/*
 * Generated by PEG.js 0.10.0.
 *
 * http://pegjs.org/
 */

"use strict";

function peg$subclass(child, parent) {
  function ctor() { this.constructor = child; }
  ctor.prototype = parent.prototype;
  child.prototype = new ctor();
}

function peg$SyntaxError(message, expected, found, location) {
  this.message  = message;
  this.expected = expected;
  this.found    = found;
  this.location = location;
  this.name     = "SyntaxError";

  if (typeof Error.captureStackTrace === "function") {
    Error.captureStackTrace(this, peg$SyntaxError);
  }
}

peg$subclass(peg$SyntaxError, Error);

peg$SyntaxError.buildMessage = function(expected, found) {
  var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },

        "class": function(expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array
              ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1])
              : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },

        any: function(expectation) {
          return "any character";
        },

        end: function(expectation) {
          return "end of input";
        },

        other: function(expectation) {
          return expectation.description;
        }
      };

  function hex(ch) {
    return ch.charCodeAt(0).toString(16).toUpperCase();
  }

  function literalEscape(s) {
    return s
      .replace(/\\/g, '\\\\')
      .replace(/"/g,  '\\"')
      .replace(/\0/g, '\\0')
      .replace(/\t/g, '\\t')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
  }

  function classEscape(s) {
    return s
      .replace(/\\/g, '\\\\')
      .replace(/\]/g, '\\]')
      .replace(/\^/g, '\\^')
      .replace(/-/g,  '\\-')
      .replace(/\0/g, '\\0')
      .replace(/\t/g, '\\t')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
  }

  function describeExpectation(expectation) {
    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
  }

  function describeExpected(expected) {
    var descriptions = new Array(expected.length),
        i, j;

    for (i = 0; i < expected.length; i++) {
      descriptions[i] = describeExpectation(expected[i]);
    }

    descriptions.sort();

    if (descriptions.length > 0) {
      for (i = 1, j = 1; i < descriptions.length; i++) {
        if (descriptions[i - 1] !== descriptions[i]) {
          descriptions[j] = descriptions[i];
          j++;
        }
      }
      descriptions.length = j;
    }

    switch (descriptions.length) {
      case 1:
        return descriptions[0];

      case 2:
        return descriptions[0] + " or " + descriptions[1];

      default:
        return descriptions.slice(0, -1).join(", ")
          + ", or "
          + descriptions[descriptions.length - 1];
    }
  }

  function describeFound(found) {
    return found ? "\"" + literalEscape(found) + "\"" : "end of input";
  }

  return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
};

function peg$DefaultTracer() {
  this.indentLevel = 0;
}

peg$DefaultTracer.prototype.trace = function(event) {
  var that = this;

  function log(event) {
    function repeat(string, n) {
       var result = "", i;

       for (i = 0; i < n; i++) {
         result += string;
       }

       return result;
    }

    function pad(string, length) {
      return string + repeat(" ", length - string.length);
    }

    if (typeof console === "object") {
      console.log(
        event.location.start.line + ":" + event.location.start.column + "-"
          + event.location.end.line + ":" + event.location.end.column + " "
          + pad(event.type, 10) + " "
          + repeat("  ", that.indentLevel) + event.rule
      );
    }
  }

  switch (event.type) {
    case "rule.enter":
      log(event);
      this.indentLevel++;
      break;

    case "rule.match":
      this.indentLevel--;
      log(event);
      break;

    case "rule.fail":
      this.indentLevel--;
      log(event);
      break;

    default:
      throw new Error("Invalid event type: " + event.type + ".");
  }
};

function peg$parse(input, options) {
  options = options !== void 0 ? options : {};

  var peg$FAILED = {},

      peg$startRuleFunctions = { start: peg$parsestart },
      peg$startRuleFunction  = peg$parsestart,

      peg$c0 = function(n) {
          // => multiple_stmt | cmd_stmt | crud_stmt
          return n
        },
      peg$c1 = function(head, tail) {
            /*
            // is in reality: { tableList: any[]; columnList: any[]; ast: T; }
            export type AstStatement<T> = T;
             => AstStatement<crud_stmt[]> */
            const cur = [head && head.ast || head];
            for (let i = 0; i < tail.length; i++) {
              if(!tail[i][3] || tail[i][3].length === 0) continue;
              cur.push(tail[i][3] && tail[i][3].ast || tail[i][3]);
            }
            return {
              tableList: Array.from(tableList),
              columnList: columnListTableAlias(columnList),
            	ast: cur
            }
          },
      peg$c2 = function(ss) {
          return {
            'type': 'union',
            'content': ss
          }
        },
      peg$c3 = function(ss) {
          return {
            'type': 'minus',
            'content': ss
          }
        },
      peg$c4 = function(ss) {
          return {
            'type': 'intersect',
            'content': ss
          }
        },
      peg$c5 = function(head, tail, ob, l) {
           /* export interface union_stmt_node extends select_stmt_node  {
               _next: union_stmt_node;
               union: 'union' | 'union all';
            }
           => AstStatement<union_stmt_node>
           */
            let cur = head
            for (let i = 0; i < tail.length; i++) {
              if(tail[i].type == 'union') {
                cur._next = tail[i].content[5]
                // cur.union = tail[i][3] ? 'union all' : 'union'
                cur.union = tail[i].content[1][0] + (tail[i].content[3] ? ' all' : '')
              }else {
                cur._next = tail[i].content[3]
                cur.union = tail[i].content[1][0]
              }       
              cur = cur._next 
            }
            if(ob) head._orderby = ob
            if(l) head._limit = l
            return {
              tableList: Array.from(tableList),
              columnList: columnListTableAlias(columnList),
              ast: head
            }
          },
      peg$c6 = "extension",
      peg$c7 = peg$literalExpectation("EXTENSION", true),
      peg$c8 = "schema",
      peg$c9 = peg$literalExpectation("SCHEMA", true),
      peg$c10 = "version",
      peg$c11 = peg$literalExpectation("VERSION", true),
      peg$c12 = function(a, e, ife, n, w, s, v, f) {
            /*
             export type nameOrLiteral = literal_string | { type: 'same', value: string; };
            => {
                type: 'create';
                keyword: 'extension';
                if_not_exists?: 'if not exists';
                extension: nameOrLiteral;
                with: 'with';
                schema: nameOrLiteral;
                version: nameOrLiteral;
                from: nameOrLiteral;
              }
            */
            return {
              type: 'create',
              keyword: e.toLowerCase(),
              if_not_exists: ife && ife[0].toLowerCase(),
              extension: commonStrToLiteral(n),
              with: w && w[0].toLowerCase(),
              schema: commonStrToLiteral(s && s[2].toLowerCase()), // <== wont that be a bug ?
              version: commonStrToLiteral(v && v[2]),
              from: commonStrToLiteral(f && f[2]),
            }
          },
      peg$c13 = function(head, tail) {
          // => create_option_character_set[]
          return createList(head, tail, 1)
        },
      peg$c14 = function(a, k, ife, t, c) {
            /*
            export type create_db_stmt = {
              type: 'create',
              keyword: 'database',
              if_not_exists?: 'if not exists',
              database: string,
              create_definition?: create_db_definition
            }
            => AstStatement<create_db_stmt>
            */
            return {
              tableList: Array.from(tableList),
              columnList: columnListTableAlias(columnList),
              ast: {
                type: a[0].toLowerCase(),
                keyword: 'database',
                if_not_exists: ife && ife[0].toLowerCase(),
                database: t,
                create_definitions: c,
              }
            }
          },
      peg$c15 = function(a, tp, ife, t, c, to, ir, as, qe) {
            /*
            export type create_table_stmt_node = create_table_stmt_node_simple | create_table_stmt_node_like;
            export interface create_table_stmt_node_base {
              type: 'create';
              keyword: 'table';
              temporary?: 'temporary';
              if_not_exists?: 'if not exists';
              table: table_ref_list;
            }
            export interface create_table_stmt_node_simple extends create_table_stmt_node_base{
              ignore_replace?: 'ignore' | 'replace';
              as?: 'as';
              query_expr?: union_stmt_node;
              create_definition?: create_table_definition;
              table_options?: table_options;
            }
            => AstStatement<create_table_stmt_node>
            */
            if(t) t.forEach(tt => tableList.add(`create::${tt.db}::${tt.table}`));
            return {
              tableList: Array.from(tableList),
              columnList: columnListTableAlias(columnList),
              ast: {
                type: a[0].toLowerCase(),
                keyword: 'table',
                temporary: tp && tp.toLowerCase(),
                if_not_exists: ife && ife[0].toLowerCase(),
                table: t,
                ignore_replace: ir && ir[0].toLowerCase(),
                as: as && as[0].toLowerCase(),
                query_expr: qe && qe.ast,
                create_definitions: c,
                table_options: to
              }
            }
          },
      peg$c16 = function(a, tp, ife, t, lt) {
            /*

            export interface create_table_stmt_node_like extends create_table_stmt_node_base{
              like: create_like_table;
            }
            => AstStatement<create_table_stmt_node>;
            */
            if(t) t.forEach(tt => tableList.add(`create::${tt.db}::${tt.table}`));
            return {
              tableList: Array.from(tableList),
              columnList: columnListTableAlias(columnList),
              ast: {
                type: a[0].toLowerCase(),
                keyword: 'table',
                temporary: tp && tp.toLowerCase(),
                if_not_exists: ife && ife[0].toLowerCase(),
                table: t,
                like: lt
              }
            }
          },
      peg$c17 = function(a, tp, ife, t, as, c) {
            /*
            export type create_sequence_stmt = {
              type: 'create',
              keyword: 'sequence',
              temporary?: 'temporary' | 'temp',
              if_not_exists?: 'if not exists',
              table: table_ref_list,
              create_definition?: create_sequence_definition_list
            }
            => AstStatement<create_sequence_stmt>
            */
            t.as = as && as[2]
            return {
              tableList: Array.from(tableList),
              columnList: columnListTableAlias(columnList),
              ast: {
                type: a[0].toLowerCase(),
                keyword: 'sequence',
                temporary: tp && tp.toLowerCase(),
                if_not_exists: ife && ife[0].toLowerCase(),
                sequence: [t],
                create_definitions: c,
              }
            }
          },
      peg$c18 = "increment",
      peg$c19 = peg$literalExpectation("INCREMENT", true),
      peg$c20 = function(k, b, n) {
          /*
          export type sequence_definition = { "resource": "sequence", prefix?: string,value: literal | column_ref }
          => sequence_definition
          */
          return {
            resource: 'sequence',
            prefix: b ? `${k.toLowerCase()} by` : k.toLowerCase(),
            value: n
          }
        },
      peg$c21 = "minvalue",
      peg$c22 = peg$literalExpectation("MINVALUE", true),
      peg$c23 = function(k, n) {
          // => sequence_definition
          return {
            resource: 'sequence',
            prefix: k.toLowerCase(),
            value: n
          }
        },
      peg$c24 = "no",
      peg$c25 = peg$literalExpectation("NO", true),
      peg$c26 = function() {
          // => sequence_definition
          return {
            resource: 'sequence',
            value: {
              type: 'origin',
              value: 'no minvalue'
            }
          }
        },
      peg$c27 = "maxvalue",
      peg$c28 = peg$literalExpectation("MAXVALUE", true),
      peg$c29 = function() {
          // => sequence_definition
          return {
            resource: 'sequence',
            value: {
              type: 'origin',
              value: 'no maxvalue'
            }
          }
        },
      peg$c30 = "start",
      peg$c31 = peg$literalExpectation("START", true),
      peg$c32 = function(k, w, n) {
          // => sequence_definition
          return {
            resource: 'sequence',
            prefix: w ? `${k.toLowerCase()} with` : k.toLowerCase(),
            value: n
          }
        },
      peg$c33 = "cache",
      peg$c34 = peg$literalExpectation("CACHE", true),
      peg$c35 = "cycle",
      peg$c36 = peg$literalExpectation("CYCLE", true),
      peg$c37 = function(n) {
          // => sequence_definition
          return {
            resource: 'sequence',
            value: {
              type: 'origin',
              value: n ? 'no cycle' : 'cycle'
            }
          }
        },
      peg$c38 = "owned",
      peg$c39 = peg$literalExpectation("OWNED", true),
      peg$c40 = "none",
      peg$c41 = peg$literalExpectation("NONE", true),
      peg$c42 = function() {
          // => sequence_definition
          return {
            resource: 'sequence',
            prefix: 'owned by',
            value: {
              type: 'origin',
              value: 'none'
            }
          }
        },
      peg$c43 = function(n, col) {
          // => sequence_definition
          return {
            resource: 'sequence',
            prefix: 'owned by',
            value: col
          }
        },
      peg$c44 = function(head, tail) {
          // => create_sequence_definition[]
          return createList(head, tail, 1)
      },
      peg$c45 = function(a, kw, t, co, n, on, ta, um, cols, wr, ts, w) {
          /*
          export interface create_index_stmt_node {
            type: 'create';
            index_type?: 'unique';
            keyword: 'index';
            concurrently?: 'concurrently';
            index: string;
            on_kw: string;
            table: table_name;
            index_using?: index_type;
            index_columns: column_order[];
            with?: index_option[];
            with_before_where: true;
            tablespace?: {type: 'origin'; value: string; }
            where?: where_clause;
          }
          => AstStatement<create_index_stmt_node>
          */
          return {
              tableList: Array.from(tableList),
              columnList: columnListTableAlias(columnList),
              ast: {
                type: a[0].toLowerCase(),
                index_type: kw && kw.toLowerCase(),
                keyword: t.toLowerCase(),
                concurrently: co && co.toLowerCase(),
                index: n,
                on_kw: on[0].toLowerCase(),
                table: ta,
                index_using: um,
                index_columns: cols,
                with: wr && wr[4],
                with_before_where: true,
                tablespace: ts && { type: 'origin', value: ts[2] },
                where: w,
              }
          }
        },
      peg$c46 = function(head, tail) {
          // => column_order[]
          return createList(head, tail)
        },
      peg$c47 = "nulls",
      peg$c48 = peg$literalExpectation("NULLS", true),
      peg$c49 = "first",
      peg$c50 = peg$literalExpectation("FIRST", true),
      peg$c51 = "last",
      peg$c52 = peg$literalExpectation("LAST", true),
      peg$c53 = function(c, ca, op, o, nf) {
          /*
          => {
            column: expr;
            collate: collate_expr;
            opclass: ident;
            order: 'asc' | 'desc';
            nulls: 'nulls last' | 'nulls first';
          }
          */
          return {
            column: c,
            collate: ca,
            opclass: op,
            order: o && o.toLowerCase() || 'asc',
            nulls: nf && `${nf[0].toLowerCase()} ${nf[2].toLowerCase()}`,
          }
        },
      peg$c54 = function(t) {
          // => { type: 'like'; table: table_ref_list; }
          return {
            type: 'like',
            table: t
          }
        },
      peg$c55 = function(e) {
           // => create_like_table_simple & { parentheses?: boolean; }
            e.parentheses = true;
            return e;
        },
      peg$c56 = function(head, tail) {
            // => create_definition[]
            return createList(head, tail);
          },
      peg$c57 = "auto_increment",
      peg$c58 = peg$literalExpectation("AUTO_INCREMENT", true),
      peg$c59 = "unique",
      peg$c60 = peg$literalExpectation("UNIQUE", true),
      peg$c61 = "primary",
      peg$c62 = peg$literalExpectation("PRIMARY", true),
      peg$c63 = "key",
      peg$c64 = peg$literalExpectation("KEY", true),
      peg$c65 = function(c, d, clc, a, u, co, ca, cf, s, re) {
            /*
            => {
              column: column_ref;
              definition: data_type;
              nullable: column_constraint['nullable'];
              default_val: column_constraint['default_val'];
              auto_increment?: 'auto_increment';
              unique_or_primary?: 'unique' | 'primary key';
              comment?: keyword_comment;
              collate?: collate_expr;
              column_format?: column_format;
              storage?: storage;
              reference_definition?: reference_definition;
              resource: 'column';
            }
            */
            columnList.add(`create::${c.table}::${c.column}`)
            return {
              column: c,
              definition: d,
              nullable: clc && clc.nullable,
              default_val: clc && clc.default_val,
              auto_increment: a && a.toLowerCase(),
              unique_or_primary: Array.isArray(u) ? `${u[0].toLowerCase()} ${u[2].toLowerCase()}` : u,
              comment: co,
              collate: ca,
              column_format: cf,
              storage:s,
              reference_definition: re,
              resource: 'column'
            }
          },
      peg$c66 = function(n, df) {
          // => { nullable: literal_null | literal_not_null; default_val: default_expr; }
          if (n && !n.value) n.value = 'null'
          return {
            default_val: df,
            nullable: n
          }
        },
      peg$c67 = function(df, n) {
          // => { nullable: literal_null | literal_not_null; default_val: default_expr; }
          if (n && !n.value) n.value = 'null'
          return {
            default_val: df,
            nullable: n
          }
        },
      peg$c68 = function(ca) {
          // => { type: 'collate'; value: ident; }
          return {
            type: 'collate',
            value: ca,
          }
        },
      peg$c69 = "column_format",
      peg$c70 = peg$literalExpectation("COLUMN_FORMAT", true),
      peg$c71 = "fixed",
      peg$c72 = peg$literalExpectation("FIXED", true),
      peg$c73 = "dynamic",
      peg$c74 = peg$literalExpectation("DYNAMIC", true),
      peg$c75 = "default",
      peg$c76 = peg$literalExpectation("DEFAULT", true),
      peg$c77 = function(k, f) {
          // => { type: 'column_format'; value: 'fixed' | 'dynamic' | 'default'; }
          return {
            type: 'column_format',
            value: f.toLowerCase()
          }
        },
      peg$c78 = "storage",
      peg$c79 = peg$literalExpectation("STORAGE", true),
      peg$c80 = "disk",
      peg$c81 = peg$literalExpectation("DISK", true),
      peg$c82 = "memory",
      peg$c83 = peg$literalExpectation("MEMORY", true),
      peg$c84 = function(k, s) {
          // => { type: 'storage'; value: 'disk' | 'memory' }
          return {
            type: 'storage',
            value: s.toLowerCase()
          }
        },
      peg$c85 = function(ce) {
          // => { type: 'default'; value: literal | expr; }
          return {
            type: 'default',
            value: ce
          }
        },
      peg$c86 = function(head, tail) {
          // => (ALTER_ALGORITHM | ALTER_LOCK)[]
          return createList(head, tail, 1)
        },
      peg$c87 = function(a, r, t) {
            /*
            export interface drop_stmt_node {
              type: 'drop';
              keyword: 'table';
              name: table_ref_list;
            }
            => AstStatement<drop_stmt_node>
            */
            if(t) t.forEach(tt => tableList.add(`${a}::${tt.db}::${tt.table}`));
            return {
              tableList: Array.from(tableList),
              columnList: columnListTableAlias(columnList),
              ast: {
                type: a.toLowerCase(),
                keyword: r.toLowerCase(),
                name: t
              }
            };
          },
      peg$c88 = function(a, r, i, t, op) {
            /*
            export interface drop_index_stmt_node {
              type: 'drop';
              keyword: string;
              name: column_ref;
              table: table_name;
              options?: drop_index_opt;
            }
            => AstStatement<drop_index_stmt_node>
            */
            return {
              tableList: Array.from(tableList),
              columnList: columnListTableAlias(columnList),
              ast: {
                type: a.toLowerCase(),
                keyword: r.toLowerCase(),
                name: i,
                table: t,
                options: op
              }
            };
          },
      peg$c89 = function(a, kw, t) {
            /*
            export interface truncate_stmt_node {
              type: 'trucate';
              keyword: 'table';
              name: table_ref_list;
            }
            => AstStatement<truncate_stmt_node>
            */
            if(t) t.forEach(tt => tableList.add(`${a}::${tt.db}::${tt.table}`));
            return {
              tableList: Array.from(tableList),
              columnList: columnListTableAlias(columnList),
              ast: {
                type: a.toLowerCase(),
                keyword: kw && kw.toLowerCase() || 'table',
                name: t
              }
            };
          },
      peg$c90 = function(d) {
            /*
            export interface use_stmt_node {
              type: 'use';
              db: ident;
            }
            => AstStatement<use_stmt_node>
            */
            tableList.add(`use::${d}::null`);
            return {
              tableList: Array.from(tableList),
              columnList: columnListTableAlias(columnList),
              ast: {
                type: 'use',
                db: d
              }
            };
          },
      peg$c91 = function(t, e) {
            /*
            export interface alter_table_stmt_node {
              type: 'alter';
              table: table_ref_list;
              expr: alter_action_list;
            }
            => AstStatement<alter_table_stmt_node>
            */
            if (t && t.length > 0) t.forEach(table => tableList.add(`alter::${table.db}::${table.table}`));
            return {
              tableList: Array.from(tableList),
              columnList: columnListTableAlias(columnList),
              ast: {
                type: 'alter',
                table: t,
                expr: e
              }
            };
          },
      peg$c92 = function(head, tail) {
            // => alter_action[]
            return createList(head, tail);
          },
      peg$c93 = function(kc, cd) {
            /*
            => {
              action: 'add';
              keyword: KW_COLUMN;
              resource: 'column';
              type: 'alter';
            } & create_column_definition;
            */
            return {
              action: 'add',
              ...cd,
              keyword: kc,
              resource: 'column',
              type: 'alter',
            }
          },
      peg$c94 = function(kc, c) {
            /* => {
              action: 'drop';
              collumn: column_ref;
              keyword: KW_COLUMN;
              resource: 'column';
              type: 'alter';
            } */
            return {
              action: 'drop',
              column: c,
              keyword: kc,
              resource: 'column',
              type: 'alter',
            }
          },
      peg$c95 = function(id) {
             /* => {
               action: 'add';
               type: 'alter';
               } & create_index_definition */
            return {
              action: 'add',
              type: 'alter',
              ...id,
            }
          },
      peg$c96 = function(kw, tn) {
             /* => {
               action: 'rename';
               type: 'alter';
               resource: 'table';
               keyword?: 'to' | 'as';
               table: ident;
               } */
          return {
            action: 'rename',
            type: 'alter',
            resource: 'table',
            keyword: kw && kw[0].toLowerCase(),
            table: tn
          }
        },
      peg$c97 = "algorithm",
      peg$c98 = peg$literalExpectation("ALGORITHM", true),
      peg$c99 = "instant",
      peg$c100 = peg$literalExpectation("INSTANT", true),
      peg$c101 = "inplace",
      peg$c102 = peg$literalExpectation("INPLACE", true),
      peg$c103 = "copy",
      peg$c104 = peg$literalExpectation("COPY", true),
      peg$c105 = function(s, val) {
          /* => {
              type: 'alter';
              keyword: 'algorithm';
              resource: 'algorithm';
              symbol?: '=';
              algorithm: 'DEFAULT' | 'INSTANT' | 'INPLACE' | 'COPY';
            }*/
          return {
            type: 'alter',
            keyword: 'algorithm',
            resource: 'algorithm',
            symbol: s,
            algorithm: val
          }
        },
      peg$c106 = "lock",
      peg$c107 = peg$literalExpectation("LOCK", true),
      peg$c108 = "shared",
      peg$c109 = peg$literalExpectation("SHARED", true),
      peg$c110 = "exclusive",
      peg$c111 = peg$literalExpectation("EXCLUSIVE", true),
      peg$c112 = function(s, val) {
          /* => {
            type: 'alter';
            keyword: 'lock';
            resource: 'lock';
            symbol?: '=';
            lock: 'DEFAULT' | 'NONE' | 'SHARED' | 'EXCLUSIVE';
          }*/
          return {
            type: 'alter',
            keyword: 'lock',
            resource: 'lock',
            symbol: s,
            lock: val
          }
        },
      peg$c113 = function(kc, c, t, de, id) {
             /* => {
               index: column;
               definition: cte_column_definition;
               keyword: 'index' | 'key';
               index_type?: index_type;
               resource: 'index';
               index_options?: index_options;
             }*/
            return {
              index: c,
              definition: de,
              keyword: kc.toLowerCase(),
              index_type: t,
              resource: 'index',
              index_options: id,
            }
          },
      peg$c114 = function(p, kc, c, de, id) {
            /* => {
                index: column;
                definition: cte_column_definition;
                keyword: 'fulltext' | 'spatial' | 'fulltext key' | 'spatial key' | 'fulltext index' | 'spatial index';
                index_options?: index_options;
                resource: 'index';
              }*/
            return {
              index: c,
              definition: de,
              keyword: kc && `${p.toLowerCase()} ${kc.toLowerCase()}` || p.toLowerCase(),
              index_options: id,
              resource: 'index',
            }
          },
      peg$c115 = function(kc, c) {
          // => { keyword: 'constraint'; constraint: ident; }
          return {
            keyword: kc.toLowerCase(),
            constraint: c
          }
        },
      peg$c116 = "primary key",
      peg$c117 = peg$literalExpectation("PRIMARY KEY", true),
      peg$c118 = function(kc, p, t, de, id) {
          /* => {
            constraint?: constraint_name['constraint'];
            definition: cte_column_definition;
            constraint_type: 'primary key';
            index_type?: index_type;
            resource: 'constraint';
            index_options?: index_options;
          }*/
          return {
              constraint: kc && kc.constraint,
              definition: de,
              constraint_type: p.toLowerCase(),
              keyword: kc && kc.keyword,
              index_type: t,
              resource: 'constraint',
              index_options: id,
            }
        },
      peg$c119 = function(kc, u, p, i, t, de, id) {
          /* => {
            constraint?: constraint_name['constraint'];
            definition: cte_column_definition;
            constraint_type: 'unique key' | 'unique' | 'unique index';
            index_type?: index_type;
            resource: 'constraint';
            index_options?: index_options;
          }*/
          return {
              constraint: kc && kc.constraint,
              definition: de,
              constraint_type: p && `${u.toLowerCase()} ${p.toLowerCase()}` || u.toLowerCase(),
              keyword: kc && kc.keyword,
              index_type: t,
              index: i,
              resource: 'constraint',
              index_options: id
            }
        },
      peg$c120 = "foreign key",
      peg$c121 = peg$literalExpectation("FOREIGN KEY", true),
      peg$c122 = function(kc, p, i, de, id) {
          /* => {
            constraint?: constraint_name['constraint'];
            definition: cte_column_definition;
            constraint_type: 'FOREIGN KEY';
            keyword: constraint_name['keyword'];
            index?: column;
            resource: 'constraint';
            reference_definition?: reference_definition;
          }*/
          return {
              constraint: kc && kc.constraint,
              definition: de,
              constraint_type: p,
              keyword: kc && kc.keyword,
              index: i,
              resource: 'constraint',
              reference_definition: id
            }
        },
      peg$c123 = "match full",
      peg$c124 = peg$literalExpectation("MATCH FULL", true),
      peg$c125 = "match partial",
      peg$c126 = peg$literalExpectation("MATCH PARTIAL", true),
      peg$c127 = "match simple",
      peg$c128 = peg$literalExpectation("MATCH SIMPLE", true),
      peg$c129 = function(kc, t, de, m, od, ou) {
          /* => {
              definition: cte_column_definition;
              table: table_ref_list;
              keyword: 'references';
              match: 'match full' | 'match partial' | 'match simple';
              on_delete?: on_reference;
              on_update?: on_reference;
            }*/
          return {
              definition: de,
              table: t,
              keyword: kc.toLowerCase(),
              match:m && m.toLowerCase(),
              on_delete: od,
              on_update: ou,
            }
        },
      peg$c130 = "on delete",
      peg$c131 = peg$literalExpectation("ON DELETE", true),
      peg$c132 = "on update",
      peg$c133 = peg$literalExpectation("ON UPDATE", true),
      peg$c134 = function(kw, ro) {
          // => { type: 'on delete' | 'on update'; value: reference_option; }
          return {
            type: kw.toLowerCase(),
            value: ro
          }
        },
      peg$c135 = "restrict",
      peg$c136 = peg$literalExpectation("RESTRICT", true),
      peg$c137 = "cascade",
      peg$c138 = peg$literalExpectation("CASCADE", true),
      peg$c139 = "set null",
      peg$c140 = peg$literalExpectation("SET NULL", true),
      peg$c141 = "no action",
      peg$c142 = peg$literalExpectation("NO ACTION", true),
      peg$c143 = "set default",
      peg$c144 = peg$literalExpectation("SET DEFAULT", true),
      peg$c145 = function(kc) {
          // => 'restrict' | 'cascade' | 'set null' | 'no action' | 'set default'
          return kc.toLowerCase()
        },
      peg$c146 = "trigger",
      peg$c147 = peg$literalExpectation("TRIGGER", true),
      peg$c148 = "before",
      peg$c149 = peg$literalExpectation("BEFORE", true),
      peg$c150 = "after",
      peg$c151 = peg$literalExpectation("AFTER", true),
      peg$c152 = "instead of",
      peg$c153 = peg$literalExpectation("INSTEAD OF", true),
      peg$c154 = "on",
      peg$c155 = peg$literalExpectation("ON", true),
      peg$c156 = "execute",
      peg$c157 = peg$literalExpectation("EXECUTE", true),
      peg$c158 = "procedure",
      peg$c159 = peg$literalExpectation("PROCEDURE", true),
      peg$c160 = function(kw, kc, t, c, p, te, on, tn, fr, de, fe, tw, fc, fct) {
          /*
          => {
            type: 'create';
            constraint: string;
            location: 'before' | 'after' | 'instead of';
            events: trigger_event_list;
            table: table_name;
            from?: table_name;
            deferrable?: trigger_deferrable;
            for_each?: trigger_for_row;
            when?: trigger_when;
            execute: {
              keyword: 'execute procedure';
              expr: proc_func_call;
            };
            constraint_type: 'trigger';
            keyword: 'trigger';
            constraint_kw: 'constraint';
            resource: 'constraint';
          }
          */
          return {
              type: 'create',
              constraint: c,
              location: p && p.toLowerCase(),
              events: te,
              table: tn,
              from: fr && fr[2],
              deferrable: de,
              for_each: fe,
              when: tw,
              execute: {
                keyword: 'execute procedure',
                expr: fct
              },
              constraint_type: t && t.toLowerCase(),
              keyword: t && t.toLowerCase(),
              constraint_kw: kc && kc.toLowerCase(),
              resource: 'constraint',
            }
        },
      peg$c161 = function(kw) {
          // => { keyword: 'insert' | 'delete' | 'truncate' }
          const keyword = Array.isArray(kw) ? kw[0].toLowerCase() : kw.toLowerCase()
          return {
            keyword,
          }
        },
      peg$c162 = "of",
      peg$c163 = peg$literalExpectation("OF", true),
      peg$c164 = function(kw, a) {
          // => { keyword: 'update'; args?: { keyword: 'of', columns: column_ref_list; }}
          return {
            keyword: kw && kw[0] && kw[0].toLowerCase(),
            args: a && { keyword: a[0], columns: a[2] } || null
          }
        },
      peg$c165 = function(head, tail) {
          // => trigger_event[];
          return createList(head, tail)
        },
      peg$c166 = "not",
      peg$c167 = peg$literalExpectation("NOT", true),
      peg$c168 = "deferrable",
      peg$c169 = peg$literalExpectation("DEFERRABLE", true),
      peg$c170 = "initially immediate",
      peg$c171 = peg$literalExpectation("INITIALLY IMMEDIATE", true),
      peg$c172 = "initially deferred",
      peg$c173 = peg$literalExpectation("INITIALLY DEFERRED", true),
      peg$c174 = function(kw, args) {
          // => { keyword: 'deferrable' | 'not deferrable'; args: 'initially immediate' | 'initially deferred' }
          return {
            keyword: kw && kw[0] ? `${kw[0].toLowerCase()} deferrable` : 'deferrable',
            args: args && args.toLowerCase(),
          }
        },
      peg$c175 = "for",
      peg$c176 = peg$literalExpectation("FOR", true),
      peg$c177 = "each",
      peg$c178 = peg$literalExpectation("EACH", true),
      peg$c179 = "row",
      peg$c180 = peg$literalExpectation("ROW", true),
      peg$c181 = "statement",
      peg$c182 = peg$literalExpectation("STATEMENT", true),
      peg$c183 = function(kw, e, ob) {
          // => { keyword: 'for' | 'for each'; args: 'row' | 'statement' }
          return {
            keyword: e ? `${kw.toLowerCase()} ${e.toLowerCase()}` : kw.toLowerCase(),
            args: ob.toLowerCase()
          }
        },
      peg$c184 = function(condition) {
          // => { type: 'when'; cond: expr; parentheses: true; }
          return {
            type: 'when',
            cond: condition,
            parentheses: true,
          }
        },
      peg$c185 = function(head, tail) {
          // => table_option[]
          return createList(head, tail)
        },
      peg$c186 = "character",
      peg$c187 = peg$literalExpectation("CHARACTER", true),
      peg$c188 = "set",
      peg$c189 = peg$literalExpectation("SET", true),
      peg$c190 = function() {
          // => string
          return 'CHARACTER SET'
        },
      peg$c191 = "charset",
      peg$c192 = peg$literalExpectation("CHARSET", true),
      peg$c193 = "collate",
      peg$c194 = peg$literalExpectation("COLLATE", true),
      peg$c195 = function(kw, t, s, v) {
          /* => {
            keyword: 'character set' | 'charset' | 'collate' | 'default character set' | 'default charset' | 'default collate';
            symbol: '=';
            value: ident_name;
            } */
          return {
            keyword: kw && `${kw[0].toLowerCase()} ${t.toLowerCase()}` || t.toLowerCase(),
            symbol: s,
            value: v
          }
        },
      peg$c196 = "avg_row_length",
      peg$c197 = peg$literalExpectation("AVG_ROW_LENGTH", true),
      peg$c198 = "key_block_size",
      peg$c199 = peg$literalExpectation("KEY_BLOCK_SIZE", true),
      peg$c200 = "max_rows",
      peg$c201 = peg$literalExpectation("MAX_ROWS", true),
      peg$c202 = "min_rows",
      peg$c203 = peg$literalExpectation("MIN_ROWS", true),
      peg$c204 = "stats_sample_pages",
      peg$c205 = peg$literalExpectation("STATS_SAMPLE_PAGES", true),
      peg$c206 = function(kw, s, v) {
          /* => {
            keyword: 'auto_increment' | 'avg_row_length' | 'key_block_size' | 'max_rows' | 'min_rows' | 'stats_sample_pages';
            symbol: '=';
            value: number; // <== literal_numeric['value']
            } */
          return {
            keyword: kw.toLowerCase(),
            symbol: s,
            value: v.value
          }
        },
      peg$c207 = "connection",
      peg$c208 = peg$literalExpectation("CONNECTION", true),
      peg$c209 = function(kw, s, c) {
          // => { keyword: 'connection' | 'comment'; symbol: '='; value: string; }
          return {
            keyword: kw.toLowerCase(),
            symbol: s,
            value: `'${c.value}'`
          }
        },
      peg$c210 = "compression",
      peg$c211 = peg$literalExpectation("COMPRESSION", true),
      peg$c212 = "'",
      peg$c213 = peg$literalExpectation("'", false),
      peg$c214 = "zlib",
      peg$c215 = peg$literalExpectation("ZLIB", true),
      peg$c216 = "lz4",
      peg$c217 = peg$literalExpectation("LZ4", true),
      peg$c218 = function(kw, s, v) {
          // => { keyword: 'compression'; symbol: '='; value: "'ZLIB'" | "'LZ4'" | "'NONE'" }
          return {
            keyword: kw.toLowerCase(),
            symbol: s,
            value: v.join('').toUpperCase()
          }
        },
      peg$c219 = "engine",
      peg$c220 = peg$literalExpectation("ENGINE", true),
      peg$c221 = function(kw, s, c) {
          // => { keyword: 'engine'; symbol: '='; value: string; }
          return {
            keyword: kw.toLowerCase(),
            symbol: s,
            value: c.toUpperCase()
          }
        },
      peg$c222 = function(fsid) {
             // => create_fulltext_spatial_index_definition & { action: 'add'; type: 'alter' }
            return {
              action: 'add',
              type: 'alter',
              ...fsid,
            }
          },
      peg$c223 = function(t) {
            /*
            export interface rename_stmt_node {
              type: 'rename';
              table: table_to_list;
            }
             => AstStatement<rename_stmt_node>
             */
            t.forEach(tg => tg.forEach(dt => dt.table && tableList.add(`rename::${dt.db}::${dt.table}`)))
            return {
              tableList: Array.from(tableList),
              columnList: columnListTableAlias(columnList),
              ast: {
                type: 'rename',
                table: t
              }
            };
          },
      peg$c224 = function(kw, a) {
            /*
            export interface set_stmt_node {
              type: 'set';
              expr: assign_stmt & { keyword?: 'GLOBAL' | 'SESSION' | 'LOCAL' | 'PERSIST' | 'PERSIST_ONLY'; };
            }
             => AstStatement<set_stmt_node>
             */
          a.keyword = kw
          return {
            tableList: Array.from(tableList),
            columnList: columnListTableAlias(columnList),
            ast: {
              type: 'set',
              expr: a
            }
          }
        },
      peg$c225 = "in",
      peg$c226 = peg$literalExpectation("IN", true),
      peg$c227 = "access share",
      peg$c228 = peg$literalExpectation("ACCESS SHARE", true),
      peg$c229 = "row share",
      peg$c230 = peg$literalExpectation("ROW SHARE", true),
      peg$c231 = "row exclusive",
      peg$c232 = peg$literalExpectation("ROW EXCLUSIVE", true),
      peg$c233 = "share update exclusive",
      peg$c234 = peg$literalExpectation("SHARE UPDATE EXCLUSIVE", true),
      peg$c235 = "share row exclusive",
      peg$c236 = peg$literalExpectation("SHARE ROW EXCLUSIVE", true),
      peg$c237 = "access exclusive",
      peg$c238 = peg$literalExpectation("ACCESS EXCLUSIVE", true),
      peg$c239 = "share",
      peg$c240 = peg$literalExpectation("SHARE", true),
      peg$c241 = "mode",
      peg$c242 = peg$literalExpectation("MODE", true),
      peg$c243 = function(m) {
          // => { mode: string; }
          return {
            mode: `in ${m.toLowerCase()} mode`
          }
        },
      peg$c244 = "nowait",
      peg$c245 = peg$literalExpectation("NOWAIT", true),
      peg$c246 = function(k, t, lm, nw) {

            /*
            export interface lock_stmt_node {
              type: 'lock';
              keyword: 'lock';
              tables: [[table_base], ...{table: table_ref}[]]; // see table_ref_list
              lock_mode?: lock_mode;
              nowait?: 'NOWAIT';
            }
             => AstStatement<lock_stmt_node>
             */

          if (t) t.forEach(tt => tableList.add(`lock::${tt.db}::${tt.table}`))
          return {
            tableList: Array.from(tableList),
            columnList: columnListTableAlias(columnList),
            ast: {
              type: 'lock',
              keyword: k && k.toLowerCase(),
              tables: t.map((table) => ({ table })),
              lock_mode: lm,
              nowait: nw
            }
          }
        },
      peg$c247 = function(e) {
          /*
          export interface call_stmt_node {
            type: 'call';
            expr: proc_func_call;
          }
             => AstStatement<call_stmt_node>
             */
          return {
            tableList: Array.from(tableList),
            columnList: columnListTableAlias(columnList),
            ast: {
              type: 'call',
              expr: e
            }
          }
        },
      peg$c248 = "(",
      peg$c249 = peg$literalExpectation("(", false),
      peg$c250 = ")",
      peg$c251 = peg$literalExpectation(")", false),
      peg$c252 = function(s) {
          /*
          export interface select_stmt_node extends select_stmt_nake  {
             parentheses_symbol: true;
            }
            => select_stmt_node
            */
            return {
              ...s[2],
              parentheses_symbol: true,
            }
          },
      peg$c253 = function(head, tail) {
            // => cte_definition[]
            return createList(head, tail);
          },
      peg$c254 = function(cte) {
            // => [cte_definition & {recursive: true; }]
            cte.recursive = true;
            return [cte]
          },
      peg$c255 = function(name, columns, stmt) {
          // => { name: ident_name; stmt: union_stmt; columns?: cte_column_definition; }
            return { name, stmt, columns };
          },
      peg$c256 = function(head, tail) {
          // => column[]
            return createList(head, tail);
          },
      peg$c257 = function(cte, opts, d, c, f, w, g, h, o, l) {
            /* => {
                with?: with_clause;
                type: 'select';
                options?: option_clause;
                distinct?: 'DISTINCT';
                columns: column_clause;
                from?: from_clause;
                where?: where_clause;
                groupby?: group_by_clause;
                having?: having_clause;
                orderby?: order_by_clause;
                limit?: limit_clause;
              }*/
            if(f) f.forEach(info => info.table && tableList.add(`select::${info.db}::${info.table}`));
            return {
                with: cte,
                type: 'select',
                options: opts,
                distinct: d,
                columns: c,
                from: f,
                where: w,
                groupby: g,
                having: h,
                orderby: o,
                limit: l
            };
        },
      peg$c258 = function(head, tail) {
          // => query_option[]
          const opts = [head];
          for (let i = 0, l = tail.length; i < l; ++i) {
            opts.push(tail[i][1]);
          }
          return opts;
        },
      peg$c259 = function(option) {
            // =>  'SQL_CALC_FOUND_ROWS'| 'SQL_CACHE'| 'SQL_NO_CACHE'| 'SQL_BIG_RESULT'| 'SQL_SMALL_RESULT'| 'SQL_BUFFER_RESULT'
            return option;
          },
      peg$c260 = function(head, tail) {
            // => 'ALL' | '*' | column_list_item[]
            columnList.add('select::null::(.*)');
            if (tail && tail.length > 0) {
              head[0] = {
                expr: {
                  type: 'column_ref',
                  table: null,
                  column: '*'
                },
                as: null
              };
              return createList(head[0], tail);
            }
            return head[0];
          },
      peg$c261 = function(head, tail) {
          // => column_list_item[]
            return createList(head, tail);
          },
      peg$c262 = function(e, s, t, alias) {
          // => { type: 'cast'; expr: expr; symbol: '::'; target: data_type;  as?: null; }
          return {
            as: alias,
            type: 'cast',
            expr: e,
            symbol: '::',
            target: t
          }
        },
      peg$c263 = function(tbl) {
          // => { type: 'star_ref'; expr: column_ref; as: null; }

            columnList.add(`select::${tbl}::(.*)`);
            return {
              type: 'star_ref',
              expr: {
                type: 'column_ref',
                table: tbl,
                column: '*'
              },
              as: null
            };
          },
      peg$c264 = function(e, alias) {
          // => { type: 'expr'; expr: expr; as?: alias_clause; }
            return { type: 'expr', expr: e, as: alias };
          },
      peg$c265 = function(i) { /*=>alias_ident*/ return i; },
      peg$c266 = function(i) { /*=>ident*/ return i; },
      peg$c267 = function(l) { /*=>table_ref_list*/return l; },
      peg$c268 = function(head, tail) {
          // => table_to_item[]
            return createList(head, tail);
          },
      peg$c269 = function(head, tail) {
          // => table_name[]
            return [head, tail]
          },
      peg$c270 = "btree",
      peg$c271 = peg$literalExpectation("BTREE", true),
      peg$c272 = "hash",
      peg$c273 = peg$literalExpectation("HASH", true),
      peg$c274 = "gist",
      peg$c275 = peg$literalExpectation("GIST", true),
      peg$c276 = "gin",
      peg$c277 = peg$literalExpectation("GIN", true),
      peg$c278 = function(t) {
          // => { keyword: 'using'; type: 'btree' | 'hash' | 'gist' | 'gin' }
          return {
            keyword: 'using',
            type: t.toLowerCase(),
          }
        },
      peg$c279 = function(head, tail) {
          // => index_option[]
          return createList(head, tail)
        },
      peg$c280 = function(head, tail) {
          // => index_option[]
          const result = [head];
          for (let i = 0; i < tail.length; i++) {
            result.push(tail[i][1]);
          }
          return result;
        },
      peg$c281 = function(k, e, kbs) {
          // => { type: 'key_block_size'; symbol: '='; expr: number; }
          return {
            type: k.toLowerCase(),
            symbol: e,
            expr: kbs
          }
        },
      peg$c282 = function(k, e, kbs) {
          // => { type: ident_name; symbol: '='; expr: number | {type: 'origin'; value: ident; }; }
          return {
            type: k.toLowerCase(),
            symbol: e,
            expr: typeof kbs === 'string' && { type: 'origin', value: kbs } || kbs
          };
        },
      peg$c283 = "with",
      peg$c284 = peg$literalExpectation("WITH", true),
      peg$c285 = "parser",
      peg$c286 = peg$literalExpectation("PARSER", true),
      peg$c287 = function(pn) {
          // => { type: 'with parser'; expr: ident_name }
          return {
            type: 'with parser',
            expr: pn
          }
        },
      peg$c288 = "visible",
      peg$c289 = peg$literalExpectation("VISIBLE", true),
      peg$c290 = "invisible",
      peg$c291 = peg$literalExpectation("INVISIBLE", true),
      peg$c292 = function(k) {
          // => { type: 'visible'; expr: 'visible' } | { type: 'invisible'; expr: 'invisible' }
          return {
            type: k.toLowerCase(),
            expr: k.toLowerCase()
          }
        },
      peg$c293 = function(head, tail) {
            // => [table_base, ...table_ref[]]
            tail.unshift(head);
            tail.forEach(tableInfo => {
              const { table, as } = tableInfo
              tableAlias[table] = table
              if (as) tableAlias[as] = table
              refreshColumnList(columnList)
            })
            return tail;
          },
      peg$c294 = function(t) { /* => table_base */ return t; },
      peg$c295 = function(t) { /* => table_join */ return t; },
      peg$c296 = function(op, t, head, tail) {
            // => table_base & {join: join_op; using: ident_name[]; }
            t.join = op;
            t.using = createList(head, tail);
            return t;
          },
      peg$c297 = function(op, t, expr) {
          // => table_base & {join: join_op; on?: on_clause; }
            t.join = op;
            t.on   = expr;
            return t;
          },
      peg$c298 = function(op, stmt, alias, expr) {
          /* => {
            expr: union_stmt & { parentheses: true; };
            as?: alias_clause;
            join: join_op;
            on?: on_clause;
          }*/
          stmt.parentheses = true;
          return {
            expr: stmt,
            as: alias,
            join: op,
            on: expr
          };
        },
      peg$c299 = function() {
          // => { type: 'dual' }
            return {
              type: 'dual'
            };
        },
      peg$c300 = function(t, alias) {
          // => table_name & { as?: alias_clause; }
            if (t.type === 'var') {
              t.as = alias;
              return t;
            } else {
              return {
                db: t.db,
                table: t.table,
                as: alias
              };
            }
          },
      peg$c301 = function(stmt, alias) {
          // => { expr: union_stmt; as?: alias_clause; }
            stmt.parentheses = true;
            return {
              expr: stmt,
              as: alias
            };
          },
      peg$c302 = function() { /* => 'LEFT JOIN' */ return 'LEFT OUTER JOIN'; },
      peg$c303 = function() { /* =>  'RIGHT JOIN' */ return 'RIGHT OUTER JOIN'; },
      peg$c304 = function() { /* => 'FULL JOIN' */ return 'FULL OUTER JOIN'; },
      peg$c305 = function() { /* => 'FULL JOIN' */ return 'CROSS JOIN'; },
      peg$c306 = function() { /* => 'FULL JOIN' */ return 'NATURAL JOIN'; },
      peg$c307 = function() { /* => 'INNER JOIN' */ return 'INNER JOIN'; },
      peg$c308 = function(dt, schema, tail) {
            // => { db?: ident; table: ident | '*'; }
            const obj = { db: null, table: dt };
            if (tail !== null) {
              obj.db = `${dt}.${schema[3]}`;
              obj.table = tail[3];
            }
            return obj;
          },
      peg$c309 = function(dt) {
          // => IGNORE
            tableList.add(`select::${dt}::(.*)`);
            return {
              db: dt,
              table: '*'
            }
          },
      peg$c310 = function(dt, tail) {
          // => IGNORE
            const obj = { db: null, table: dt };
            if (tail !== null) {
              obj.db = dt;
              obj.table = tail[3];
            }
            return obj;
          },
      peg$c311 = function(v) {
          // => IGNORE
            v.db = null;
            v.table = v.name;
            return v;
          },
      peg$c312 = function(e) { /* => expr */ return e; },
      peg$c313 = function(e) { /* => expr_list['value'] */ return e.value; },
      peg$c314 = function(head, tail) {
          // => { type: 'expr_list'; value: expr[] }
            const el = { type: 'expr_list' };
            el.value = createList(head, tail);
            return el;
          },
      peg$c315 = function(name, l) {
            // => { type: 'function'; name: string; args: expr_list; }
            return {
              type: 'function',
              name: name,
              args: l ? l: { type: 'expr_list', value: [] }
            };
          },
      peg$c316 = function() {
          return "GROUPING SETS"
        },
      peg$c317 = function(head, tail) {
          // => column_ref[]
            return createList(head, tail);
          },
      peg$c318 = function(ws) {
          // => { window_specification: window_specification; parentheses: boolean }
          return {
            window_specification: ws || {},
            parentheses: true
          }
        },
      peg$c319 = function(bc, l, w) {
          // => { name: null; partitionby: partition_by_clause; orderby: order_by_clause; window_frame_clause: string }
          return {
            name: null,
            partitionby: bc,
            orderby: l,
            window_frame_clause: w
          }
        },
      peg$c320 = function(bc, l) {
          // => { name: null; partitionby: partition_by_clause; orderby: order_by_clause; window_frame_clause: null }
          return {
            name: null,
            partitionby: bc,
            orderby: l,
            window_frame_clause: null
          }
        },
      peg$c321 = function(type, s) {
          // => string
          return `${type} ${s.value}`
        },
      peg$c322 = function(type, p, f) {
          // => string
          return `${type} between ${p.value} and ${f.value}`
        },
      peg$c323 = "following",
      peg$c324 = peg$literalExpectation("FOLLOWING", true),
      peg$c325 = function(s) {
          // => string
          s.value += ' FOLLOWING'
          return s
        },
      peg$c326 = "preceding",
      peg$c327 = peg$literalExpectation("PRECEDING", true),
      peg$c328 = function(s) {
          // => string
          s.value += ' PRECEDING'
          return s
        },
      peg$c329 = "current",
      peg$c330 = peg$literalExpectation("CURRENT", true),
      peg$c331 = function() {
          // => { type: 'single_quote_string'; value: string }
          return { type: 'single_quote_string', value: 'current row' }
        },
      peg$c332 = "unbounded",
      peg$c333 = peg$literalExpectation("UNBOUNDED", true),
      peg$c334 = function(s) {
          // => literal_string
          return { type: 'single_quote_string', value: s.toUpperCase() }
        },
      peg$c335 = function(bc) { /* => column_clause */ return bc; },
      peg$c336 = function(l) { /* => order_by_list */ return l; },
      peg$c337 = function(head, tail) {
          // => order_by_element[]
            return createList(head, tail);
          },
      peg$c338 = function(e, d) {
          // => { expr: expr; type: 'ASC' | 'DESC'; }
          const obj = { expr: e, type: 'ASC' };
          if (d === 'DESC') obj.type = 'DESC';
          return obj;
        },
      peg$c339 = function(i1, tail) {
          // => { separator: 'offset' | ''; value: [number_or_param | { type: 'origin', value: 'all' }, number_or_param?] }
            const res = []
            if (typeof i1 === 'string') res.push({ type: 'origin', value: 'all' })
            else res.push(i1)
            if (tail) res.push(tail[2]);
            return {
              seperator: tail && tail[0] && tail[0].toLowerCase() || '',
              value: res
            };
          },
      peg$c340 = function(t, l, w, r) {
            /* export interface update_stmt_node {
               type: 'update';
               table: table_ref_list;
               set: set_list;
               where?: where_clause;
               returning?: returning_stmt;
            }
           => AstStatement<update_stmt_node>
           */
            if (t) t.forEach(tableInfo => {
              const { db, as, table } = tableInfo
              tableList.add(`update::${db}::${table}`)
            });
            if(l) {
              l.forEach(col => columnList.add(`update::${col.table}::${col.column}`));
            }
            return {
              tableList: Array.from(tableList),
              columnList: columnListTableAlias(columnList),
              ast: {
                type: 'update',
                table: t,
                set: l,
                where: w,
                returning: r,
              }
            };
          },
      peg$c341 = function(t, f, w) {
            /*
            export interface table_ref_addition extends table_name {
              addition: true;
              as?: alias_clause;
            }
             export interface delete_stmt_node {
               type: 'delete';
               table?: table_ref_list | [table_ref_addition];
               where?: where_clause;
            }
           => AstStatement<delete_stmt_node>
           */
            if(f) f.forEach(info => {
              info.table && tableList.add(`delete::${info.db}::${info.table}`);
              columnList.add(`delete::${info.table}::(.*)`);
            });
            if (t === null && f.length === 1) {
              const tableInfo = f[0]
              t = [{
                db: tableInfo.db,
                table: tableInfo.table,
                as: tableInfo.as,
                addition: true
              }]
            }
            return {
              tableList: Array.from(tableList),
              columnList: columnListTableAlias(columnList),
              ast: {
                type: 'delete',
                table: t,
                from: f,
                where: w
              }
            };
          },
      peg$c342 = function(head, tail) {
            // => set_item[]
            return createList(head, tail);
          },
      peg$c343 = "=",
      peg$c344 = peg$literalExpectation("=", false),
      peg$c345 = function(tbl, c, v) {
            // => { column: ident; value: additive_expr; table?: ident;}
            return { column: c, value: v, table: tbl && tbl[0] };
          },
      peg$c346 = function(tbl, c, v) {
            // => { column: ident; value: column_ref; table?: ident; keyword: 'values' }
            return { column: c, value: v, table: tbl && tbl[0], keyword: 'values' };
        },
      peg$c347 = function(k, c) {
          // => { type: 'returning'; columns: column_ref_list | column_ref; }
          return {
            type: k && k.toLowerCase() || 'returning',
            columns: c === '*' && [{ type: 'columne_ref', table: null, column: '*' }] || c
          }
        },
      peg$c348 = function(head, tail) {
          // => ident_name[]
            return createList(head, tail)
          },
      peg$c349 = function(v) {
          // => value_item
          return v
        },
      peg$c350 = function(ri, t, p, c, v, r) {
            /*
             export interface replace_insert_stmt_node {
               type: 'insert' | 'replace';
               table?: [table_name];
               columns: column_list;
               values: insert_value_clause;
               partition?: insert_partition;
               returning?: returning_stmt;
            }
           => AstStatement<replace_insert_stmt_node>
           */
            if (t) {
              tableList.add(`insert::${t.db}::${t.table}`)
              t.as = null
            }
            if (c) {
              let table = t && t.table || null
              c.forEach(c => columnList.add(`insert::${table}::${c}`));
            }
            return {
              tableList: Array.from(tableList),
              columnList: columnListTableAlias(columnList),
              ast: {
                type: ri,
                table: [t],
                columns: c,
                values: v,
                partition: p,
                returning: r,
              }
            };
          },
      peg$c351 = function(ri, t, p, v, r) {
           // => AstStatement<replace_insert_stmt_node>
            if (t) {
              tableList.add(`insert::${t.db}::${t.table}`)
              columnList.add(`insert::${t.table}::(.*)`);
              t.as = null
            }
            return {
              tableList: Array.from(tableList),
              columnList: columnListTableAlias(columnList),
              ast: {
                type: ri,
                table: [t],
                columns: null,
                values: v,
                partition: p,
                returning: r,
              }
            };
          },
      peg$c352 = function() { /* => 'insert' */ return 'insert'; },
      peg$c353 = function() { /* => 'replace' */return 'replace'; },
      peg$c354 = function(l) { /* => value_list */ return l; },
      peg$c355 = function(head, tail) {
          // => value_item[]
            return createList(head, tail);
          },
      peg$c356 = function(l) {
          // => expr_list
            return l;
          },
      peg$c357 = function(e, u) {
            // => { type: 'interval', expr: expr; unit: interval_unit; }
            return {
              type: 'interval',
              expr: e,
              unit: u.toLowerCase(),
            }
          },
      peg$c358 = function(e) {
            // => { type: 'interval', expr: expr; unit: interval_unit; }
            return {
              type: 'interval',
              expr: e,
              unit: '',
            }
          },
      peg$c359 = function(expr, condition_list, otherwise) {
            /* => {
                type: 'case';
                expr?: expr;
                // nb: Only the last element is a case_else
                args: (case_when_then | case_else)[];
              } */
            if (otherwise) condition_list.push(otherwise);
            return {
              type: 'case',
              expr: expr || null,
              args: condition_list
            };
          },
      peg$c360 = function(condition, result) {
          // => { type: 'when'; cond: expr; result: expr; }
          return {
            type: 'when',
            cond: condition,
            result: result
          };
        },
      peg$c361 = function(result) {
          // => { type: 'else'; condition?: never; result: expr; }
          return { type: 'else', result: result };
        },
      peg$c362 = function(head, tail) {
          /*
          export type BINARY_OPERATORS = LOGIC_OPERATOR | 'OR' | 'AND' | multiplicative_operator | additive_operator
            | arithmetic_comparison_operator
            | 'IN' | 'NOT IN'
            | 'BETWEEN' | 'NOT BETWEEN'
            | 'IS' | 'IS NOT'
            | 'LIKE'
            | '@>' | '<@' | OPERATOR_CONCATENATION | DOUBLE_WELL_ARROW | WELL_ARROW | '?' | '?|' | '?&' | '#-'
          export interface binary_expr {
            type: 'binary_expr',
            operator: BINARY_OPERATORS,
            left: expr,
            right: expr
          }
          => binary_expr
          */
          // console.log("LOGIC OPEATOR : ")
          // console.log("HEAD : ")
          // console.log(head)
          // console.log("TAIL : ")
          // console.log(tail)
          return createBinaryExprChain(head, tail);
        },
      peg$c363 = function(op, tail) {
          /*
          export type UNARY_OPERATORS = '+' | '-' | 'EXISTS' | 'NOT EXISTS'  | 'NULL'
          => {
            type: 'unary_expr',
            operator: UNARY_OPERATORS,
            expr: expr;
            parentheses?: boolean;
          } */
          return createUnaryExpr(op, tail[0][1]);
        },
      peg$c364 = function(head, tail) {
          // => binary_expr
          return createBinaryExprChain(head, tail);
      },
      peg$c365 = function(lf, head, rt) { if ((lf && !rt) || (!lf && rt)) return true },
      peg$c366 = function(lf, head, rt) {
          // => binary_expr
        if (lf && rt) head.parentheses = true
        return head
      },
      peg$c367 = function(head, tail) {
            // => binary_expr
            return createBinaryExprChain(head, tail);
          },
      peg$c368 = "!",
      peg$c369 = peg$literalExpectation("!", false),
      peg$c370 = function(expr) {
          // => unary_expr
            return createUnaryExpr('NOT', expr);
          },
      peg$c371 = function(left, rh) {
          // => binary_expr
            if (rh === null) return left;
            else if (rh.type === 'arithmetic') return createBinaryExprChain(left, rh.tail);
            else return createBinaryExpr(rh.op, left, rh.right);
          },
      peg$c372 = function(op, stmt) {
          // => unary_expr
          stmt.parentheses = true;
          return createUnaryExpr(op, stmt);
        },
      peg$c373 = function(nk) { /* => 'NOT EXISTS' */ return nk[0] + ' ' + nk[2]; },
      peg$c374 = function(l) {
          // => { type: 'arithmetic'; tail: any }
            return { type: 'arithmetic', tail: l };
          },
      peg$c375 = ">=",
      peg$c376 = peg$literalExpectation(">=", false),
      peg$c377 = ">",
      peg$c378 = peg$literalExpectation(">", false),
      peg$c379 = "<=",
      peg$c380 = peg$literalExpectation("<=", false),
      peg$c381 = "<>",
      peg$c382 = peg$literalExpectation("<>", false),
      peg$c383 = "<",
      peg$c384 = peg$literalExpectation("<", false),
      peg$c385 = "!=",
      peg$c386 = peg$literalExpectation("!=", false),
      peg$c387 = function(right) {
          // => { op: 'IS'; right: additive_expr; }
            return { op: 'IS', right: right };
          },
      peg$c388 = function(right) {
          // => { type: 'origin'; value: string; }
          const { db, table } = right.pop()
          const tableName = table === '*' ? '*' : `"${table}"`
          let tableStr = db ? `"${db}".${tableName}` : tableName
          return { op: 'IS', right: {
            type: 'origin',
            value: `DISTINCT FROM ${tableStr}`
          }}
        },
      peg$c389 = function(right) {
            // => { type: 'IS NOT'; right: additive_expr; }
            return { op: 'IS NOT', right: right };
        },
      peg$c390 = function(op, begin, end) {
          // => { op: 'BETWEEN' | 'NOT BETWEEN'; right: { type: 'expr_list'; value: [expr, expr] }  }
            return {
              op: op,
              right: {
                type: 'expr_list',
                value: [begin, end]
              }
            };
          },
      peg$c391 = function(nk) { /* => 'NOT BETWEEN' */ return nk[0] + ' ' + nk[2]; },
      peg$c392 = function(nk) { /* => 'LIKE' */ return nk[0] + ' ' + nk[2]; },
      peg$c393 = function(nk) { /* => 'NOT IN' */ return nk[0] + ' ' + nk[2]; },
      peg$c394 = function(op, right) {
           // => { op: like_op; right: literal | comparison_expr}
            return { op: op, right: right };
          },
      peg$c395 = function(op, l) {
          // => {op: in_op; right: expr_list | var_decl | literal_string; }
            return { op: op, right: l };
          },
      peg$c396 = function(op, e) {
          // => IGNORE
            return { op: op, right: e };
          },
      peg$c397 = "@>",
      peg$c398 = peg$literalExpectation("@>", false),
      peg$c399 = "<@",
      peg$c400 = peg$literalExpectation("<@", false),
      peg$c401 = "?",
      peg$c402 = peg$literalExpectation("?", false),
      peg$c403 = "?|",
      peg$c404 = peg$literalExpectation("?|", false),
      peg$c405 = "?&",
      peg$c406 = peg$literalExpectation("?&", false),
      peg$c407 = "#-",
      peg$c408 = peg$literalExpectation("#-", false),
      peg$c409 = function(s, c) {
          // => { op: string; right: expr }
          return {
            op: s,
            right: c && c.expr || c
          }
        },
      peg$c410 = "+",
      peg$c411 = peg$literalExpectation("+", false),
      peg$c412 = "-",
      peg$c413 = peg$literalExpectation("-", false),
      peg$c414 = function(head, tail) {
            // => binary_expr
            return createBinaryExprChain(head, tail)
          },
      peg$c415 = "*",
      peg$c416 = peg$literalExpectation("*", false),
      peg$c417 = "/",
      peg$c418 = peg$literalExpectation("/", false),
      peg$c419 = "%",
      peg$c420 = peg$literalExpectation("%", false),
      peg$c421 = function(e, tail) {
          // => expr | binary_expr
            e.parentheses = true;
            if (!tail || tail.length === 0) return e
            return createBinaryExprChain(e, tail);
          },
      peg$c422 = function(list) {
          // => expr_list
              list.parentheses = true;
              return list;
          },
      peg$c423 = "$",
      peg$c424 = peg$literalExpectation("$", false),
      peg$c425 = function(prepared_symbol, n) {
          // => { type: 'origin'; value: string; }
          return {
            type: 'origin',
            value: `$${n.value}`,
          }
        },
      peg$c426 = function(tbl) {
          // => IGNORE
            columnList.add(`select::${tbl}::(.*)`);
            return {
                type: 'column_ref',
                table: tbl,
                column: '*'
            }
          },
      peg$c427 = function(tbl, col, a, j) {
          // => IGNORE
            const tableName = tbl && tbl[0] || null
            columnList.add(`select::${tableName}::${col}`);
            return {
              type: 'column_ref',
              table: tableName,
              column: col,
              arrow: a,
              property: j
            };
        },
      peg$c428 = function(tbl, col) {
            columnList.add(`select::${tbl}::${col}`);
            return {
              type: 'column_ref_with_join_mark',
              table: tbl,
              column: col
            };
          },
      peg$c429 = function(col) {
          // => IGNORE
            columnList.add(`select::null::${col}`);
            return {
              type: 'column_ref_with_join_mark',
              table: null,
              column: col
            };
          },
      peg$c430 = function(tbl, col) {
            /* => {
              type: 'column_ref';
              table: ident;
              column: column | '*';
              arrow?: '->>' | '->';
              property?: literal_string | literal_numeric;
            } */
            columnList.add(`select::${tbl}::${col}`);
            return {
              type: 'column_ref',
              table: tbl,
              column: col
            };
          },
      peg$c431 = function(col) {
          // => IGNORE
            columnList.add(`select::null::${col}`);
            return {
              type: 'column_ref',
              table: null,
              column: col
            };
          },
      peg$c432 = function(name) { return reservedMap[name.toUpperCase()] === true; },
      peg$c433 = function(name) {
            // => indent_name
            return name;
          },
      peg$c434 = function(name) {
            if (reservedMap[name.toUpperCase()] === true) throw new Error("Error: "+ JSON.stringify(name)+" is a reserved word, can not as alias clause");
            return false
          },
      peg$c435 = function(name) {
            // => string
            return name;
          },
      peg$c436 = function(name) {
            // => IGNORE
            return name;
          },
      peg$c437 = "\"",
      peg$c438 = peg$literalExpectation("\"", false),
      peg$c439 = /^[^"]/,
      peg$c440 = peg$classExpectation(["\""], true, false),
      peg$c441 = function(chars) { /* => string */ return '"' + chars.join('') + '"'; },
      peg$c442 = /^[^']/,
      peg$c443 = peg$classExpectation(["'"], true, false),
      peg$c444 = function(chars) { /* => string */ return chars.join(''); },
      peg$c445 = "`",
      peg$c446 = peg$literalExpectation("`", false),
      peg$c447 = /^[^`]/,
      peg$c448 = peg$classExpectation(["`"], true, false),
      peg$c449 = function(name) { /* => string */ return name; },
      peg$c450 = function(start, parts) { /* => string */ return start + parts.join(''); },
      peg$c451 = function(start, parts, join_mark) { /* => string */ return start + parts.join(''); },
      peg$c452 = function(start, parts, join_mark) { /* => string */ return '"' + start + parts.join('') + '"'; },
      peg$c453 = function(start, parts) {
            // => string
            return start + parts.join('');
          },
      peg$c454 = /^[A-Za-z\u3131-\u314E\uAC00-\uD7A3\u9673_]/,
      peg$c455 = peg$classExpectation([["A", "Z"], ["a", "z"], ["\u3131", "\u314E"], ["\uAC00", "\uD7A3"], "\u9673", "_"], false, false),
      peg$c456 = /^[A-Za-z0-9\u3131-\u314E\uAC00-\uD7A3\u9673_\-]/,
      peg$c457 = peg$classExpectation([["A", "Z"], ["a", "z"], ["0", "9"], ["\u3131", "\u314E"], ["\uAC00", "\uD7A3"], "\u9673", "_", "-"], false, false),
      peg$c458 = /^[A-Za-z0-9\u3131-\u314E\uAC00-\uD7A3\u9673_]/,
      peg$c459 = peg$classExpectation([["A", "Z"], ["a", "z"], ["0", "9"], ["\u3131", "\u314E"], ["\uAC00", "\uD7A3"], "\u9673", "_"], false, false),
      peg$c460 = ":",
      peg$c461 = peg$literalExpectation(":", false),
      peg$c462 = function(l) {
          // => { type: 'param'; value: ident_name }
            return { type: 'param', value: l[1] };
          },
      peg$c463 = "over",
      peg$c464 = peg$literalExpectation("OVER", true),
      peg$c465 = function(aws) {
          // => { type: 'windows'; as_window_specification: as_window_specification }
          return {
            type: 'window',
            as_window_specification: aws,
          }
        },
      peg$c466 = function(bc, l) {
          // => { partitionby: partition_by_clause; orderby: order_by_clause }
          return {
            partitionby: bc,
            orderby: l
          }
        },
      peg$c467 = function(name, over) {
          // => { type: 'window_func'; name: string; over: over_partition }
          return {
            type: 'window_func',
            name: name,
            over: over
          }
        },
      peg$c468 = function(name, l, over) {
          // => { type: 'window_func'; name: string; args: expr_list; consider_nulls: string; over: over_partition }
          return {
            type: 'window_func',
            name: name,
            args: l,
            over: over,
            // consider_nulls: cn ||'RESPECT NULLS'
          };
        },
      peg$c469 = function(name, l, cn, over) {
          // => window_fun_laglead
          return {
            type: 'window_func',
            name: name,
            args: {
              type: 'expr_list', value: [l]
            },
            over: over,
            consider_nulls: cn
          };
        },
      peg$c470 = "first_value",
      peg$c471 = peg$literalExpectation("FIRST_VALUE", true),
      peg$c472 = "last_value",
      peg$c473 = peg$literalExpectation("LAST_VALUE", true),
      peg$c474 = "row_number",
      peg$c475 = peg$literalExpectation("ROW_NUMBER", true),
      peg$c476 = "dense_rank",
      peg$c477 = peg$literalExpectation("DENSE_RANK", true),
      peg$c478 = "rank",
      peg$c479 = peg$literalExpectation("RANK", true),
      peg$c480 = "lag",
      peg$c481 = peg$literalExpectation("LAG", true),
      peg$c482 = "lead",
      peg$c483 = peg$literalExpectation("LEAD", true),
      peg$c484 = "nth_value",
      peg$c485 = peg$literalExpectation("NTH_VALUE", true),
      peg$c486 = "ignore",
      peg$c487 = peg$literalExpectation("IGNORE", true),
      peg$c488 = function(v) {
          // => string
          return v.toUpperCase() + ' NULLS'
        },
      peg$c489 = function(name, e, bc) {
          // => { type: 'aggr_func'; name: 'SUM' | 'MAX' | 'MIN' | 'AVG'; args: { expr: additive_expr }; over: over_partition }
            return {
              type: 'aggr_func',
              name: name,
              args: {
                expr: e
              },
              over: bc
            };
          },
      peg$c490 = function(name, arg, bc) {
          // => { type: 'aggr_func'; name: 'COUNT'; args:count_arg; over: over_partition }
            return {
              type: 'aggr_func',
              name: name,
              args: arg,
              over: bc
            };
          },
      peg$c491 = function(d, c) { /* => { distinct: 'DISTINCT'; expr: column_ref; } */  return { distinct: d, expr: c }; },
      peg$c492 = function(d, c) { /* => { distinct: 'DISTINCT'; expr: column_ref; } */  c.parentheses = true; return { distinct: d, expr: c }; },
      peg$c493 = function(e) { /* => { expr: star_expr } */ return { expr: e }; },
      peg$c494 = function(name, arg, o) {
          // => { type: 'aggr_func'; args:count_arg; name: 'ARRAY_AGG'; orderby?: order_by_clause  }
            return {
              type: 'aggr_func',
              name: name,
              args: arg,
              orderby: o,
            };
          },
      peg$c495 = function() { /* => { type: 'star'; value: '*' } */ return { type: 'star', value: '*' }; },
      peg$c496 = function(name, l, bc) {
          // => { type: 'function'; name: string; args: expr_list; over?: over_partition; }
            return {
              type: 'function',
              name: name,
              args: l ? l: { type: 'expr_list', value: [] },
              over: bc
            };
          },
      peg$c497 = "century",
      peg$c498 = peg$literalExpectation("CENTURY", true),
      peg$c499 = "day",
      peg$c500 = peg$literalExpectation("DAY", true),
      peg$c501 = "decade",
      peg$c502 = peg$literalExpectation("DECADE", true),
      peg$c503 = "dow",
      peg$c504 = peg$literalExpectation("DOW", true),
      peg$c505 = "doy",
      peg$c506 = peg$literalExpectation("DOY", true),
      peg$c507 = "epoch",
      peg$c508 = peg$literalExpectation("EPOCH", true),
      peg$c509 = "hour",
      peg$c510 = peg$literalExpectation("HOUR", true),
      peg$c511 = "isodow",
      peg$c512 = peg$literalExpectation("ISODOW", true),
      peg$c513 = "isoyear",
      peg$c514 = peg$literalExpectation("ISOYEAR", true),
      peg$c515 = "microseconds",
      peg$c516 = peg$literalExpectation("MICROSECONDS", true),
      peg$c517 = "millennium",
      peg$c518 = peg$literalExpectation("MILLENNIUM", true),
      peg$c519 = "milliseconds",
      peg$c520 = peg$literalExpectation("MILLISECONDS", true),
      peg$c521 = "minute",
      peg$c522 = peg$literalExpectation("MINUTE", true),
      peg$c523 = "month",
      peg$c524 = peg$literalExpectation("MONTH", true),
      peg$c525 = "quarter",
      peg$c526 = peg$literalExpectation("QUARTER", true),
      peg$c527 = "second",
      peg$c528 = peg$literalExpectation("SECOND", true),
      peg$c529 = "timezone",
      peg$c530 = peg$literalExpectation("TIMEZONE", true),
      peg$c531 = "timezone_hour",
      peg$c532 = peg$literalExpectation("TIMEZONE_HOUR", true),
      peg$c533 = "timezone_minute",
      peg$c534 = peg$literalExpectation("TIMEZONE_MINUTE", true),
      peg$c535 = "week",
      peg$c536 = peg$literalExpectation("WEEK", true),
      peg$c537 = "year",
      peg$c538 = peg$literalExpectation("YEAR", true),
      peg$c539 = function() {
          // => 'string'
          return f
        },
      peg$c540 = function(kw, f, t, s) {
          // => { type: 'extract'; args: { field: extract_filed; cast_type: 'TIMESTAMP' | 'INTERVAL' | 'TIME'; source: expr; }}
          return {
              type: kw.toLowerCase(),
              args: {
                field: f,
                cast_type: t,
                source: s,
              }
          }
        },
      peg$c541 = function(e, s, t, alias) {
          /* => {
              as?: alias_clause,
              type: 'cast';
              expr: expr | literal | aggr_func | func_call | case_expr | interval_expr | column_ref | param
                | expr;
              symbol: '::' | 'as',
              target: data_type;
            }
            */
          return {
            as: alias,
            type: 'cast',
            expr: e,
            symbol: '::',
            target: t
          }
        },
      peg$c542 = function(e, t) {
          // => IGNORE
          return {
            type: 'cast',
            expr: e,
            symbol: 'as',
            target: t
          };
        },
      peg$c543 = function(e, precision) {
          // => IGNORE
          return {
            type: 'cast',
            expr: e,
            symbol: 'as',
            target: {
              dataType: 'DECIMAL(' + precision + ')'
            }
          };
        },
      peg$c544 = function(e, precision, scale) {
            // => IGNORE
            return {
              type: 'cast',
              expr: e,
              symbol: 'as',
              target: {
                dataType: 'DECIMAL(' + precision + ', ' + scale + ')'
              }
            };
          },
      peg$c545 = function(e, s, t) { /* MySQL cast to un-/signed integer */
          // => IGNORE
          return {
            type: 'cast',
            expr: e,
            symbol: 'as',
            target: {
              dataType: s + (t ? ' ' + t: '')
            }
          };
        },
      peg$c546 = function(s, c) {
          /*
            => {
              expr_list: expr_list | {type: 'origin', value: ident },
              type: string,
              keyword: string,
              brackets: boolean
            }
          */
          return {
            expr_list: c || { type: 'origin', value: '' },
            type: 'array',
            keyword: 'array',
            brackets: true
          }
        },
      peg$c547 = function(head, tail) {
          // => literal[]
            return createList(head, tail);
          },
      peg$c548 = function() {
          // => { type: 'null'; value: null }
            return { type: 'null', value: null };
          },
      peg$c549 = function() {
          // => { type: 'not null'; value: 'not null' }
          return {
            type: 'not null',
            value: 'not null',
          }
        },
      peg$c550 = function() {
            // => { type: 'bool', value: true }
            return { type: 'bool', value: true };
          },
      peg$c551 = function() {
            //=> { type: 'bool', value: false }
            return { type: 'bool', value: false };
          },
      peg$c552 = function(ca) {
            // => { type: 'single_quote_string'; value: string; }
            return {
              type: 'single_quote_string',
              value: ca[1].join('')
            };
          },
      peg$c553 = function(type, ca) {
            //=> { type: 'TIME' | 'DATE' | 'TIMESTAMP' | 'DATETIME', value: string }
            return {
              type: type.toLowerCase(),
              value: ca[1].join('')
            };
          },
      peg$c554 = function(type, lf, rt) { if (lf && rt) return true },
      peg$c555 = "on update current_timestamp",
      peg$c556 = peg$literalExpectation("ON UPDATE CURRENT_TIMESTAMP", true),
      peg$c557 = function(type, lf, rt, up) {
            // => { type: 'origin'; value: string; }
            return {
              type: 'origin',
              value: (up ? `${type} ${up}` : type).toLowerCase()
            };
          },
      peg$c558 = /^[^"\\\0-\x1F\x7F]/,
      peg$c559 = peg$classExpectation(["\"", "\\", ["\0", "\x1F"], "\x7F"], true, false),
      peg$c560 = /^[^'\^"\\]/,
      peg$c561 = peg$classExpectation(["'", "^", "\"", "\\"], true, false),
      peg$c562 = /^[^'\\]/,
      peg$c563 = peg$classExpectation(["'", "\\"], true, false),
      peg$c564 = "\\'",
      peg$c565 = peg$literalExpectation("\\'", false),
      peg$c566 = function() { return "'";  },
      peg$c567 = "\\\"",
      peg$c568 = peg$literalExpectation("\\\"", false),
      peg$c569 = function() { return '"';  },
      peg$c570 = "\\\\",
      peg$c571 = peg$literalExpectation("\\\\", false),
      peg$c572 = function() { return "\\"; },
      peg$c573 = "\\/",
      peg$c574 = peg$literalExpectation("\\/", false),
      peg$c575 = function() { return "/";  },
      peg$c576 = "\\b",
      peg$c577 = peg$literalExpectation("\\b", false),
      peg$c578 = function() { return "\b"; },
      peg$c579 = "\\f",
      peg$c580 = peg$literalExpectation("\\f", false),
      peg$c581 = function() { return "\f"; },
      peg$c582 = "\\n",
      peg$c583 = peg$literalExpectation("\\n", false),
      peg$c584 = function() { return "\n"; },
      peg$c585 = "\\r",
      peg$c586 = peg$literalExpectation("\\r", false),
      peg$c587 = function() { return "\r"; },
      peg$c588 = "\\t",
      peg$c589 = peg$literalExpectation("\\t", false),
      peg$c590 = function() { return "\t"; },
      peg$c591 = "\\u",
      peg$c592 = peg$literalExpectation("\\u", false),
      peg$c593 = function(h1, h2, h3, h4) {
            return String.fromCharCode(parseInt("0x" + h1 + h2 + h3 + h4));
          },
      peg$c594 = "\\",
      peg$c595 = peg$literalExpectation("\\", false),
      peg$c596 = /^[\n\r]/,
      peg$c597 = peg$classExpectation(["\n", "\r"], false, false),
      peg$c598 = function(n) {
          // => number | { type: 'bigint'; value: string; }
            if (n && n.type === 'bigint') return n
            return { type: 'number', value: n };
          },
      peg$c599 = function(int_, frac, exp) {
          const numStr = int_ + frac + exp
          return {
            type: 'bigint',
            value: numStr
          }
        },
      peg$c600 = function(int_, frac) {
          // => IGNORE
          const numStr = int_ + frac
          if (isBigInt(int_)) return {
            type: 'bigint',
            value: numStr
          }
          return parseFloat(numStr);
        },
      peg$c601 = function(int_, exp) {
          // => IGNORE
          const numStr = int_ + exp
          return {
            type: 'bigint',
            value: numStr
          }
        },
      peg$c602 = function(int_) {
          // => IGNORE
          if (isBigInt(int_)) return {
            type: 'bigint',
            value: int_
          }
          return parseFloat(int_);
        },
      peg$c603 = function(op, digits) { return "-" + digits; },
      peg$c604 = function(op, digit) { return "-" + digit; },
      peg$c605 = ".",
      peg$c606 = peg$literalExpectation(".", false),
      peg$c607 = function(digits) { return "." + digits; },
      peg$c608 = function(e, digits) { return e + digits; },
      peg$c609 = function(digits) { return digits.join(""); },
      peg$c610 = /^[0-9]/,
      peg$c611 = peg$classExpectation([["0", "9"]], false, false),
      peg$c612 = /^[0-9a-fA-F]/,
      peg$c613 = peg$classExpectation([["0", "9"], ["a", "f"], ["A", "F"]], false, false),
      peg$c614 = /^[eE]/,
      peg$c615 = peg$classExpectation(["e", "E"], false, false),
      peg$c616 = /^[+\-]/,
      peg$c617 = peg$classExpectation(["+", "-"], false, false),
      peg$c618 = function(e, sign) { return e + (sign !== null ? sign: ''); },
      peg$c619 = "null",
      peg$c620 = peg$literalExpectation("NULL", true),
      peg$c621 = "not null",
      peg$c622 = peg$literalExpectation("NOT NULL", true),
      peg$c623 = "true",
      peg$c624 = peg$literalExpectation("TRUE", true),
      peg$c625 = "to",
      peg$c626 = peg$literalExpectation("TO", true),
      peg$c627 = "false",
      peg$c628 = peg$literalExpectation("FALSE", true),
      peg$c629 = "show",
      peg$c630 = peg$literalExpectation("SHOW", true),
      peg$c631 = "drop",
      peg$c632 = peg$literalExpectation("DROP", true),
      peg$c633 = function() { return 'DROP'; },
      peg$c634 = "use",
      peg$c635 = peg$literalExpectation("USE", true),
      peg$c636 = "alter",
      peg$c637 = peg$literalExpectation("ALTER", true),
      peg$c638 = "select",
      peg$c639 = peg$literalExpectation("SELECT", true),
      peg$c640 = "update",
      peg$c641 = peg$literalExpectation("UPDATE", true),
      peg$c642 = "create",
      peg$c643 = peg$literalExpectation("CREATE", true),
      peg$c644 = "temporary",
      peg$c645 = peg$literalExpectation("TEMPORARY", true),
      peg$c646 = function() { return 'TEMPORARY'; },
      peg$c647 = "temp",
      peg$c648 = peg$literalExpectation("TEMP", true),
      peg$c649 = function() { return 'TEMP'; },
      peg$c650 = "if not exists",
      peg$c651 = peg$literalExpectation("IF NOT EXISTS", true),
      peg$c652 = "delete",
      peg$c653 = peg$literalExpectation("DELETE", true),
      peg$c654 = "insert",
      peg$c655 = peg$literalExpectation("INSERT", true),
      peg$c656 = "RECURSIVE",
      peg$c657 = peg$literalExpectation("RECURSIVE", false),
      peg$c658 = "replace",
      peg$c659 = peg$literalExpectation("REPLACE", true),
      peg$c660 = "returning",
      peg$c661 = peg$literalExpectation("RETURNING", true),
      peg$c662 = function() { return 'RETURNING' },
      peg$c663 = "rename",
      peg$c664 = peg$literalExpectation("RENAME", true),
      peg$c665 = "explain",
      peg$c666 = peg$literalExpectation("EXPLAIN", true),
      peg$c667 = "partition",
      peg$c668 = peg$literalExpectation("PARTITION", true),
      peg$c669 = function() { return 'PARTITION' },
      peg$c670 = "into",
      peg$c671 = peg$literalExpectation("INTO", true),
      peg$c672 = "from",
      peg$c673 = peg$literalExpectation("FROM", true),
      peg$c674 = "as",
      peg$c675 = peg$literalExpectation("AS", true),
      peg$c676 = "table",
      peg$c677 = peg$literalExpectation("TABLE", true),
      peg$c678 = function() { return 'TABLE'; },
      peg$c679 = "database",
      peg$c680 = peg$literalExpectation("DATABASE", true),
      peg$c681 = function() { return 'DATABASE'; },
      peg$c682 = "scheme",
      peg$c683 = peg$literalExpectation("SCHEME", true),
      peg$c684 = function() { return 'SCHEME'; },
      peg$c685 = "sequence",
      peg$c686 = peg$literalExpectation("SEQUENCE", true),
      peg$c687 = function() { return 'SEQUENCE'; },
      peg$c688 = "tablespace",
      peg$c689 = peg$literalExpectation("TABLESPACE", true),
      peg$c690 = function() { return 'TABLESPACE'; },
      peg$c691 = function() { return 'COLLATE'; },
      peg$c692 = "left",
      peg$c693 = peg$literalExpectation("LEFT", true),
      peg$c694 = "right",
      peg$c695 = peg$literalExpectation("RIGHT", true),
      peg$c696 = "full",
      peg$c697 = peg$literalExpectation("FULL", true),
      peg$c698 = "cross",
      peg$c699 = peg$literalExpectation("CROSS", true),
      peg$c700 = "natural",
      peg$c701 = peg$literalExpectation("NATURAL", true),
      peg$c702 = "inner",
      peg$c703 = peg$literalExpectation("INNER", true),
      peg$c704 = "join",
      peg$c705 = peg$literalExpectation("JOIN", true),
      peg$c706 = "outer",
      peg$c707 = peg$literalExpectation("OUTER", true),
      peg$c708 = "union",
      peg$c709 = peg$literalExpectation("UNION", true),
      peg$c710 = "minus",
      peg$c711 = peg$literalExpectation("MINUS", true),
      peg$c712 = "intersect",
      peg$c713 = peg$literalExpectation("INTERSECT", true),
      peg$c714 = "values",
      peg$c715 = peg$literalExpectation("VALUES", true),
      peg$c716 = "using",
      peg$c717 = peg$literalExpectation("USING", true),
      peg$c718 = "where",
      peg$c719 = peg$literalExpectation("WHERE", true),
      peg$c720 = "group",
      peg$c721 = peg$literalExpectation("GROUP", true),
      peg$c722 = "by",
      peg$c723 = peg$literalExpectation("BY", true),
      peg$c724 = "order",
      peg$c725 = peg$literalExpectation("ORDER", true),
      peg$c726 = "having",
      peg$c727 = peg$literalExpectation("HAVING", true),
      peg$c728 = "limit",
      peg$c729 = peg$literalExpectation("LIMIT", true),
      peg$c730 = "offset",
      peg$c731 = peg$literalExpectation("OFFSET", true),
      peg$c732 = function() { return 'OFFSET' },
      peg$c733 = "asc",
      peg$c734 = peg$literalExpectation("ASC", true),
      peg$c735 = function() { return 'ASC'; },
      peg$c736 = "desc",
      peg$c737 = peg$literalExpectation("DESC", true),
      peg$c738 = function() { return 'DESC'; },
      peg$c739 = "all",
      peg$c740 = peg$literalExpectation("ALL", true),
      peg$c741 = function() { return 'ALL'; },
      peg$c742 = "distinct",
      peg$c743 = peg$literalExpectation("DISTINCT", true),
      peg$c744 = function() { return 'DISTINCT';},
      peg$c745 = "between",
      peg$c746 = peg$literalExpectation("BETWEEN", true),
      peg$c747 = function() { return 'BETWEEN'; },
      peg$c748 = function() { return 'IN'; },
      peg$c749 = "is",
      peg$c750 = peg$literalExpectation("IS", true),
      peg$c751 = function() { return 'IS'; },
      peg$c752 = "like",
      peg$c753 = peg$literalExpectation("LIKE", true),
      peg$c754 = function() { return 'LIKE'; },
      peg$c755 = "ilike",
      peg$c756 = peg$literalExpectation("ILIKE", true),
      peg$c757 = function() { return 'ILIKE'; },
      peg$c758 = "exists",
      peg$c759 = peg$literalExpectation("EXISTS", true),
      peg$c760 = function() { /* => 'EXISTS' */ return 'EXISTS'; },
      peg$c761 = function() { return 'NOT'; },
      peg$c762 = "and",
      peg$c763 = peg$literalExpectation("AND", true),
      peg$c764 = function() { return 'AND'; },
      peg$c765 = "or",
      peg$c766 = peg$literalExpectation("OR", true),
      peg$c767 = function() { return 'OR'; },
      peg$c768 = "array",
      peg$c769 = peg$literalExpectation("ARRAY", true),
      peg$c770 = function() { return 'ARRAY'; },
      peg$c771 = "array_agg",
      peg$c772 = peg$literalExpectation("ARRAY_AGG", true),
      peg$c773 = function() { return 'ARRAY_AGG'; },
      peg$c774 = "count",
      peg$c775 = peg$literalExpectation("COUNT", true),
      peg$c776 = function() { return 'COUNT'; },
      peg$c777 = "max",
      peg$c778 = peg$literalExpectation("MAX", true),
      peg$c779 = function() { return 'MAX'; },
      peg$c780 = "min",
      peg$c781 = peg$literalExpectation("MIN", true),
      peg$c782 = function() { return 'MIN'; },
      peg$c783 = "sum",
      peg$c784 = peg$literalExpectation("SUM", true),
      peg$c785 = function() { return 'SUM'; },
      peg$c786 = "avg",
      peg$c787 = peg$literalExpectation("AVG", true),
      peg$c788 = function() { return 'AVG'; },
      peg$c789 = "extract",
      peg$c790 = peg$literalExpectation("EXTRACT", true),
      peg$c791 = function() { return 'EXTRACT'; },
      peg$c792 = "call",
      peg$c793 = peg$literalExpectation("CALL", true),
      peg$c794 = function() { return 'CALL'; },
      peg$c795 = "case",
      peg$c796 = peg$literalExpectation("CASE", true),
      peg$c797 = "when",
      peg$c798 = peg$literalExpectation("WHEN", true),
      peg$c799 = "then",
      peg$c800 = peg$literalExpectation("THEN", true),
      peg$c801 = "else",
      peg$c802 = peg$literalExpectation("ELSE", true),
      peg$c803 = "end",
      peg$c804 = peg$literalExpectation("END", true),
      peg$c805 = "cast",
      peg$c806 = peg$literalExpectation("CAST", true),
      peg$c807 = "bool",
      peg$c808 = peg$literalExpectation("BOOL", true),
      peg$c809 = function() { return 'BOOL'; },
      peg$c810 = "boolean",
      peg$c811 = peg$literalExpectation("BOOLEAN", true),
      peg$c812 = function() { return 'BOOLEAN'; },
      peg$c813 = "char",
      peg$c814 = peg$literalExpectation("CHAR", true),
      peg$c815 = function() { return 'CHAR'; },
      peg$c816 = "varchar",
      peg$c817 = peg$literalExpectation("VARCHAR", true),
      peg$c818 = function() { return 'VARCHAR';},
      peg$c819 = "numeric",
      peg$c820 = peg$literalExpectation("NUMERIC", true),
      peg$c821 = function() { return 'NUMERIC'; },
      peg$c822 = "decimal",
      peg$c823 = peg$literalExpectation("DECIMAL", true),
      peg$c824 = function() { return 'DECIMAL'; },
      peg$c825 = "signed",
      peg$c826 = peg$literalExpectation("SIGNED", true),
      peg$c827 = function() { return 'SIGNED'; },
      peg$c828 = "unsigned",
      peg$c829 = peg$literalExpectation("UNSIGNED", true),
      peg$c830 = function() { return 'UNSIGNED'; },
      peg$c831 = "int",
      peg$c832 = peg$literalExpectation("INT", true),
      peg$c833 = function() { return 'INT'; },
      peg$c834 = "zerofill",
      peg$c835 = peg$literalExpectation("ZEROFILL", true),
      peg$c836 = function() { return 'ZEROFILL'; },
      peg$c837 = "integer",
      peg$c838 = peg$literalExpectation("INTEGER", true),
      peg$c839 = function() { return 'INTEGER'; },
      peg$c840 = "json",
      peg$c841 = peg$literalExpectation("JSON", true),
      peg$c842 = function() { return 'JSON'; },
      peg$c843 = "jsonb",
      peg$c844 = peg$literalExpectation("JSONB", true),
      peg$c845 = function() { return 'JSONB'; },
      peg$c846 = "geometry",
      peg$c847 = peg$literalExpectation("GEOMETRY", true),
      peg$c848 = function() { return 'GEOMETRY'; },
      peg$c849 = "smallint",
      peg$c850 = peg$literalExpectation("SMALLINT", true),
      peg$c851 = function() { return 'SMALLINT'; },
      peg$c852 = "tinyint",
      peg$c853 = peg$literalExpectation("TINYINT", true),
      peg$c854 = function() { return 'TINYINT'; },
      peg$c855 = "tinytext",
      peg$c856 = peg$literalExpectation("TINYTEXT", true),
      peg$c857 = function() { return 'TINYTEXT'; },
      peg$c858 = "text",
      peg$c859 = peg$literalExpectation("TEXT", true),
      peg$c860 = function() { return 'TEXT'; },
      peg$c861 = "mediumtext",
      peg$c862 = peg$literalExpectation("MEDIUMTEXT", true),
      peg$c863 = function() { return 'MEDIUMTEXT'; },
      peg$c864 = "longtext",
      peg$c865 = peg$literalExpectation("LONGTEXT", true),
      peg$c866 = function() { return 'LONGTEXT'; },
      peg$c867 = "bigint",
      peg$c868 = peg$literalExpectation("BIGINT", true),
      peg$c869 = function() { return 'BIGINT'; },
      peg$c870 = "float",
      peg$c871 = peg$literalExpectation("FLOAT", true),
      peg$c872 = function() { return 'FLOAT'; },
      peg$c873 = "double",
      peg$c874 = peg$literalExpectation("DOUBLE", true),
      peg$c875 = function() { return 'DOUBLE'; },
      peg$c876 = "date",
      peg$c877 = peg$literalExpectation("DATE", true),
      peg$c878 = function() { return 'DATE'; },
      peg$c879 = "datetime",
      peg$c880 = peg$literalExpectation("DATETIME", true),
      peg$c881 = function() { return 'DATETIME'; },
      peg$c882 = "rows",
      peg$c883 = peg$literalExpectation("ROWS", true),
      peg$c884 = function() { return 'ROWS'; },
      peg$c885 = "range",
      peg$c886 = peg$literalExpectation("RANGE", true),
      peg$c887 = function() { return 'RANGE'; },
      peg$c888 = "time",
      peg$c889 = peg$literalExpectation("TIME", true),
      peg$c890 = function() { return 'TIME'; },
      peg$c891 = "timestamp",
      peg$c892 = peg$literalExpectation("TIMESTAMP", true),
      peg$c893 = function() { return 'TIMESTAMP'; },
      peg$c894 = "truncate",
      peg$c895 = peg$literalExpectation("TRUNCATE", true),
      peg$c896 = function() { return 'TRUNCATE'; },
      peg$c897 = "user",
      peg$c898 = peg$literalExpectation("USER", true),
      peg$c899 = function() { return 'USER'; },
      peg$c900 = "uuid",
      peg$c901 = peg$literalExpectation("UUID", true),
      peg$c902 = function() { return 'UUID'; },
      peg$c903 = "current_date",
      peg$c904 = peg$literalExpectation("CURRENT_DATE", true),
      peg$c905 = function() { return 'CURRENT_DATE'; },
      peg$c906 = "adddate",
      peg$c907 = peg$literalExpectation("ADDDATE", true),
      peg$c908 = function() { return 'ADDDATE'; },
      peg$c909 = "interval",
      peg$c910 = peg$literalExpectation("INTERVAL", true),
      peg$c911 = function() { return 'INTERVAL'; },
      peg$c912 = function() { return 'YEAR'; },
      peg$c913 = function() { return 'MONTH'; },
      peg$c914 = function() { return 'DAY'; },
      peg$c915 = function() { return 'HOUR'; },
      peg$c916 = function() { return 'MINUTE'; },
      peg$c917 = function() { return 'SECOND'; },
      peg$c918 = "current_time",
      peg$c919 = peg$literalExpectation("CURRENT_TIME", true),
      peg$c920 = function() { return 'CURRENT_TIME'; },
      peg$c921 = "current_timestamp",
      peg$c922 = peg$literalExpectation("CURRENT_TIMESTAMP", true),
      peg$c923 = function() { return 'CURRENT_TIMESTAMP'; },
      peg$c924 = "current_user",
      peg$c925 = peg$literalExpectation("CURRENT_USER", true),
      peg$c926 = function() { return 'CURRENT_USER'; },
      peg$c927 = "session_user",
      peg$c928 = peg$literalExpectation("SESSION_USER", true),
      peg$c929 = function() { return 'SESSION_USER'; },
      peg$c930 = "system_user",
      peg$c931 = peg$literalExpectation("SYSTEM_USER", true),
      peg$c932 = function() { return 'SYSTEM_USER'; },
      peg$c933 = "global",
      peg$c934 = peg$literalExpectation("GLOBAL", true),
      peg$c935 = function() { return 'GLOBAL'; },
      peg$c936 = "session",
      peg$c937 = peg$literalExpectation("SESSION", true),
      peg$c938 = function() { return 'SESSION'; },
      peg$c939 = "local",
      peg$c940 = peg$literalExpectation("LOCAL", true),
      peg$c941 = function() { return 'LOCAL'; },
      peg$c942 = "persist",
      peg$c943 = peg$literalExpectation("PERSIST", true),
      peg$c944 = function() { return 'PERSIST'; },
      peg$c945 = "persist_only",
      peg$c946 = peg$literalExpectation("PERSIST_ONLY", true),
      peg$c947 = function() { return 'PERSIST_ONLY'; },
      peg$c948 = "cube",
      peg$c949 = peg$literalExpectation("CUBE", true),
      peg$c950 = function() { return 'CUBE'; },
      peg$c951 = "rollup",
      peg$c952 = peg$literalExpectation("ROLLUP", true),
      peg$c953 = function() { return 'ROLLUP'; },
      peg$c954 = "grouping",
      peg$c955 = peg$literalExpectation("GROUPING", true),
      peg$c956 = function() { return 'GROUPING'; },
      peg$c957 = "sets",
      peg$c958 = peg$literalExpectation("SETS", true),
      peg$c959 = function() { return 'SETS'; },
      peg$c960 = "@",
      peg$c961 = peg$literalExpectation("@", false),
      peg$c962 = "@@",
      peg$c963 = peg$literalExpectation("@@", false),
      peg$c964 = "return",
      peg$c965 = peg$literalExpectation("return", true),
      peg$c966 = ":=",
      peg$c967 = peg$literalExpectation(":=", false),
      peg$c968 = "::",
      peg$c969 = peg$literalExpectation("::", false),
      peg$c970 = "dual",
      peg$c971 = peg$literalExpectation("DUAL", true),
      peg$c972 = "add",
      peg$c973 = peg$literalExpectation("ADD", true),
      peg$c974 = function() { return 'ADD'; },
      peg$c975 = "column",
      peg$c976 = peg$literalExpectation("COLUMN", true),
      peg$c977 = function() { return 'COLUMN'; },
      peg$c978 = "index",
      peg$c979 = peg$literalExpectation("INDEX", true),
      peg$c980 = function() { return 'INDEX'; },
      peg$c981 = function() { return 'KEY'; },
      peg$c982 = "fulltext",
      peg$c983 = peg$literalExpectation("FULLTEXT", true),
      peg$c984 = function() { return 'FULLTEXT'; },
      peg$c985 = "spatial",
      peg$c986 = peg$literalExpectation("SPATIAL", true),
      peg$c987 = function() { return 'SPATIAL'; },
      peg$c988 = function() { return 'UNIQUE'; },
      peg$c989 = function() { return 'KEY_BLOCK_SIZE'; },
      peg$c990 = "comment",
      peg$c991 = peg$literalExpectation("COMMENT", true),
      peg$c992 = function() { return 'COMMENT'; },
      peg$c993 = "constraint",
      peg$c994 = peg$literalExpectation("CONSTRAINT", true),
      peg$c995 = function() { return 'CONSTRAINT'; },
      peg$c996 = "concurrently",
      peg$c997 = peg$literalExpectation("CONCURRENTLY", true),
      peg$c998 = function() { return 'CONCURRENTLY'; },
      peg$c999 = "references",
      peg$c1000 = peg$literalExpectation("REFERENCES", true),
      peg$c1001 = function() { return 'REFERENCES'; },
      peg$c1002 = "sql_calc_found_rows",
      peg$c1003 = peg$literalExpectation("SQL_CALC_FOUND_ROWS", true),
      peg$c1004 = "sql_cache",
      peg$c1005 = peg$literalExpectation("SQL_CACHE", true),
      peg$c1006 = "sql_no_cache",
      peg$c1007 = peg$literalExpectation("SQL_NO_CACHE", true),
      peg$c1008 = "sql_small_result",
      peg$c1009 = peg$literalExpectation("SQL_SMALL_RESULT", true),
      peg$c1010 = "sql_big_result",
      peg$c1011 = peg$literalExpectation("SQL_BIG_RESULT", true),
      peg$c1012 = "sql_buffer_result",
      peg$c1013 = peg$literalExpectation("SQL_BUFFER_RESULT", true),
      peg$c1014 = ",",
      peg$c1015 = peg$literalExpectation(",", false),
      peg$c1016 = "[",
      peg$c1017 = peg$literalExpectation("[", false),
      peg$c1018 = "]",
      peg$c1019 = peg$literalExpectation("]", false),
      peg$c1020 = ";",
      peg$c1021 = peg$literalExpectation(";", false),
      peg$c1022 = "->",
      peg$c1023 = peg$literalExpectation("->", false),
      peg$c1024 = "->>",
      peg$c1025 = peg$literalExpectation("->>", false),
      peg$c1026 = "#>",
      peg$c1027 = peg$literalExpectation("#>", false),
      peg$c1028 = "#>>",
      peg$c1029 = peg$literalExpectation("#>>", false),
      peg$c1030 = "||",
      peg$c1031 = peg$literalExpectation("||", false),
      peg$c1032 = "&&",
      peg$c1033 = peg$literalExpectation("&&", false),
      peg$c1034 = "/*",
      peg$c1035 = peg$literalExpectation("/*", false),
      peg$c1036 = "*/",
      peg$c1037 = peg$literalExpectation("*/", false),
      peg$c1038 = "--",
      peg$c1039 = peg$literalExpectation("--", false),
      peg$c1040 = "#",
      peg$c1041 = peg$literalExpectation("#", false),
      peg$c1042 = function(k, s, c) {
          // => { type: 'comment'; keyword: 'comment'; symbol: '='; value: literal_string; }
          return {
            type: k.toLowerCase(),
            keyword: k.toLowerCase(),
            symbol: s,
            value: c,
          }
        },
      peg$c1043 = peg$anyExpectation(),
      peg$c1044 = /^[ \t\n\r]/,
      peg$c1045 = peg$classExpectation([" ", "\t", "\n", "\r"], false, false),
      peg$c1046 = function() { varList = []; return true; },
      peg$c1047 = function(s) {
            // => { type: 'proc'; stmt: assign_stmt | return_stmt; vars: any }
            return { type: 'proc', stmt: s, vars: varList };
          },
      peg$c1048 = function(va, s, e) {
          // => { type: 'assign'; left: var_decl | without_prefix_var_decl; symbol: ':=' | '='; right: proc_expr; }
          return {
            type: 'assign',
            left: va,
            symbol: s,
            right: e
          };
        },
      peg$c1049 = function(e) {
          // => { type: 'return'; expr: proc_expr; }
            return { type: 'return', expr: e };
          },
      peg$c1050 = function(lt, op, rt, expr) {
          // => { type: 'join'; ltable: var_decl; rtable: var_decl; op: join_op; expr: on_clause; }
            return {
              type: 'join',
              ltable: lt,
              rtable: rt,
              op: op,
              on: expr
            };
          },
      peg$c1051 = function(e) {
          // => proc_additive_expr & { parentheses: true; }
            e.parentheses = true;
            return e;
          },
      peg$c1052 = function(dt, tail) {
          // => string
            let name = dt
            if (tail !== null) {
              name = `${dt}.${tail[3]}`
            }
            return name;
          },
      peg$c1053 = function(name, l) {
          // => { type: 'function'; name: string; args: null | { type: expr_list; value: proc_primary_list; }}
            //compatible with original func_call
            return {
              type: 'function',
              name: name,
              args: {
                type: 'expr_list',
                value: l
              }
            };
          },
      peg$c1054 = function(name) {
          // => IGNORE
          return {
              type: 'function',
              name: name,
              args: null
            };
        },
      peg$c1055 = function(head, tail) {
          // => proc_primary[]
            return createList(head, tail);
          },
      peg$c1056 = function(l) {
          // => { type: 'array'; value: proc_primary_list }
          return { type: 'array', value: l };
        },
      peg$c1057 = function(p, d) {
          // => without_prefix_var_decl & { type: 'var'; prefix: string; };
          //push for analysis
          return {
            type: 'var',
            ...d,
            prefix: p
          };
        },
      peg$c1058 = function(name, m) {
          // => { type: 'var'; prefix: string; name: ident_name; members: mem_chain; }
          //push for analysis
          varList.push(name);
          return {
            type: 'var',
            name: name,
            members: m,
            prefix: null,
          };
        },
      peg$c1059 = function(l) {
          // => ident_name[];
          const s = [];
          for (let i = 0; i < l.length; i++) {
            s.push(l[i][1]);
          }
          return s;
        },
      peg$c1060 = function(t) { /* => data_type */ return { dataType: t }},
      peg$c1061 = function(t, l) {
          // => data_type
          return { dataType: t, length: parseInt(l.join(''), 10) };
        },
      peg$c1062 = function(t) { /* =>  data_type */ return { dataType: t }; },
      peg$c1063 = function(t) { /* =>  data_type */  return { dataType: t }; },
      peg$c1064 = function(un, ze) {
          // => any[];
          const result = []
          if (un) result.push(un)
          if (ze) result.push(ze)
          return result
        },
      peg$c1065 = function(t, l, r, s) { /* =>  data_type */ return { dataType: t, length: parseInt(l.join(''), 10), scale: r && parseInt(r[2].join(''), 10), parentheses: true, suffix: s }; },
      peg$c1066 = function(t, l, s) { /* =>  data_type */ return { dataType: t, length: parseInt(l.join(''), 10), suffix: s }; },
      peg$c1067 = function(t, s) { /* =>  data_type */ return { dataType: t, suffix: s }; },
      peg$c1068 = function(t, l) { /* =>  data_type */ return { dataType: t, length: parseInt(l.join(''), 10) }; },
      peg$c1069 = function(t) {/* =>  data_type */  return { dataType: t }; },
      peg$c1070 = function(t) { /* =>  data_type */ return { dataType: `${t}[]` }},
      peg$c1071 = function(t) { /* =>  data_type */ return { dataType: t }},
      peg$c1072 = function(t) {/* =>  data_type */  return { dataType: t }},

      peg$currPos          = 0,
      peg$savedPos         = 0,
      peg$posDetailsCache  = [{ line: 1, column: 1 }],
      peg$maxFailPos       = 0,
      peg$maxFailExpected  = [],
      peg$silentFails      = 0,

      peg$tracer = "tracer" in options ? options.tracer : new peg$DefaultTracer(),

      peg$result;

  if ("startRule" in options) {
    if (!(options.startRule in peg$startRuleFunctions)) {
      throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
    }

    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
  }

  function text() {
    return input.substring(peg$savedPos, peg$currPos);
  }

  function location() {
    return peg$computeLocation(peg$savedPos, peg$currPos);
  }

  function expected(description, location) {
    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

    throw peg$buildStructuredError(
      [peg$otherExpectation(description)],
      input.substring(peg$savedPos, peg$currPos),
      location
    );
  }

  function error(message, location) {
    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

    throw peg$buildSimpleError(message, location);
  }

  function peg$literalExpectation(text, ignoreCase) {
    return { type: "literal", text: text, ignoreCase: ignoreCase };
  }

  function peg$classExpectation(parts, inverted, ignoreCase) {
    return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
  }

  function peg$anyExpectation() {
    return { type: "any" };
  }

  function peg$endExpectation() {
    return { type: "end" };
  }

  function peg$otherExpectation(description) {
    return { type: "other", description: description };
  }

  function peg$computePosDetails(pos) {
    var details = peg$posDetailsCache[pos], p;

    if (details) {
      return details;
    } else {
      p = pos - 1;
      while (!peg$posDetailsCache[p]) {
        p--;
      }

      details = peg$posDetailsCache[p];
      details = {
        line:   details.line,
        column: details.column
      };

      while (p < pos) {
        if (input.charCodeAt(p) === 10) {
          details.line++;
          details.column = 1;
        } else {
          details.column++;
        }

        p++;
      }

      peg$posDetailsCache[pos] = details;
      return details;
    }
  }

  function peg$computeLocation(startPos, endPos) {
    var startPosDetails = peg$computePosDetails(startPos),
        endPosDetails   = peg$computePosDetails(endPos);

    return {
      start: {
        offset: startPos,
        line:   startPosDetails.line,
        column: startPosDetails.column
      },
      end: {
        offset: endPos,
        line:   endPosDetails.line,
        column: endPosDetails.column
      }
    };
  }

  function peg$fail(expected) {
    if (peg$currPos < peg$maxFailPos) { return; }

    if (peg$currPos > peg$maxFailPos) {
      peg$maxFailPos = peg$currPos;
      peg$maxFailExpected = [];
    }

    peg$maxFailExpected.push(expected);
  }

  function peg$buildSimpleError(message, location) {
    return new peg$SyntaxError(message, null, null, location);
  }

  function peg$buildStructuredError(expected, found, location) {
    return new peg$SyntaxError(
      peg$SyntaxError.buildMessage(expected, found),
      expected,
      found,
      location
    );
  }

  function peg$parsestart() {
    var s0, s1, s2,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "start",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parse__();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsemultiple_stmt();
      if (s2 === peg$FAILED) {
        s2 = peg$parsecmd_stmt();
        if (s2 === peg$FAILED) {
          s2 = peg$parsecrud_stmt();
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c0(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "start",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "start",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecmd_stmt() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "cmd_stmt",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$parsedrop_stmt();
    if (s0 === peg$FAILED) {
      s0 = peg$parsecreate_stmt();
      if (s0 === peg$FAILED) {
        s0 = peg$parsetruncate_stmt();
        if (s0 === peg$FAILED) {
          s0 = peg$parserename_stmt();
          if (s0 === peg$FAILED) {
            s0 = peg$parsecall_stmt();
            if (s0 === peg$FAILED) {
              s0 = peg$parseuse_stmt();
              if (s0 === peg$FAILED) {
                s0 = peg$parsealter_table_stmt();
                if (s0 === peg$FAILED) {
                  s0 = peg$parseset_stmt();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parselock_stmt();
                  }
                }
              }
            }
          }
        }
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "cmd_stmt",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "cmd_stmt",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecreate_stmt() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "create_stmt",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$parsecreate_table_stmt();
    if (s0 === peg$FAILED) {
      s0 = peg$parsecreate_constraint_trigger();
      if (s0 === peg$FAILED) {
        s0 = peg$parsecreate_extension_stmt();
        if (s0 === peg$FAILED) {
          s0 = peg$parsecreate_index_stmt();
          if (s0 === peg$FAILED) {
            s0 = peg$parsecreate_sequence();
            if (s0 === peg$FAILED) {
              s0 = peg$parsecreate_db_stmt();
            }
          }
        }
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "create_stmt",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_stmt",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecrud_stmt() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "crud_stmt",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$parseset_operator_stmt();
    if (s0 === peg$FAILED) {
      s0 = peg$parseupdate_stmt();
      if (s0 === peg$FAILED) {
        s0 = peg$parsereplace_insert_stmt();
        if (s0 === peg$FAILED) {
          s0 = peg$parseinsert_no_columns_stmt();
          if (s0 === peg$FAILED) {
            s0 = peg$parsedelete_stmt();
            if (s0 === peg$FAILED) {
              s0 = peg$parsecmd_stmt();
              if (s0 === peg$FAILED) {
                s0 = peg$parseproc_stmts();
              }
            }
          }
        }
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "crud_stmt",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "crud_stmt",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsemultiple_stmt() {
    var s0, s1, s2, s3, s4, s5, s6, s7,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "multiple_stmt",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parsecrud_stmt();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse__();
      if (s4 !== peg$FAILED) {
        s5 = peg$parseSEMICOLON();
        if (s5 !== peg$FAILED) {
          s6 = peg$parse__();
          if (s6 !== peg$FAILED) {
            s7 = peg$parsecrud_stmt();
            if (s7 !== peg$FAILED) {
              s4 = [s4, s5, s6, s7];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseSEMICOLON();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parsecrud_stmt();
                if (s7 !== peg$FAILED) {
                  s4 = [s4, s5, s6, s7];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c1(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "multiple_stmt",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "multiple_stmt",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseunion_operator_stmt() {
    var s0, s1, s2, s3, s4, s5, s6, s7,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "union_operator_stmt",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parse__();
    if (s2 !== peg$FAILED) {
      s3 = peg$parseKW_UNION();
      if (s3 !== peg$FAILED) {
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseKW_ALL();
          if (s5 === peg$FAILED) {
            s5 = null;
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseselect_stmt();
              if (s7 !== peg$FAILED) {
                s2 = [s2, s3, s4, s5, s6, s7];
                s1 = s2;
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c2(s1);
    }
    s0 = s1;

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "union_operator_stmt",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "union_operator_stmt",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseminus_operator_stmt() {
    var s0, s1, s2, s3, s4, s5,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "minus_operator_stmt",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parse__();
    if (s2 !== peg$FAILED) {
      s3 = peg$parseKW_MINUS();
      if (s3 !== peg$FAILED) {
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseselect_stmt();
          if (s5 !== peg$FAILED) {
            s2 = [s2, s3, s4, s5];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c3(s1);
    }
    s0 = s1;

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "minus_operator_stmt",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "minus_operator_stmt",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseintersect_operator_stmt() {
    var s0, s1, s2, s3, s4, s5,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "intersect_operator_stmt",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parse__();
    if (s2 !== peg$FAILED) {
      s3 = peg$parseKW_INTERSECT();
      if (s3 !== peg$FAILED) {
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseselect_stmt();
          if (s5 !== peg$FAILED) {
            s2 = [s2, s3, s4, s5];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c4(s1);
    }
    s0 = s1;

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "intersect_operator_stmt",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "intersect_operator_stmt",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseset_operator_stmt() {
    var s0, s1, s2, s3, s4, s5, s6,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "set_operator_stmt",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseselect_stmt();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseunion_operator_stmt();
      if (s3 === peg$FAILED) {
        s3 = peg$parseminus_operator_stmt();
        if (s3 === peg$FAILED) {
          s3 = peg$parseintersect_operator_stmt();
        }
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parseunion_operator_stmt();
        if (s3 === peg$FAILED) {
          s3 = peg$parseminus_operator_stmt();
          if (s3 === peg$FAILED) {
            s3 = peg$parseintersect_operator_stmt();
          }
        }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse__();
        if (s3 !== peg$FAILED) {
          s4 = peg$parseorder_by_clause();
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parse__();
            if (s5 !== peg$FAILED) {
              s6 = peg$parselimit_clause();
              if (s6 === peg$FAILED) {
                s6 = null;
              }
              if (s6 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c5(s1, s2, s4, s6);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "set_operator_stmt",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "set_operator_stmt",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecreate_extension_stmt() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17, s18,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "create_extension_stmt",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_CREATE();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        if (input.substr(peg$currPos, 9).toLowerCase() === peg$c6) {
          s3 = input.substr(peg$currPos, 9);
          peg$currPos += 9;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c7); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseKW_IF_NOT_EXISTS();
            if (s5 === peg$FAILED) {
              s5 = null;
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseident_name();
                if (s7 === peg$FAILED) {
                  s7 = peg$parseliteral_string();
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse__();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parseKW_WITH();
                    if (s9 === peg$FAILED) {
                      s9 = null;
                    }
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parse__();
                      if (s10 !== peg$FAILED) {
                        s11 = peg$currPos;
                        if (input.substr(peg$currPos, 6).toLowerCase() === peg$c8) {
                          s12 = input.substr(peg$currPos, 6);
                          peg$currPos += 6;
                        } else {
                          s12 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c9); }
                        }
                        if (s12 !== peg$FAILED) {
                          s13 = peg$parse__();
                          if (s13 !== peg$FAILED) {
                            s14 = peg$parseident_name();
                            if (s14 !== peg$FAILED) {
                              s12 = [s12, s13, s14];
                              s11 = s12;
                            } else {
                              peg$currPos = s11;
                              s11 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s11;
                            s11 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s11;
                          s11 = peg$FAILED;
                        }
                        if (s11 === peg$FAILED) {
                          s11 = peg$parseliteral_string();
                        }
                        if (s11 === peg$FAILED) {
                          s11 = null;
                        }
                        if (s11 !== peg$FAILED) {
                          s12 = peg$parse__();
                          if (s12 !== peg$FAILED) {
                            s13 = peg$currPos;
                            if (input.substr(peg$currPos, 7).toLowerCase() === peg$c10) {
                              s14 = input.substr(peg$currPos, 7);
                              peg$currPos += 7;
                            } else {
                              s14 = peg$FAILED;
                              if (peg$silentFails === 0) { peg$fail(peg$c11); }
                            }
                            if (s14 !== peg$FAILED) {
                              s15 = peg$parse__();
                              if (s15 !== peg$FAILED) {
                                s16 = peg$parseident_name();
                                if (s16 === peg$FAILED) {
                                  s16 = peg$parseliteral_string();
                                }
                                if (s16 !== peg$FAILED) {
                                  s14 = [s14, s15, s16];
                                  s13 = s14;
                                } else {
                                  peg$currPos = s13;
                                  s13 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s13;
                                s13 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s13;
                              s13 = peg$FAILED;
                            }
                            if (s13 === peg$FAILED) {
                              s13 = null;
                            }
                            if (s13 !== peg$FAILED) {
                              s14 = peg$parse__();
                              if (s14 !== peg$FAILED) {
                                s15 = peg$currPos;
                                s16 = peg$parseKW_FROM();
                                if (s16 !== peg$FAILED) {
                                  s17 = peg$parse__();
                                  if (s17 !== peg$FAILED) {
                                    s18 = peg$parseident_name();
                                    if (s18 === peg$FAILED) {
                                      s18 = peg$parseliteral_string();
                                    }
                                    if (s18 !== peg$FAILED) {
                                      s16 = [s16, s17, s18];
                                      s15 = s16;
                                    } else {
                                      peg$currPos = s15;
                                      s15 = peg$FAILED;
                                    }
                                  } else {
                                    peg$currPos = s15;
                                    s15 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s15;
                                  s15 = peg$FAILED;
                                }
                                if (s15 === peg$FAILED) {
                                  s15 = null;
                                }
                                if (s15 !== peg$FAILED) {
                                  peg$savedPos = s0;
                                  s1 = peg$c12(s1, s3, s5, s7, s9, s11, s13, s15);
                                  s0 = s1;
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "create_extension_stmt",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_extension_stmt",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecreate_db_definition() {
    var s0, s1, s2, s3, s4, s5,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "create_db_definition",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parsecreate_option_character_set();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse__();
      if (s4 !== peg$FAILED) {
        s5 = peg$parsecreate_option_character_set();
        if (s5 !== peg$FAILED) {
          s4 = [s4, s5];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s5 = peg$parsecreate_option_character_set();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c13(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "create_db_definition",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_db_definition",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecreate_db_stmt() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "create_db_stmt",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_CREATE();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseKW_DATABASE();
        if (s3 === peg$FAILED) {
          s3 = peg$parseKW_SCHEME();
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseKW_IF_NOT_EXISTS();
            if (s5 === peg$FAILED) {
              s5 = null;
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseident_name();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse__();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parsecreate_db_definition();
                    if (s9 === peg$FAILED) {
                      s9 = null;
                    }
                    if (s9 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c14(s1, s3, s5, s7, s9);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "create_db_stmt",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_db_stmt",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecreate_table_stmt() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17, s18, s19,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "create_table_stmt",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_CREATE();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseKW_TEMPORARY();
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseKW_TABLE();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseKW_IF_NOT_EXISTS();
                if (s7 === peg$FAILED) {
                  s7 = null;
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse__();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parsetable_ref_list();
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parse__();
                      if (s10 !== peg$FAILED) {
                        s11 = peg$parsecreate_table_definition();
                        if (s11 !== peg$FAILED) {
                          s12 = peg$parse__();
                          if (s12 !== peg$FAILED) {
                            s13 = peg$parsetable_options();
                            if (s13 === peg$FAILED) {
                              s13 = null;
                            }
                            if (s13 !== peg$FAILED) {
                              s14 = peg$parse__();
                              if (s14 !== peg$FAILED) {
                                s15 = peg$parseKW_IGNORE();
                                if (s15 === peg$FAILED) {
                                  s15 = peg$parseKW_REPLACE();
                                }
                                if (s15 === peg$FAILED) {
                                  s15 = null;
                                }
                                if (s15 !== peg$FAILED) {
                                  s16 = peg$parse__();
                                  if (s16 !== peg$FAILED) {
                                    s17 = peg$parseKW_AS();
                                    if (s17 === peg$FAILED) {
                                      s17 = null;
                                    }
                                    if (s17 !== peg$FAILED) {
                                      s18 = peg$parse__();
                                      if (s18 !== peg$FAILED) {
                                        s19 = peg$parseset_operator_stmt();
                                        if (s19 === peg$FAILED) {
                                          s19 = null;
                                        }
                                        if (s19 !== peg$FAILED) {
                                          peg$savedPos = s0;
                                          s1 = peg$c15(s1, s3, s7, s9, s11, s13, s15, s17, s19);
                                          s0 = s1;
                                        } else {
                                          peg$currPos = s0;
                                          s0 = peg$FAILED;
                                        }
                                      } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                      }
                                    } else {
                                      peg$currPos = s0;
                                      s0 = peg$FAILED;
                                    }
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseKW_CREATE();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseKW_TEMPORARY();
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse__();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseKW_TABLE();
              if (s5 !== peg$FAILED) {
                s6 = peg$parse__();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parseKW_IF_NOT_EXISTS();
                  if (s7 === peg$FAILED) {
                    s7 = null;
                  }
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parse__();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parsetable_ref_list();
                      if (s9 !== peg$FAILED) {
                        s10 = peg$parse__();
                        if (s10 !== peg$FAILED) {
                          s11 = peg$parsecreate_like_table();
                          if (s11 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c16(s1, s3, s7, s9, s11);
                            s0 = s1;
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "create_table_stmt",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_table_stmt",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecreate_sequence() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "create_sequence",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_CREATE();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseKW_TEMPORARY();
        if (s3 === peg$FAILED) {
          s3 = peg$parseKW_TEMP();
        }
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseKW_SEQUENCE();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseKW_IF_NOT_EXISTS();
                if (s7 === peg$FAILED) {
                  s7 = null;
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse__();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parsetable_name();
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parse__();
                      if (s10 !== peg$FAILED) {
                        s11 = peg$currPos;
                        s12 = peg$parseKW_AS();
                        if (s12 !== peg$FAILED) {
                          s13 = peg$parse__();
                          if (s13 !== peg$FAILED) {
                            s14 = peg$parsealias_ident();
                            if (s14 !== peg$FAILED) {
                              s12 = [s12, s13, s14];
                              s11 = s12;
                            } else {
                              peg$currPos = s11;
                              s11 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s11;
                            s11 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s11;
                          s11 = peg$FAILED;
                        }
                        if (s11 === peg$FAILED) {
                          s11 = null;
                        }
                        if (s11 !== peg$FAILED) {
                          s12 = peg$parse__();
                          if (s12 !== peg$FAILED) {
                            s13 = peg$parsecreate_sequence_definition_list();
                            if (s13 === peg$FAILED) {
                              s13 = null;
                            }
                            if (s13 !== peg$FAILED) {
                              peg$savedPos = s0;
                              s1 = peg$c17(s1, s3, s7, s9, s11, s13);
                              s0 = s1;
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "create_sequence",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_sequence",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsesequence_definition_increment() {
    var s0, s1, s2, s3, s4, s5,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "sequence_definition_increment",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 9).toLowerCase() === peg$c18) {
      s1 = input.substr(peg$currPos, 9);
      peg$currPos += 9;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c19); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseKW_BY();
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseliteral_numeric();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c20(s1, s3, s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "sequence_definition_increment",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "sequence_definition_increment",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsesequence_definition_minval() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "sequence_definition_minval",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 8).toLowerCase() === peg$c21) {
      s1 = input.substr(peg$currPos, 8);
      peg$currPos += 8;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c22); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseliteral_numeric();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c23(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2).toLowerCase() === peg$c24) {
        s1 = input.substr(peg$currPos, 2);
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c25); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          if (input.substr(peg$currPos, 8).toLowerCase() === peg$c21) {
            s3 = input.substr(peg$currPos, 8);
            peg$currPos += 8;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c22); }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c26();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "sequence_definition_minval",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "sequence_definition_minval",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsesequence_definition_maxval() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "sequence_definition_maxval",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 8).toLowerCase() === peg$c27) {
      s1 = input.substr(peg$currPos, 8);
      peg$currPos += 8;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c28); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseliteral_numeric();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c23(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2).toLowerCase() === peg$c24) {
        s1 = input.substr(peg$currPos, 2);
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c25); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          if (input.substr(peg$currPos, 8).toLowerCase() === peg$c27) {
            s3 = input.substr(peg$currPos, 8);
            peg$currPos += 8;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c28); }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c29();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "sequence_definition_maxval",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "sequence_definition_maxval",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsesequence_definition_start() {
    var s0, s1, s2, s3, s4, s5,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "sequence_definition_start",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c30) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c31); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseKW_WITH();
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseliteral_numeric();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c32(s1, s3, s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "sequence_definition_start",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "sequence_definition_start",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsesequence_definition_cache() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "sequence_definition_cache",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c33) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c34); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseliteral_numeric();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c23(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "sequence_definition_cache",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "sequence_definition_cache",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsesequence_definition_cycle() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "sequence_definition_cycle",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2).toLowerCase() === peg$c24) {
      s1 = input.substr(peg$currPos, 2);
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c25); }
    }
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        if (input.substr(peg$currPos, 5).toLowerCase() === peg$c35) {
          s3 = input.substr(peg$currPos, 5);
          peg$currPos += 5;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c36); }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c37(s1);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "sequence_definition_cycle",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "sequence_definition_cycle",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsesequence_definition_owned() {
    var s0, s1, s2, s3, s4, s5,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "sequence_definition_owned",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c38) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c39); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseKW_BY();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            if (input.substr(peg$currPos, 4).toLowerCase() === peg$c40) {
              s5 = input.substr(peg$currPos, 4);
              peg$currPos += 4;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c41); }
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c42();
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 5).toLowerCase() === peg$c38) {
        s1 = input.substr(peg$currPos, 5);
        peg$currPos += 5;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c39); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseKW_BY();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse__();
            if (s4 !== peg$FAILED) {
              s5 = peg$parsecolumn_ref();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c43(s1, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "sequence_definition_owned",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "sequence_definition_owned",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecreate_sequence_definition() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "create_sequence_definition",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$parsesequence_definition_increment();
    if (s0 === peg$FAILED) {
      s0 = peg$parsesequence_definition_minval();
      if (s0 === peg$FAILED) {
        s0 = peg$parsesequence_definition_maxval();
        if (s0 === peg$FAILED) {
          s0 = peg$parsesequence_definition_start();
          if (s0 === peg$FAILED) {
            s0 = peg$parsesequence_definition_cache();
            if (s0 === peg$FAILED) {
              s0 = peg$parsesequence_definition_cycle();
              if (s0 === peg$FAILED) {
                s0 = peg$parsesequence_definition_owned();
              }
            }
          }
        }
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "create_sequence_definition",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_sequence_definition",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecreate_sequence_definition_list() {
    var s0, s1, s2, s3, s4, s5,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "create_sequence_definition_list",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parsecreate_sequence_definition();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse__();
      if (s4 !== peg$FAILED) {
        s5 = peg$parsecreate_sequence_definition();
        if (s5 !== peg$FAILED) {
          s4 = [s4, s5];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s5 = peg$parsecreate_sequence_definition();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c44(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "create_sequence_definition_list",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_sequence_definition_list",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecreate_index_stmt() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17, s18, s19, s20, s21, s22, s23, s24, s25, s26, s27, s28, s29, s30,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "create_index_stmt",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_CREATE();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseKW_UNIQUE();
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseKW_INDEX();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseKW_CONCURRENTLY();
                if (s7 === peg$FAILED) {
                  s7 = null;
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse__();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parseident();
                    if (s9 === peg$FAILED) {
                      s9 = null;
                    }
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parse__();
                      if (s10 !== peg$FAILED) {
                        s11 = peg$parseKW_ON();
                        if (s11 !== peg$FAILED) {
                          s12 = peg$parse__();
                          if (s12 !== peg$FAILED) {
                            s13 = peg$parsetable_name();
                            if (s13 !== peg$FAILED) {
                              s14 = peg$parse__();
                              if (s14 !== peg$FAILED) {
                                s15 = peg$parseindex_type();
                                if (s15 === peg$FAILED) {
                                  s15 = null;
                                }
                                if (s15 !== peg$FAILED) {
                                  s16 = peg$parse__();
                                  if (s16 !== peg$FAILED) {
                                    s17 = peg$parseLPAREN();
                                    if (s17 !== peg$FAILED) {
                                      s18 = peg$parse__();
                                      if (s18 !== peg$FAILED) {
                                        s19 = peg$parsecolumn_order_list();
                                        if (s19 !== peg$FAILED) {
                                          s20 = peg$parse__();
                                          if (s20 !== peg$FAILED) {
                                            s21 = peg$parseRPAREN();
                                            if (s21 !== peg$FAILED) {
                                              s22 = peg$parse__();
                                              if (s22 !== peg$FAILED) {
                                                s23 = peg$currPos;
                                                s24 = peg$parseKW_WITH();
                                                if (s24 !== peg$FAILED) {
                                                  s25 = peg$parse__();
                                                  if (s25 !== peg$FAILED) {
                                                    s26 = peg$parseLPAREN();
                                                    if (s26 !== peg$FAILED) {
                                                      s27 = peg$parse__();
                                                      if (s27 !== peg$FAILED) {
                                                        s28 = peg$parseindex_options_list();
                                                        if (s28 !== peg$FAILED) {
                                                          s29 = peg$parse__();
                                                          if (s29 !== peg$FAILED) {
                                                            s30 = peg$parseRPAREN();
                                                            if (s30 !== peg$FAILED) {
                                                              s24 = [s24, s25, s26, s27, s28, s29, s30];
                                                              s23 = s24;
                                                            } else {
                                                              peg$currPos = s23;
                                                              s23 = peg$FAILED;
                                                            }
                                                          } else {
                                                            peg$currPos = s23;
                                                            s23 = peg$FAILED;
                                                          }
                                                        } else {
                                                          peg$currPos = s23;
                                                          s23 = peg$FAILED;
                                                        }
                                                      } else {
                                                        peg$currPos = s23;
                                                        s23 = peg$FAILED;
                                                      }
                                                    } else {
                                                      peg$currPos = s23;
                                                      s23 = peg$FAILED;
                                                    }
                                                  } else {
                                                    peg$currPos = s23;
                                                    s23 = peg$FAILED;
                                                  }
                                                } else {
                                                  peg$currPos = s23;
                                                  s23 = peg$FAILED;
                                                }
                                                if (s23 === peg$FAILED) {
                                                  s23 = null;
                                                }
                                                if (s23 !== peg$FAILED) {
                                                  s24 = peg$parse__();
                                                  if (s24 !== peg$FAILED) {
                                                    s25 = peg$currPos;
                                                    s26 = peg$parseKW_TABLESPACE();
                                                    if (s26 !== peg$FAILED) {
                                                      s27 = peg$parse__();
                                                      if (s27 !== peg$FAILED) {
                                                        s28 = peg$parseident_name();
                                                        if (s28 !== peg$FAILED) {
                                                          s26 = [s26, s27, s28];
                                                          s25 = s26;
                                                        } else {
                                                          peg$currPos = s25;
                                                          s25 = peg$FAILED;
                                                        }
                                                      } else {
                                                        peg$currPos = s25;
                                                        s25 = peg$FAILED;
                                                      }
                                                    } else {
                                                      peg$currPos = s25;
                                                      s25 = peg$FAILED;
                                                    }
                                                    if (s25 === peg$FAILED) {
                                                      s25 = null;
                                                    }
                                                    if (s25 !== peg$FAILED) {
                                                      s26 = peg$parse__();
                                                      if (s26 !== peg$FAILED) {
                                                        s27 = peg$parsewhere_clause();
                                                        if (s27 === peg$FAILED) {
                                                          s27 = null;
                                                        }
                                                        if (s27 !== peg$FAILED) {
                                                          s28 = peg$parse__();
                                                          if (s28 !== peg$FAILED) {
                                                            peg$savedPos = s0;
                                                            s1 = peg$c45(s1, s3, s5, s7, s9, s11, s13, s15, s19, s23, s25, s27);
                                                            s0 = s1;
                                                          } else {
                                                            peg$currPos = s0;
                                                            s0 = peg$FAILED;
                                                          }
                                                        } else {
                                                          peg$currPos = s0;
                                                          s0 = peg$FAILED;
                                                        }
                                                      } else {
                                                        peg$currPos = s0;
                                                        s0 = peg$FAILED;
                                                      }
                                                    } else {
                                                      peg$currPos = s0;
                                                      s0 = peg$FAILED;
                                                    }
                                                  } else {
                                                    peg$currPos = s0;
                                                    s0 = peg$FAILED;
                                                  }
                                                } else {
                                                  peg$currPos = s0;
                                                  s0 = peg$FAILED;
                                                }
                                              } else {
                                                peg$currPos = s0;
                                                s0 = peg$FAILED;
                                              }
                                            } else {
                                              peg$currPos = s0;
                                              s0 = peg$FAILED;
                                            }
                                          } else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                          }
                                        } else {
                                          peg$currPos = s0;
                                          s0 = peg$FAILED;
                                        }
                                      } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                      }
                                    } else {
                                      peg$currPos = s0;
                                      s0 = peg$FAILED;
                                    }
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "create_index_stmt",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_index_stmt",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecolumn_order_list() {
    var s0, s1, s2, s3, s4, s5, s6, s7,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "column_order_list",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parsecolumn_order();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse__();
      if (s4 !== peg$FAILED) {
        s5 = peg$parseCOMMA();
        if (s5 !== peg$FAILED) {
          s6 = peg$parse__();
          if (s6 !== peg$FAILED) {
            s7 = peg$parsecolumn_order();
            if (s7 !== peg$FAILED) {
              s4 = [s4, s5, s6, s7];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseCOMMA();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s7 = peg$parsecolumn_order();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c46(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "column_order_list",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "column_order_list",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecolumn_order() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "column_order",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseexpr();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parsecollate_expr();
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseident();
            if (s5 === peg$FAILED) {
              s5 = null;
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseKW_ASC();
                if (s7 === peg$FAILED) {
                  s7 = peg$parseKW_DESC();
                }
                if (s7 === peg$FAILED) {
                  s7 = null;
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse__();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$currPos;
                    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c47) {
                      s10 = input.substr(peg$currPos, 5);
                      peg$currPos += 5;
                    } else {
                      s10 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c48); }
                    }
                    if (s10 !== peg$FAILED) {
                      s11 = peg$parse__();
                      if (s11 !== peg$FAILED) {
                        if (input.substr(peg$currPos, 5).toLowerCase() === peg$c49) {
                          s12 = input.substr(peg$currPos, 5);
                          peg$currPos += 5;
                        } else {
                          s12 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c50); }
                        }
                        if (s12 === peg$FAILED) {
                          if (input.substr(peg$currPos, 4).toLowerCase() === peg$c51) {
                            s12 = input.substr(peg$currPos, 4);
                            peg$currPos += 4;
                          } else {
                            s12 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$c52); }
                          }
                        }
                        if (s12 !== peg$FAILED) {
                          s10 = [s10, s11, s12];
                          s9 = s10;
                        } else {
                          peg$currPos = s9;
                          s9 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s9;
                        s9 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s9;
                      s9 = peg$FAILED;
                    }
                    if (s9 === peg$FAILED) {
                      s9 = null;
                    }
                    if (s9 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c53(s1, s3, s5, s7, s9);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "column_order",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "column_order",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecreate_like_table_simple() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "create_like_table_simple",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_LIKE();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parsetable_ref_list();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c54(s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "create_like_table_simple",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_like_table_simple",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecreate_like_table() {
    var s0, s1, s2, s3, s4, s5,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "create_like_table",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$parsecreate_like_table_simple();
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseLPAREN();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsecreate_like_table();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse__();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseRPAREN();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c55(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "create_like_table",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_like_table",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecreate_table_definition() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "create_table_definition",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseLPAREN();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parsecreate_definition();
        if (s3 !== peg$FAILED) {
          s4 = [];
          s5 = peg$currPos;
          s6 = peg$parse__();
          if (s6 !== peg$FAILED) {
            s7 = peg$parseCOMMA();
            if (s7 !== peg$FAILED) {
              s8 = peg$parse__();
              if (s8 !== peg$FAILED) {
                s9 = peg$parsecreate_definition();
                if (s9 !== peg$FAILED) {
                  s6 = [s6, s7, s8, s9];
                  s5 = s6;
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$currPos;
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseCOMMA();
              if (s7 !== peg$FAILED) {
                s8 = peg$parse__();
                if (s8 !== peg$FAILED) {
                  s9 = peg$parsecreate_definition();
                  if (s9 !== peg$FAILED) {
                    s6 = [s6, s7, s8, s9];
                    s5 = s6;
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parse__();
            if (s5 !== peg$FAILED) {
              s6 = peg$parseRPAREN();
              if (s6 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c56(s3, s4);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "create_table_definition",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_table_definition",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecreate_definition() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "create_definition",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$parsecreate_column_definition();
    if (s0 === peg$FAILED) {
      s0 = peg$parsecreate_index_definition();
      if (s0 === peg$FAILED) {
        s0 = peg$parsecreate_fulltext_spatial_index_definition();
        if (s0 === peg$FAILED) {
          s0 = peg$parsecreate_constraint_definition();
        }
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "create_definition",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_definition",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecreate_column_definition() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17, s18, s19,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "create_column_definition",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parsecolumn_ref();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parsedata_type();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parsecolumn_constraint();
            if (s5 === peg$FAILED) {
              s5 = null;
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                if (input.substr(peg$currPos, 14).toLowerCase() === peg$c57) {
                  s7 = input.substr(peg$currPos, 14);
                  peg$currPos += 14;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c58); }
                }
                if (s7 === peg$FAILED) {
                  s7 = null;
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse__();
                  if (s8 !== peg$FAILED) {
                    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c59) {
                      s9 = input.substr(peg$currPos, 6);
                      peg$currPos += 6;
                    } else {
                      s9 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c60); }
                    }
                    if (s9 === peg$FAILED) {
                      s9 = peg$currPos;
                      if (input.substr(peg$currPos, 7).toLowerCase() === peg$c61) {
                        s10 = input.substr(peg$currPos, 7);
                        peg$currPos += 7;
                      } else {
                        s10 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c62); }
                      }
                      if (s10 !== peg$FAILED) {
                        s11 = peg$parse__();
                        if (s11 !== peg$FAILED) {
                          if (input.substr(peg$currPos, 3).toLowerCase() === peg$c63) {
                            s12 = input.substr(peg$currPos, 3);
                            peg$currPos += 3;
                          } else {
                            s12 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$c64); }
                          }
                          if (s12 !== peg$FAILED) {
                            s10 = [s10, s11, s12];
                            s9 = s10;
                          } else {
                            peg$currPos = s9;
                            s9 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s9;
                          s9 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s9;
                        s9 = peg$FAILED;
                      }
                    }
                    if (s9 === peg$FAILED) {
                      s9 = null;
                    }
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parse__();
                      if (s10 !== peg$FAILED) {
                        s11 = peg$parsekeyword_comment();
                        if (s11 === peg$FAILED) {
                          s11 = null;
                        }
                        if (s11 !== peg$FAILED) {
                          s12 = peg$parse__();
                          if (s12 !== peg$FAILED) {
                            s13 = peg$parsecollate_expr();
                            if (s13 === peg$FAILED) {
                              s13 = null;
                            }
                            if (s13 !== peg$FAILED) {
                              s14 = peg$parse__();
                              if (s14 !== peg$FAILED) {
                                s15 = peg$parsecolumn_format();
                                if (s15 === peg$FAILED) {
                                  s15 = null;
                                }
                                if (s15 !== peg$FAILED) {
                                  s16 = peg$parse__();
                                  if (s16 !== peg$FAILED) {
                                    s17 = peg$parsestorage();
                                    if (s17 === peg$FAILED) {
                                      s17 = null;
                                    }
                                    if (s17 !== peg$FAILED) {
                                      s18 = peg$parse__();
                                      if (s18 !== peg$FAILED) {
                                        s19 = peg$parsereference_definition();
                                        if (s19 === peg$FAILED) {
                                          s19 = null;
                                        }
                                        if (s19 !== peg$FAILED) {
                                          peg$savedPos = s0;
                                          s1 = peg$c65(s1, s3, s5, s7, s9, s11, s13, s15, s17, s19);
                                          s0 = s1;
                                        } else {
                                          peg$currPos = s0;
                                          s0 = peg$FAILED;
                                        }
                                      } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                      }
                                    } else {
                                      peg$currPos = s0;
                                      s0 = peg$FAILED;
                                    }
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "create_column_definition",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_column_definition",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecolumn_constraint() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "column_constraint",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseliteral_not_null();
    if (s1 === peg$FAILED) {
      s1 = peg$parseliteral_null();
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parsedefault_expr();
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c66(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parsedefault_expr();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseliteral_not_null();
          if (s3 === peg$FAILED) {
            s3 = peg$parseliteral_null();
          }
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c67(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "column_constraint",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "column_constraint",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecollate_expr() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "collate_expr",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_COLLATE();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseident();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c68(s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "collate_expr",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "collate_expr",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecolumn_format() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "column_format",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 13).toLowerCase() === peg$c69) {
      s1 = input.substr(peg$currPos, 13);
      peg$currPos += 13;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c70); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        if (input.substr(peg$currPos, 5).toLowerCase() === peg$c71) {
          s3 = input.substr(peg$currPos, 5);
          peg$currPos += 5;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c72); }
        }
        if (s3 === peg$FAILED) {
          if (input.substr(peg$currPos, 7).toLowerCase() === peg$c73) {
            s3 = input.substr(peg$currPos, 7);
            peg$currPos += 7;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c74); }
          }
          if (s3 === peg$FAILED) {
            if (input.substr(peg$currPos, 7).toLowerCase() === peg$c75) {
              s3 = input.substr(peg$currPos, 7);
              peg$currPos += 7;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c76); }
            }
          }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c77(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "column_format",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "column_format",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsestorage() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "storage",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c78) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c79); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        if (input.substr(peg$currPos, 4).toLowerCase() === peg$c80) {
          s3 = input.substr(peg$currPos, 4);
          peg$currPos += 4;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c81); }
        }
        if (s3 === peg$FAILED) {
          if (input.substr(peg$currPos, 6).toLowerCase() === peg$c82) {
            s3 = input.substr(peg$currPos, 6);
            peg$currPos += 6;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c83); }
          }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c84(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "storage",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "storage",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsedefault_expr() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "default_expr",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_DEFAULT();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseliteral();
        if (s3 === peg$FAILED) {
          s3 = peg$parseexpr();
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c85(s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "default_expr",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "default_expr",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsedrop_index_opt() {
    var s0, s1, s2, s3, s4, s5,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "drop_index_opt",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseALTER_ALGORITHM();
    if (s1 === peg$FAILED) {
      s1 = peg$parseALTER_LOCK();
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse__();
      if (s4 !== peg$FAILED) {
        s5 = peg$parseALTER_ALGORITHM();
        if (s5 === peg$FAILED) {
          s5 = peg$parseALTER_LOCK();
        }
        if (s5 !== peg$FAILED) {
          s4 = [s4, s5];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseALTER_ALGORITHM();
          if (s5 === peg$FAILED) {
            s5 = peg$parseALTER_LOCK();
          }
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c86(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "drop_index_opt",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "drop_index_opt",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsedrop_stmt() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "drop_stmt",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_DROP();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseKW_TABLE();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parsetable_ref_list();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c87(s1, s3, s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseKW_DROP();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseKW_INDEX();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse__();
            if (s4 !== peg$FAILED) {
              s5 = peg$parsecolumn_ref();
              if (s5 !== peg$FAILED) {
                s6 = peg$parse__();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parseKW_ON();
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parse__();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parsetable_name();
                      if (s9 !== peg$FAILED) {
                        s10 = peg$parse__();
                        if (s10 !== peg$FAILED) {
                          s11 = peg$parsedrop_index_opt();
                          if (s11 === peg$FAILED) {
                            s11 = null;
                          }
                          if (s11 !== peg$FAILED) {
                            s12 = peg$parse__();
                            if (s12 !== peg$FAILED) {
                              peg$savedPos = s0;
                              s1 = peg$c88(s1, s3, s5, s9, s11);
                              s0 = s1;
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "drop_stmt",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "drop_stmt",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsetruncate_stmt() {
    var s0, s1, s2, s3, s4, s5,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "truncate_stmt",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_TRUNCATE();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseKW_TABLE();
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parsetable_ref_list();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c89(s1, s3, s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "truncate_stmt",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "truncate_stmt",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseuse_stmt() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "use_stmt",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_USE();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseident();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c90(s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "use_stmt",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "use_stmt",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsealter_table_stmt() {
    var s0, s1, s2, s3, s4, s5, s6, s7,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "alter_table_stmt",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_ALTER();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseKW_TABLE();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parsetable_ref_list();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parsealter_action_list();
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c91(s5, s7);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "alter_table_stmt",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "alter_table_stmt",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsealter_action_list() {
    var s0, s1, s2, s3, s4, s5, s6, s7,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "alter_action_list",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parsealter_action();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse__();
      if (s4 !== peg$FAILED) {
        s5 = peg$parseCOMMA();
        if (s5 !== peg$FAILED) {
          s6 = peg$parse__();
          if (s6 !== peg$FAILED) {
            s7 = peg$parsealter_action();
            if (s7 !== peg$FAILED) {
              s4 = [s4, s5, s6, s7];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseCOMMA();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s7 = peg$parsealter_action();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c92(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "alter_action_list",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "alter_action_list",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsealter_action() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "alter_action",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$parseALTER_ADD_COLUMN();
    if (s0 === peg$FAILED) {
      s0 = peg$parseALTER_DROP_COLUMN();
      if (s0 === peg$FAILED) {
        s0 = peg$parseALTER_ADD_INDEX_OR_KEY();
        if (s0 === peg$FAILED) {
          s0 = peg$parseALTER_ADD_FULLETXT_SPARITAL_INDEX();
          if (s0 === peg$FAILED) {
            s0 = peg$parseALTER_RENAME_TABLE();
            if (s0 === peg$FAILED) {
              s0 = peg$parseALTER_ALGORITHM();
              if (s0 === peg$FAILED) {
                s0 = peg$parseALTER_LOCK();
              }
            }
          }
        }
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "alter_action",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "alter_action",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseALTER_ADD_COLUMN() {
    var s0, s1, s2, s3, s4, s5,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "ALTER_ADD_COLUMN",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_ADD();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseKW_COLUMN();
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parsecreate_column_definition();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c93(s3, s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "ALTER_ADD_COLUMN",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "ALTER_ADD_COLUMN",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseALTER_DROP_COLUMN() {
    var s0, s1, s2, s3, s4, s5,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "ALTER_DROP_COLUMN",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_DROP();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseKW_COLUMN();
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parsecolumn_ref();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c94(s3, s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "ALTER_DROP_COLUMN",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "ALTER_DROP_COLUMN",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseALTER_ADD_INDEX_OR_KEY() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "ALTER_ADD_INDEX_OR_KEY",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_ADD();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parsecreate_index_definition();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c95(s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "ALTER_ADD_INDEX_OR_KEY",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "ALTER_ADD_INDEX_OR_KEY",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseALTER_RENAME_TABLE() {
    var s0, s1, s2, s3, s4, s5,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "ALTER_RENAME_TABLE",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_RENAME();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseKW_TO();
        if (s3 === peg$FAILED) {
          s3 = peg$parseKW_AS();
        }
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseident();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c96(s3, s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "ALTER_RENAME_TABLE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "ALTER_RENAME_TABLE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseALTER_ALGORITHM() {
    var s0, s1, s2, s3, s4, s5,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "ALTER_ALGORITHM",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 9).toLowerCase() === peg$c97) {
      s1 = input.substr(peg$currPos, 9);
      peg$currPos += 9;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c98); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseKW_ASSIGIN_EQUAL();
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            if (input.substr(peg$currPos, 7).toLowerCase() === peg$c75) {
              s5 = input.substr(peg$currPos, 7);
              peg$currPos += 7;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c76); }
            }
            if (s5 === peg$FAILED) {
              if (input.substr(peg$currPos, 7).toLowerCase() === peg$c99) {
                s5 = input.substr(peg$currPos, 7);
                peg$currPos += 7;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c100); }
              }
              if (s5 === peg$FAILED) {
                if (input.substr(peg$currPos, 7).toLowerCase() === peg$c101) {
                  s5 = input.substr(peg$currPos, 7);
                  peg$currPos += 7;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c102); }
                }
                if (s5 === peg$FAILED) {
                  if (input.substr(peg$currPos, 4).toLowerCase() === peg$c103) {
                    s5 = input.substr(peg$currPos, 4);
                    peg$currPos += 4;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c104); }
                  }
                }
              }
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c105(s3, s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "ALTER_ALGORITHM",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "ALTER_ALGORITHM",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseALTER_LOCK() {
    var s0, s1, s2, s3, s4, s5,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "ALTER_LOCK",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c106) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c107); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseKW_ASSIGIN_EQUAL();
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            if (input.substr(peg$currPos, 7).toLowerCase() === peg$c75) {
              s5 = input.substr(peg$currPos, 7);
              peg$currPos += 7;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c76); }
            }
            if (s5 === peg$FAILED) {
              if (input.substr(peg$currPos, 4).toLowerCase() === peg$c40) {
                s5 = input.substr(peg$currPos, 4);
                peg$currPos += 4;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c41); }
              }
              if (s5 === peg$FAILED) {
                if (input.substr(peg$currPos, 6).toLowerCase() === peg$c108) {
                  s5 = input.substr(peg$currPos, 6);
                  peg$currPos += 6;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c109); }
                }
                if (s5 === peg$FAILED) {
                  if (input.substr(peg$currPos, 9).toLowerCase() === peg$c110) {
                    s5 = input.substr(peg$currPos, 9);
                    peg$currPos += 9;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c111); }
                  }
                }
              }
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c112(s3, s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "ALTER_LOCK",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "ALTER_LOCK",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecreate_index_definition() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "create_index_definition",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_INDEX();
    if (s1 === peg$FAILED) {
      s1 = peg$parseKW_KEY();
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parsecolumn();
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseindex_type();
            if (s5 === peg$FAILED) {
              s5 = null;
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parsecte_column_definition();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse__();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parseindex_options();
                    if (s9 === peg$FAILED) {
                      s9 = null;
                    }
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parse__();
                      if (s10 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c113(s1, s3, s5, s7, s9);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "create_index_definition",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_index_definition",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecreate_fulltext_spatial_index_definition() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "create_fulltext_spatial_index_definition",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_FULLTEXT();
    if (s1 === peg$FAILED) {
      s1 = peg$parseKW_SPATIAL();
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseKW_INDEX();
        if (s3 === peg$FAILED) {
          s3 = peg$parseKW_KEY();
        }
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parsecolumn();
            if (s5 === peg$FAILED) {
              s5 = null;
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parsecte_column_definition();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse__();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parseindex_options();
                    if (s9 === peg$FAILED) {
                      s9 = null;
                    }
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parse__();
                      if (s10 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c114(s1, s3, s5, s7, s9);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "create_fulltext_spatial_index_definition",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_fulltext_spatial_index_definition",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecreate_constraint_definition() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "create_constraint_definition",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$parsecreate_constraint_primary();
    if (s0 === peg$FAILED) {
      s0 = peg$parsecreate_constraint_unique();
      if (s0 === peg$FAILED) {
        s0 = peg$parsecreate_constraint_foreign();
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "create_constraint_definition",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_constraint_definition",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseconstraint_name() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "constraint_name",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_CONSTRAINT();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseident();
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c115(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "constraint_name",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "constraint_name",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecreate_constraint_primary() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "create_constraint_primary",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseconstraint_name();
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        if (input.substr(peg$currPos, 11).toLowerCase() === peg$c116) {
          s3 = input.substr(peg$currPos, 11);
          peg$currPos += 11;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c117); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseindex_type();
            if (s5 === peg$FAILED) {
              s5 = null;
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parsecte_column_definition();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse__();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parseindex_options();
                    if (s9 === peg$FAILED) {
                      s9 = null;
                    }
                    if (s9 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c118(s1, s3, s5, s7, s9);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "create_constraint_primary",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_constraint_primary",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecreate_constraint_unique() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "create_constraint_unique",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseconstraint_name();
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseKW_UNIQUE();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseKW_INDEX();
            if (s5 === peg$FAILED) {
              s5 = peg$parseKW_KEY();
            }
            if (s5 === peg$FAILED) {
              s5 = null;
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parsecolumn();
                if (s7 === peg$FAILED) {
                  s7 = null;
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse__();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parseindex_type();
                    if (s9 === peg$FAILED) {
                      s9 = null;
                    }
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parse__();
                      if (s10 !== peg$FAILED) {
                        s11 = peg$parsecte_column_definition();
                        if (s11 !== peg$FAILED) {
                          s12 = peg$parse__();
                          if (s12 !== peg$FAILED) {
                            s13 = peg$parseindex_options();
                            if (s13 === peg$FAILED) {
                              s13 = null;
                            }
                            if (s13 !== peg$FAILED) {
                              peg$savedPos = s0;
                              s1 = peg$c119(s1, s3, s5, s7, s9, s11, s13);
                              s0 = s1;
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "create_constraint_unique",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_constraint_unique",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecreate_constraint_foreign() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "create_constraint_foreign",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseconstraint_name();
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        if (input.substr(peg$currPos, 11).toLowerCase() === peg$c120) {
          s3 = input.substr(peg$currPos, 11);
          peg$currPos += 11;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c121); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parsecolumn();
            if (s5 === peg$FAILED) {
              s5 = null;
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parsecte_column_definition();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse__();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parsereference_definition();
                    if (s9 === peg$FAILED) {
                      s9 = null;
                    }
                    if (s9 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c122(s1, s3, s5, s7, s9);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "create_constraint_foreign",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_constraint_foreign",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsereference_definition() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "reference_definition",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_REFERENCES();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parsetable_ref_list();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parsecte_column_definition();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                if (input.substr(peg$currPos, 10).toLowerCase() === peg$c123) {
                  s7 = input.substr(peg$currPos, 10);
                  peg$currPos += 10;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c124); }
                }
                if (s7 === peg$FAILED) {
                  if (input.substr(peg$currPos, 13).toLowerCase() === peg$c125) {
                    s7 = input.substr(peg$currPos, 13);
                    peg$currPos += 13;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c126); }
                  }
                  if (s7 === peg$FAILED) {
                    if (input.substr(peg$currPos, 12).toLowerCase() === peg$c127) {
                      s7 = input.substr(peg$currPos, 12);
                      peg$currPos += 12;
                    } else {
                      s7 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c128); }
                    }
                  }
                }
                if (s7 === peg$FAILED) {
                  s7 = null;
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse__();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parseon_reference();
                    if (s9 === peg$FAILED) {
                      s9 = null;
                    }
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parse__();
                      if (s10 !== peg$FAILED) {
                        s11 = peg$parseon_reference();
                        if (s11 === peg$FAILED) {
                          s11 = null;
                        }
                        if (s11 !== peg$FAILED) {
                          peg$savedPos = s0;
                          s1 = peg$c129(s1, s3, s5, s7, s9, s11);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "reference_definition",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "reference_definition",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseon_reference() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "on_reference",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 9).toLowerCase() === peg$c130) {
      s1 = input.substr(peg$currPos, 9);
      peg$currPos += 9;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c131); }
    }
    if (s1 === peg$FAILED) {
      if (input.substr(peg$currPos, 9).toLowerCase() === peg$c132) {
        s1 = input.substr(peg$currPos, 9);
        peg$currPos += 9;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c133); }
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parsereference_option();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c134(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "on_reference",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "on_reference",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsereference_option() {
    var s0, s1,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "reference_option",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 8).toLowerCase() === peg$c135) {
      s1 = input.substr(peg$currPos, 8);
      peg$currPos += 8;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c136); }
    }
    if (s1 === peg$FAILED) {
      if (input.substr(peg$currPos, 7).toLowerCase() === peg$c137) {
        s1 = input.substr(peg$currPos, 7);
        peg$currPos += 7;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c138); }
      }
      if (s1 === peg$FAILED) {
        if (input.substr(peg$currPos, 8).toLowerCase() === peg$c139) {
          s1 = input.substr(peg$currPos, 8);
          peg$currPos += 8;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c140); }
        }
        if (s1 === peg$FAILED) {
          if (input.substr(peg$currPos, 9).toLowerCase() === peg$c141) {
            s1 = input.substr(peg$currPos, 9);
            peg$currPos += 9;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c142); }
          }
          if (s1 === peg$FAILED) {
            if (input.substr(peg$currPos, 11).toLowerCase() === peg$c143) {
              s1 = input.substr(peg$currPos, 11);
              peg$currPos += 11;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c144); }
            }
          }
        }
      }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c145(s1);
    }
    s0 = s1;

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "reference_option",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "reference_option",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecreate_constraint_trigger() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17, s18, s19, s20, s21, s22, s23, s24, s25, s26, s27, s28, s29,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "create_constraint_trigger",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_CREATE();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseKW_CONSTRAINT();
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            if (input.substr(peg$currPos, 7).toLowerCase() === peg$c146) {
              s5 = input.substr(peg$currPos, 7);
              peg$currPos += 7;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c147); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseident_name();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse__();
                  if (s8 !== peg$FAILED) {
                    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c148) {
                      s9 = input.substr(peg$currPos, 6);
                      peg$currPos += 6;
                    } else {
                      s9 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c149); }
                    }
                    if (s9 === peg$FAILED) {
                      if (input.substr(peg$currPos, 5).toLowerCase() === peg$c150) {
                        s9 = input.substr(peg$currPos, 5);
                        peg$currPos += 5;
                      } else {
                        s9 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c151); }
                      }
                      if (s9 === peg$FAILED) {
                        if (input.substr(peg$currPos, 10).toLowerCase() === peg$c152) {
                          s9 = input.substr(peg$currPos, 10);
                          peg$currPos += 10;
                        } else {
                          s9 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c153); }
                        }
                      }
                    }
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parse__();
                      if (s10 !== peg$FAILED) {
                        s11 = peg$parsetrigger_event_list();
                        if (s11 !== peg$FAILED) {
                          s12 = peg$parse__();
                          if (s12 !== peg$FAILED) {
                            if (input.substr(peg$currPos, 2).toLowerCase() === peg$c154) {
                              s13 = input.substr(peg$currPos, 2);
                              peg$currPos += 2;
                            } else {
                              s13 = peg$FAILED;
                              if (peg$silentFails === 0) { peg$fail(peg$c155); }
                            }
                            if (s13 !== peg$FAILED) {
                              s14 = peg$parse__();
                              if (s14 !== peg$FAILED) {
                                s15 = peg$parsetable_name();
                                if (s15 !== peg$FAILED) {
                                  s16 = peg$parse__();
                                  if (s16 !== peg$FAILED) {
                                    s17 = peg$currPos;
                                    s18 = peg$parseKW_FROM();
                                    if (s18 !== peg$FAILED) {
                                      s19 = peg$parse__();
                                      if (s19 !== peg$FAILED) {
                                        s20 = peg$parsetable_name();
                                        if (s20 !== peg$FAILED) {
                                          s18 = [s18, s19, s20];
                                          s17 = s18;
                                        } else {
                                          peg$currPos = s17;
                                          s17 = peg$FAILED;
                                        }
                                      } else {
                                        peg$currPos = s17;
                                        s17 = peg$FAILED;
                                      }
                                    } else {
                                      peg$currPos = s17;
                                      s17 = peg$FAILED;
                                    }
                                    if (s17 === peg$FAILED) {
                                      s17 = null;
                                    }
                                    if (s17 !== peg$FAILED) {
                                      s18 = peg$parse__();
                                      if (s18 !== peg$FAILED) {
                                        s19 = peg$parsetrigger_deferrable();
                                        if (s19 === peg$FAILED) {
                                          s19 = null;
                                        }
                                        if (s19 !== peg$FAILED) {
                                          s20 = peg$parse__();
                                          if (s20 !== peg$FAILED) {
                                            s21 = peg$parsetrigger_for_row();
                                            if (s21 === peg$FAILED) {
                                              s21 = null;
                                            }
                                            if (s21 !== peg$FAILED) {
                                              s22 = peg$parse__();
                                              if (s22 !== peg$FAILED) {
                                                s23 = peg$parsetrigger_when();
                                                if (s23 === peg$FAILED) {
                                                  s23 = null;
                                                }
                                                if (s23 !== peg$FAILED) {
                                                  s24 = peg$parse__();
                                                  if (s24 !== peg$FAILED) {
                                                    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c156) {
                                                      s25 = input.substr(peg$currPos, 7);
                                                      peg$currPos += 7;
                                                    } else {
                                                      s25 = peg$FAILED;
                                                      if (peg$silentFails === 0) { peg$fail(peg$c157); }
                                                    }
                                                    if (s25 !== peg$FAILED) {
                                                      s26 = peg$parse__();
                                                      if (s26 !== peg$FAILED) {
                                                        if (input.substr(peg$currPos, 9).toLowerCase() === peg$c158) {
                                                          s27 = input.substr(peg$currPos, 9);
                                                          peg$currPos += 9;
                                                        } else {
                                                          s27 = peg$FAILED;
                                                          if (peg$silentFails === 0) { peg$fail(peg$c159); }
                                                        }
                                                        if (s27 !== peg$FAILED) {
                                                          s28 = peg$parse__();
                                                          if (s28 !== peg$FAILED) {
                                                            s29 = peg$parseproc_func_call();
                                                            if (s29 !== peg$FAILED) {
                                                              peg$savedPos = s0;
                                                              s1 = peg$c160(s1, s3, s5, s7, s9, s11, s13, s15, s17, s19, s21, s23, s25, s29);
                                                              s0 = s1;
                                                            } else {
                                                              peg$currPos = s0;
                                                              s0 = peg$FAILED;
                                                            }
                                                          } else {
                                                            peg$currPos = s0;
                                                            s0 = peg$FAILED;
                                                          }
                                                        } else {
                                                          peg$currPos = s0;
                                                          s0 = peg$FAILED;
                                                        }
                                                      } else {
                                                        peg$currPos = s0;
                                                        s0 = peg$FAILED;
                                                      }
                                                    } else {
                                                      peg$currPos = s0;
                                                      s0 = peg$FAILED;
                                                    }
                                                  } else {
                                                    peg$currPos = s0;
                                                    s0 = peg$FAILED;
                                                  }
                                                } else {
                                                  peg$currPos = s0;
                                                  s0 = peg$FAILED;
                                                }
                                              } else {
                                                peg$currPos = s0;
                                                s0 = peg$FAILED;
                                              }
                                            } else {
                                              peg$currPos = s0;
                                              s0 = peg$FAILED;
                                            }
                                          } else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                          }
                                        } else {
                                          peg$currPos = s0;
                                          s0 = peg$FAILED;
                                        }
                                      } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                      }
                                    } else {
                                      peg$currPos = s0;
                                      s0 = peg$FAILED;
                                    }
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "create_constraint_trigger",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_constraint_trigger",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsetrigger_event() {
    var s0, s1, s2, s3, s4, s5, s6,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "trigger_event",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_INSERT();
    if (s1 === peg$FAILED) {
      s1 = peg$parseKW_DELETE();
      if (s1 === peg$FAILED) {
        s1 = peg$parseKW_TRUNCATE();
      }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c161(s1);
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseKW_UPDATE();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          if (input.substr(peg$currPos, 2).toLowerCase() === peg$c162) {
            s4 = input.substr(peg$currPos, 2);
            peg$currPos += 2;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c163); }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parse__();
            if (s5 !== peg$FAILED) {
              s6 = peg$parsecolumn_ref_list();
              if (s6 !== peg$FAILED) {
                s4 = [s4, s5, s6];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c164(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "trigger_event",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "trigger_event",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsetrigger_event_list() {
    var s0, s1, s2, s3, s4, s5, s6, s7,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "trigger_event_list",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parsetrigger_event();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse__();
      if (s4 !== peg$FAILED) {
        s5 = peg$parseKW_OR();
        if (s5 !== peg$FAILED) {
          s6 = peg$parse__();
          if (s6 !== peg$FAILED) {
            s7 = peg$parsetrigger_event();
            if (s7 !== peg$FAILED) {
              s4 = [s4, s5, s6, s7];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseKW_OR();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s7 = peg$parsetrigger_event();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c165(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "trigger_event_list",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "trigger_event_list",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsetrigger_deferrable() {
    var s0, s1, s2, s3, s4,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "trigger_deferrable",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$currPos;
    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c166) {
      s2 = input.substr(peg$currPos, 3);
      peg$currPos += 3;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c167); }
    }
    if (s2 === peg$FAILED) {
      s2 = null;
    }
    if (s2 !== peg$FAILED) {
      s3 = peg$parse__();
      if (s3 !== peg$FAILED) {
        if (input.substr(peg$currPos, 10).toLowerCase() === peg$c168) {
          s4 = input.substr(peg$currPos, 10);
          peg$currPos += 10;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c169); }
        }
        if (s4 !== peg$FAILED) {
          s2 = [s2, s3, s4];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        if (input.substr(peg$currPos, 19).toLowerCase() === peg$c170) {
          s3 = input.substr(peg$currPos, 19);
          peg$currPos += 19;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c171); }
        }
        if (s3 === peg$FAILED) {
          if (input.substr(peg$currPos, 18).toLowerCase() === peg$c172) {
            s3 = input.substr(peg$currPos, 18);
            peg$currPos += 18;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c173); }
          }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c174(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "trigger_deferrable",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "trigger_deferrable",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsetrigger_for_row() {
    var s0, s1, s2, s3, s4, s5,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "trigger_for_row",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c175) {
      s1 = input.substr(peg$currPos, 3);
      peg$currPos += 3;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c176); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        if (input.substr(peg$currPos, 4).toLowerCase() === peg$c177) {
          s3 = input.substr(peg$currPos, 4);
          peg$currPos += 4;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c178); }
        }
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            if (input.substr(peg$currPos, 3).toLowerCase() === peg$c179) {
              s5 = input.substr(peg$currPos, 3);
              peg$currPos += 3;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c180); }
            }
            if (s5 === peg$FAILED) {
              if (input.substr(peg$currPos, 9).toLowerCase() === peg$c181) {
                s5 = input.substr(peg$currPos, 9);
                peg$currPos += 9;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c182); }
              }
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c183(s1, s3, s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "trigger_for_row",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "trigger_for_row",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsetrigger_when() {
    var s0, s1, s2, s3, s4, s5, s6, s7,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "trigger_when",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_WHEN();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseLPAREN();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseexpr();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseRPAREN();
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c184(s5);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "trigger_when",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "trigger_when",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsetable_options() {
    var s0, s1, s2, s3, s4, s5, s6, s7,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "table_options",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parsetable_option();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse__();
      if (s4 !== peg$FAILED) {
        s5 = peg$parseCOMMA();
        if (s5 === peg$FAILED) {
          s5 = null;
        }
        if (s5 !== peg$FAILED) {
          s6 = peg$parse__();
          if (s6 !== peg$FAILED) {
            s7 = peg$parsetable_option();
            if (s7 !== peg$FAILED) {
              s4 = [s4, s5, s6, s7];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseCOMMA();
          if (s5 === peg$FAILED) {
            s5 = null;
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s7 = peg$parsetable_option();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c185(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "table_options",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "table_options",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecreate_option_character_set_kw() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "create_option_character_set_kw",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 9).toLowerCase() === peg$c186) {
      s1 = input.substr(peg$currPos, 9);
      peg$currPos += 9;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c187); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        if (input.substr(peg$currPos, 3).toLowerCase() === peg$c188) {
          s3 = input.substr(peg$currPos, 3);
          peg$currPos += 3;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c189); }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c190();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "create_option_character_set_kw",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_option_character_set_kw",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecreate_option_character_set() {
    var s0, s1, s2, s3, s4, s5, s6, s7,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "create_option_character_set",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_DEFAULT();
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parsecreate_option_character_set_kw();
        if (s3 === peg$FAILED) {
          if (input.substr(peg$currPos, 7).toLowerCase() === peg$c191) {
            s3 = input.substr(peg$currPos, 7);
            peg$currPos += 7;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c192); }
          }
          if (s3 === peg$FAILED) {
            if (input.substr(peg$currPos, 7).toLowerCase() === peg$c193) {
              s3 = input.substr(peg$currPos, 7);
              peg$currPos += 7;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c194); }
            }
          }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseKW_ASSIGIN_EQUAL();
            if (s5 === peg$FAILED) {
              s5 = null;
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseident_name();
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c195(s1, s3, s5, s7);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "create_option_character_set",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "create_option_character_set",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsetable_option() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "table_option",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 14).toLowerCase() === peg$c57) {
      s1 = input.substr(peg$currPos, 14);
      peg$currPos += 14;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c58); }
    }
    if (s1 === peg$FAILED) {
      if (input.substr(peg$currPos, 14).toLowerCase() === peg$c196) {
        s1 = input.substr(peg$currPos, 14);
        peg$currPos += 14;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c197); }
      }
      if (s1 === peg$FAILED) {
        if (input.substr(peg$currPos, 14).toLowerCase() === peg$c198) {
          s1 = input.substr(peg$currPos, 14);
          peg$currPos += 14;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c199); }
        }
        if (s1 === peg$FAILED) {
          if (input.substr(peg$currPos, 8).toLowerCase() === peg$c200) {
            s1 = input.substr(peg$currPos, 8);
            peg$currPos += 8;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c201); }
          }
          if (s1 === peg$FAILED) {
            if (input.substr(peg$currPos, 8).toLowerCase() === peg$c202) {
              s1 = input.substr(peg$currPos, 8);
              peg$currPos += 8;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c203); }
            }
            if (s1 === peg$FAILED) {
              if (input.substr(peg$currPos, 18).toLowerCase() === peg$c204) {
                s1 = input.substr(peg$currPos, 18);
                peg$currPos += 18;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c205); }
              }
            }
          }
        }
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseKW_ASSIGIN_EQUAL();
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseliteral_numeric();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c206(s1, s3, s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parsecreate_option_character_set();
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseKW_COMMENT();
        if (s1 === peg$FAILED) {
          if (input.substr(peg$currPos, 10).toLowerCase() === peg$c207) {
            s1 = input.substr(peg$currPos, 10);
            peg$currPos += 10;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c208); }
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse__();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseKW_ASSIGIN_EQUAL();
            if (s3 === peg$FAILED) {
              s3 = null;
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$parse__();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseliteral_string();
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c209(s1, s3, s5);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 11).toLowerCase() === peg$c210) {
            s1 = input.substr(peg$currPos, 11);
            peg$currPos += 11;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c211); }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parse__();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseKW_ASSIGIN_EQUAL();
              if (s3 === peg$FAILED) {
                s3 = null;
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$parse__();
                if (s4 !== peg$FAILED) {
                  s5 = peg$currPos;
                  if (input.charCodeAt(peg$currPos) === 39) {
                    s6 = peg$c212;
                    peg$currPos++;
                  } else {
                    s6 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c213); }
                  }
                  if (s6 !== peg$FAILED) {
                    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c214) {
                      s7 = input.substr(peg$currPos, 4);
                      peg$currPos += 4;
                    } else {
                      s7 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c215); }
                    }
                    if (s7 === peg$FAILED) {
                      if (input.substr(peg$currPos, 3).toLowerCase() === peg$c216) {
                        s7 = input.substr(peg$currPos, 3);
                        peg$currPos += 3;
                      } else {
                        s7 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c217); }
                      }
                      if (s7 === peg$FAILED) {
                        if (input.substr(peg$currPos, 4).toLowerCase() === peg$c40) {
                          s7 = input.substr(peg$currPos, 4);
                          peg$currPos += 4;
                        } else {
                          s7 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c41); }
                        }
                      }
                    }
                    if (s7 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 39) {
                        s8 = peg$c212;
                        peg$currPos++;
                      } else {
                        s8 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c213); }
                      }
                      if (s8 !== peg$FAILED) {
                        s6 = [s6, s7, s8];
                        s5 = s6;
                      } else {
                        peg$currPos = s5;
                        s5 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s5;
                      s5 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c218(s1, s3, s5);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 6).toLowerCase() === peg$c219) {
              s1 = input.substr(peg$currPos, 6);
              peg$currPos += 6;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c220); }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parse__();
              if (s2 !== peg$FAILED) {
                s3 = peg$parseKW_ASSIGIN_EQUAL();
                if (s3 === peg$FAILED) {
                  s3 = null;
                }
                if (s3 !== peg$FAILED) {
                  s4 = peg$parse__();
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parseident_name();
                    if (s5 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c221(s1, s3, s5);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
        }
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "table_option",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "table_option",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseALTER_ADD_FULLETXT_SPARITAL_INDEX() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "ALTER_ADD_FULLETXT_SPARITAL_INDEX",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_ADD();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parsecreate_fulltext_spatial_index_definition();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c222(s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "ALTER_ADD_FULLETXT_SPARITAL_INDEX",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "ALTER_ADD_FULLETXT_SPARITAL_INDEX",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parserename_stmt() {
    var s0, s1, s2, s3, s4, s5,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "rename_stmt",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_RENAME();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseKW_TABLE();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parsetable_to_list();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c223(s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "rename_stmt",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "rename_stmt",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseset_stmt() {
    var s0, s1, s2, s3, s4, s5,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "set_stmt",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_SET();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseKW_GLOBAL();
        if (s3 === peg$FAILED) {
          s3 = peg$parseKW_SESSION();
          if (s3 === peg$FAILED) {
            s3 = peg$parseKW_LOCAL();
            if (s3 === peg$FAILED) {
              s3 = peg$parseKW_PERSIST();
              if (s3 === peg$FAILED) {
                s3 = peg$parseKW_PERSIST_ONLY();
              }
            }
          }
        }
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseassign_stmt();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c224(s3, s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "set_stmt",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "set_stmt",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parselock_mode() {
    var s0, s1, s2, s3, s4, s5,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "lock_mode",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2).toLowerCase() === peg$c225) {
      s1 = input.substr(peg$currPos, 2);
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c226); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        if (input.substr(peg$currPos, 12).toLowerCase() === peg$c227) {
          s3 = input.substr(peg$currPos, 12);
          peg$currPos += 12;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c228); }
        }
        if (s3 === peg$FAILED) {
          if (input.substr(peg$currPos, 9).toLowerCase() === peg$c229) {
            s3 = input.substr(peg$currPos, 9);
            peg$currPos += 9;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c230); }
          }
          if (s3 === peg$FAILED) {
            if (input.substr(peg$currPos, 13).toLowerCase() === peg$c231) {
              s3 = input.substr(peg$currPos, 13);
              peg$currPos += 13;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c232); }
            }
            if (s3 === peg$FAILED) {
              if (input.substr(peg$currPos, 22).toLowerCase() === peg$c233) {
                s3 = input.substr(peg$currPos, 22);
                peg$currPos += 22;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c234); }
              }
              if (s3 === peg$FAILED) {
                if (input.substr(peg$currPos, 19).toLowerCase() === peg$c235) {
                  s3 = input.substr(peg$currPos, 19);
                  peg$currPos += 19;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c236); }
                }
                if (s3 === peg$FAILED) {
                  if (input.substr(peg$currPos, 9).toLowerCase() === peg$c110) {
                    s3 = input.substr(peg$currPos, 9);
                    peg$currPos += 9;
                  } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c111); }
                  }
                  if (s3 === peg$FAILED) {
                    if (input.substr(peg$currPos, 16).toLowerCase() === peg$c237) {
                      s3 = input.substr(peg$currPos, 16);
                      peg$currPos += 16;
                    } else {
                      s3 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c238); }
                    }
                    if (s3 === peg$FAILED) {
                      if (input.substr(peg$currPos, 5).toLowerCase() === peg$c239) {
                        s3 = input.substr(peg$currPos, 5);
                        peg$currPos += 5;
                      } else {
                        s3 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c240); }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            if (input.substr(peg$currPos, 4).toLowerCase() === peg$c241) {
              s5 = input.substr(peg$currPos, 4);
              peg$currPos += 4;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c242); }
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c243(s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "lock_mode",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "lock_mode",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parselock_stmt() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "lock_stmt",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_LOCK();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseKW_TABLE();
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parsetable_ref_list();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parselock_mode();
                if (s7 === peg$FAILED) {
                  s7 = null;
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse__();
                  if (s8 !== peg$FAILED) {
                    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c244) {
                      s9 = input.substr(peg$currPos, 6);
                      peg$currPos += 6;
                    } else {
                      s9 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c245); }
                    }
                    if (s9 === peg$FAILED) {
                      s9 = null;
                    }
                    if (s9 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c246(s3, s5, s7, s9);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "lock_stmt",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "lock_stmt",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecall_stmt() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "call_stmt",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_CALL();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseproc_func_call();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c247(s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "call_stmt",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "call_stmt",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseselect_stmt() {
    var s0, s1, s2, s3, s4, s5, s6,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "select_stmt",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$parseselect_stmt_nake();
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 40) {
        s2 = peg$c248;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c249); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse__();
        if (s3 !== peg$FAILED) {
          s4 = peg$parseselect_stmt();
          if (s4 !== peg$FAILED) {
            s5 = peg$parse__();
            if (s5 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 41) {
                s6 = peg$c250;
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c251); }
              }
              if (s6 !== peg$FAILED) {
                s2 = [s2, s3, s4, s5, s6];
                s1 = s2;
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c252(s1);
      }
      s0 = s1;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "select_stmt",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "select_stmt",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsewith_clause() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "with_clause",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_WITH();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parsecte_definition();
        if (s3 !== peg$FAILED) {
          s4 = [];
          s5 = peg$currPos;
          s6 = peg$parse__();
          if (s6 !== peg$FAILED) {
            s7 = peg$parseCOMMA();
            if (s7 !== peg$FAILED) {
              s8 = peg$parse__();
              if (s8 !== peg$FAILED) {
                s9 = peg$parsecte_definition();
                if (s9 !== peg$FAILED) {
                  s6 = [s6, s7, s8, s9];
                  s5 = s6;
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$currPos;
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseCOMMA();
              if (s7 !== peg$FAILED) {
                s8 = peg$parse__();
                if (s8 !== peg$FAILED) {
                  s9 = peg$parsecte_definition();
                  if (s9 !== peg$FAILED) {
                    s6 = [s6, s7, s8, s9];
                    s5 = s6;
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
          }
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c253(s3, s4);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parse__();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseKW_WITH();
        if (s2 !== peg$FAILED) {
          s3 = peg$parse__();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseKW_RECURSIVE();
            if (s4 !== peg$FAILED) {
              s5 = peg$parse__();
              if (s5 !== peg$FAILED) {
                s6 = peg$parsecte_definition();
                if (s6 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c254(s6);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "with_clause",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "with_clause",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecte_definition() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "cte_definition",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseident_name();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parsecte_column_definition();
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseKW_AS();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseLPAREN();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse__();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parseset_operator_stmt();
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parse__();
                      if (s10 !== peg$FAILED) {
                        s11 = peg$parseRPAREN();
                        if (s11 !== peg$FAILED) {
                          peg$savedPos = s0;
                          s1 = peg$c255(s1, s3, s9);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "cte_definition",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "cte_definition",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecte_column_definition() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "cte_column_definition",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseLPAREN();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parsecolumn();
        if (s3 !== peg$FAILED) {
          s4 = [];
          s5 = peg$currPos;
          s6 = peg$parse__();
          if (s6 !== peg$FAILED) {
            s7 = peg$parseCOMMA();
            if (s7 !== peg$FAILED) {
              s8 = peg$parse__();
              if (s8 !== peg$FAILED) {
                s9 = peg$parsecolumn();
                if (s9 !== peg$FAILED) {
                  s6 = [s6, s7, s8, s9];
                  s5 = s6;
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$currPos;
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseCOMMA();
              if (s7 !== peg$FAILED) {
                s8 = peg$parse__();
                if (s8 !== peg$FAILED) {
                  s9 = peg$parsecolumn();
                  if (s9 !== peg$FAILED) {
                    s6 = [s6, s7, s8, s9];
                    s5 = s6;
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parse__();
            if (s5 !== peg$FAILED) {
              s6 = peg$parseRPAREN();
              if (s6 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c256(s3, s4);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "cte_column_definition",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "cte_column_definition",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseselect_stmt_nake() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17, s18, s19, s20, s21, s22,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "select_stmt_nake",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parse__();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsewith_clause();
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse__();
        if (s3 !== peg$FAILED) {
          s4 = peg$parseKW_SELECT();
          if (s4 !== peg$FAILED) {
            s5 = peg$parse___();
            if (s5 !== peg$FAILED) {
              s6 = peg$parseoption_clause();
              if (s6 === peg$FAILED) {
                s6 = null;
              }
              if (s6 !== peg$FAILED) {
                s7 = peg$parse__();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parseKW_DISTINCT();
                  if (s8 === peg$FAILED) {
                    s8 = null;
                  }
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parse__();
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parsecolumn_clause();
                      if (s10 !== peg$FAILED) {
                        s11 = peg$parse__();
                        if (s11 !== peg$FAILED) {
                          s12 = peg$parsefrom_clause();
                          if (s12 === peg$FAILED) {
                            s12 = null;
                          }
                          if (s12 !== peg$FAILED) {
                            s13 = peg$parse__();
                            if (s13 !== peg$FAILED) {
                              s14 = peg$parsewhere_clause();
                              if (s14 === peg$FAILED) {
                                s14 = null;
                              }
                              if (s14 !== peg$FAILED) {
                                s15 = peg$parse__();
                                if (s15 !== peg$FAILED) {
                                  s16 = peg$parsegroup_by_clause();
                                  if (s16 === peg$FAILED) {
                                    s16 = null;
                                  }
                                  if (s16 !== peg$FAILED) {
                                    s17 = peg$parse__();
                                    if (s17 !== peg$FAILED) {
                                      s18 = peg$parsehaving_clause();
                                      if (s18 === peg$FAILED) {
                                        s18 = null;
                                      }
                                      if (s18 !== peg$FAILED) {
                                        s19 = peg$parse__();
                                        if (s19 !== peg$FAILED) {
                                          s20 = peg$parseorder_by_clause();
                                          if (s20 === peg$FAILED) {
                                            s20 = null;
                                          }
                                          if (s20 !== peg$FAILED) {
                                            s21 = peg$parse__();
                                            if (s21 !== peg$FAILED) {
                                              s22 = peg$parselimit_clause();
                                              if (s22 === peg$FAILED) {
                                                s22 = null;
                                              }
                                              if (s22 !== peg$FAILED) {
                                                peg$savedPos = s0;
                                                s1 = peg$c257(s2, s6, s8, s10, s12, s14, s16, s18, s20, s22);
                                                s0 = s1;
                                              } else {
                                                peg$currPos = s0;
                                                s0 = peg$FAILED;
                                              }
                                            } else {
                                              peg$currPos = s0;
                                              s0 = peg$FAILED;
                                            }
                                          } else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                          }
                                        } else {
                                          peg$currPos = s0;
                                          s0 = peg$FAILED;
                                        }
                                      } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                      }
                                    } else {
                                      peg$currPos = s0;
                                      s0 = peg$FAILED;
                                    }
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "select_stmt_nake",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "select_stmt_nake",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseoption_clause() {
    var s0, s1, s2, s3, s4, s5,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "option_clause",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parsequery_option();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse__();
      if (s4 !== peg$FAILED) {
        s5 = peg$parsequery_option();
        if (s5 !== peg$FAILED) {
          s4 = [s4, s5];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s5 = peg$parsequery_option();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c258(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "option_clause",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "option_clause",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsequery_option() {
    var s0, s1,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "query_option",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseOPT_SQL_CALC_FOUND_ROWS();
    if (s1 === peg$FAILED) {
      s1 = peg$parseOPT_SQL_CACHE();
      if (s1 === peg$FAILED) {
        s1 = peg$parseOPT_SQL_NO_CACHE();
      }
      if (s1 === peg$FAILED) {
        s1 = peg$parseOPT_SQL_BIG_RESULT();
        if (s1 === peg$FAILED) {
          s1 = peg$parseOPT_SQL_SMALL_RESULT();
          if (s1 === peg$FAILED) {
            s1 = peg$parseOPT_SQL_BUFFER_RESULT();
          }
        }
      }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c259(s1);
    }
    s0 = s1;

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "query_option",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "query_option",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecolumn_clause() {
    var s0, s1, s2, s3, s4, s5, s6, s7,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "column_clause",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_ALL();
    if (s1 === peg$FAILED) {
      s1 = peg$currPos;
      s2 = peg$parseSTAR();
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parseident_start();
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = void 0;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 === peg$FAILED) {
        s1 = peg$parseSTAR();
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse__();
      if (s4 !== peg$FAILED) {
        s5 = peg$parseCOMMA();
        if (s5 !== peg$FAILED) {
          s6 = peg$parse__();
          if (s6 !== peg$FAILED) {
            s7 = peg$parsecolumn_list_item();
            if (s7 !== peg$FAILED) {
              s4 = [s4, s5, s6, s7];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseCOMMA();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s7 = peg$parsecolumn_list_item();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c260(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parsecolumn_list_item();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseCOMMA();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s7 = peg$parsecolumn_list_item();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseCOMMA();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parsecolumn_list_item();
                if (s7 !== peg$FAILED) {
                  s4 = [s4, s5, s6, s7];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c261(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "column_clause",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "column_clause",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecolumn_list_item() {
    var s0, s1, s2, s3, s4, s5,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "column_list_item",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseexpr();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseKW_DOUBLE_COLON();
      if (s2 !== peg$FAILED) {
        s3 = peg$parsedata_type();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parsealias_clause();
            if (s5 === peg$FAILED) {
              s5 = null;
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c262(s1, s2, s3, s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseident();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseDOT();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse__();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseSTAR();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c263(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseexpr();
        if (s1 !== peg$FAILED) {
          s2 = peg$parse__();
          if (s2 !== peg$FAILED) {
            s3 = peg$parsealias_clause();
            if (s3 === peg$FAILED) {
              s3 = null;
            }
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c264(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "column_list_item",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "column_list_item",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsealias_clause() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "alias_clause",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_AS();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parsealias_ident();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c265(s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseKW_AS();
      if (s1 === peg$FAILED) {
        s1 = null;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseident();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c266(s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "alias_clause",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "alias_clause",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsefrom_clause() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "from_clause",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_FROM();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parsetable_ref_list();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c267(s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "from_clause",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "from_clause",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsetable_to_list() {
    var s0, s1, s2, s3, s4, s5, s6, s7,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "table_to_list",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parsetable_to_item();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse__();
      if (s4 !== peg$FAILED) {
        s5 = peg$parseCOMMA();
        if (s5 !== peg$FAILED) {
          s6 = peg$parse__();
          if (s6 !== peg$FAILED) {
            s7 = peg$parsetable_to_item();
            if (s7 !== peg$FAILED) {
              s4 = [s4, s5, s6, s7];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseCOMMA();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s7 = peg$parsetable_to_item();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c268(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "table_to_list",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "table_to_list",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsetable_to_item() {
    var s0, s1, s2, s3, s4, s5,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "table_to_item",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parsetable_name();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseKW_TO();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parsetable_name();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c269(s1, s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "table_to_item",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "table_to_item",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseindex_type() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "index_type",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_USING();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        if (input.substr(peg$currPos, 5).toLowerCase() === peg$c270) {
          s3 = input.substr(peg$currPos, 5);
          peg$currPos += 5;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c271); }
        }
        if (s3 === peg$FAILED) {
          if (input.substr(peg$currPos, 4).toLowerCase() === peg$c272) {
            s3 = input.substr(peg$currPos, 4);
            peg$currPos += 4;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c273); }
          }
          if (s3 === peg$FAILED) {
            if (input.substr(peg$currPos, 4).toLowerCase() === peg$c274) {
              s3 = input.substr(peg$currPos, 4);
              peg$currPos += 4;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c275); }
            }
            if (s3 === peg$FAILED) {
              if (input.substr(peg$currPos, 3).toLowerCase() === peg$c276) {
                s3 = input.substr(peg$currPos, 3);
                peg$currPos += 3;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c277); }
              }
            }
          }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c278(s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "index_type",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "index_type",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseindex_options_list() {
    var s0, s1, s2, s3, s4, s5, s6, s7,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "index_options_list",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseindex_option();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse__();
      if (s4 !== peg$FAILED) {
        s5 = peg$parseCOMMA();
        if (s5 !== peg$FAILED) {
          s6 = peg$parse__();
          if (s6 !== peg$FAILED) {
            s7 = peg$parseindex_option();
            if (s7 !== peg$FAILED) {
              s4 = [s4, s5, s6, s7];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseCOMMA();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseindex_option();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c279(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "index_options_list",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "index_options_list",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseindex_options() {
    var s0, s1, s2, s3, s4, s5,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "index_options",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseindex_option();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse__();
      if (s4 !== peg$FAILED) {
        s5 = peg$parseindex_option();
        if (s5 !== peg$FAILED) {
          s4 = [s4, s5];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseindex_option();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c280(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "index_options",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "index_options",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseindex_option() {
    var s0, s1, s2, s3, s4, s5,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "index_option",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_KEY_BLOCK_SIZE();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseKW_ASSIGIN_EQUAL();
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseliteral_numeric();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c281(s1, s3, s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseident_name();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseKW_ASSIGIN_EQUAL();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse__();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseliteral_numeric();
              if (s5 === peg$FAILED) {
                s5 = peg$parseident();
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c282(s1, s3, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parseindex_type();
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4).toLowerCase() === peg$c283) {
            s1 = input.substr(peg$currPos, 4);
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c284); }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parse__();
            if (s2 !== peg$FAILED) {
              if (input.substr(peg$currPos, 6).toLowerCase() === peg$c285) {
                s3 = input.substr(peg$currPos, 6);
                peg$currPos += 6;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c286); }
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$parse__();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseident_name();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c287(s5);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 7).toLowerCase() === peg$c288) {
              s1 = input.substr(peg$currPos, 7);
              peg$currPos += 7;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c289); }
            }
            if (s1 === peg$FAILED) {
              if (input.substr(peg$currPos, 9).toLowerCase() === peg$c290) {
                s1 = input.substr(peg$currPos, 9);
                peg$currPos += 9;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c291); }
              }
            }
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c292(s1);
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$parsekeyword_comment();
            }
          }
        }
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "index_option",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "index_option",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsetable_ref_list() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "table_ref_list",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parsetable_base();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parsetable_ref();
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parsetable_ref();
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c293(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "table_ref_list",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "table_ref_list",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsetable_ref() {
    var s0, s1, s2, s3, s4,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "table_ref",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parse__();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseCOMMA();
      if (s2 !== peg$FAILED) {
        s3 = peg$parse__();
        if (s3 !== peg$FAILED) {
          s4 = peg$parsetable_base();
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c294(s4);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parse__();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsetable_join();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c295(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "table_ref",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "table_ref",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsetable_join() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "table_join",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parsejoin_op();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parsetable_base();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseKW_USING();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseLPAREN();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse__();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parseident_name();
                    if (s9 !== peg$FAILED) {
                      s10 = [];
                      s11 = peg$currPos;
                      s12 = peg$parse__();
                      if (s12 !== peg$FAILED) {
                        s13 = peg$parseCOMMA();
                        if (s13 !== peg$FAILED) {
                          s14 = peg$parse__();
                          if (s14 !== peg$FAILED) {
                            s15 = peg$parseident_name();
                            if (s15 !== peg$FAILED) {
                              s12 = [s12, s13, s14, s15];
                              s11 = s12;
                            } else {
                              peg$currPos = s11;
                              s11 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s11;
                            s11 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s11;
                          s11 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s11;
                        s11 = peg$FAILED;
                      }
                      while (s11 !== peg$FAILED) {
                        s10.push(s11);
                        s11 = peg$currPos;
                        s12 = peg$parse__();
                        if (s12 !== peg$FAILED) {
                          s13 = peg$parseCOMMA();
                          if (s13 !== peg$FAILED) {
                            s14 = peg$parse__();
                            if (s14 !== peg$FAILED) {
                              s15 = peg$parseident_name();
                              if (s15 !== peg$FAILED) {
                                s12 = [s12, s13, s14, s15];
                                s11 = s12;
                              } else {
                                peg$currPos = s11;
                                s11 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s11;
                              s11 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s11;
                            s11 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s11;
                          s11 = peg$FAILED;
                        }
                      }
                      if (s10 !== peg$FAILED) {
                        s11 = peg$parse__();
                        if (s11 !== peg$FAILED) {
                          s12 = peg$parseRPAREN();
                          if (s12 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c296(s1, s3, s9, s10);
                            s0 = s1;
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parsejoin_op();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsetable_base();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse__();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseon_clause();
              if (s5 === peg$FAILED) {
                s5 = null;
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c297(s1, s3, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsejoin_op();
        if (s1 !== peg$FAILED) {
          s2 = peg$parse__();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseLPAREN();
            if (s3 !== peg$FAILED) {
              s4 = peg$parse__();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseset_operator_stmt();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parse__();
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parseRPAREN();
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parse__();
                      if (s8 !== peg$FAILED) {
                        s9 = peg$parsealias_clause();
                        if (s9 === peg$FAILED) {
                          s9 = null;
                        }
                        if (s9 !== peg$FAILED) {
                          s10 = peg$parse__();
                          if (s10 !== peg$FAILED) {
                            s11 = peg$parseon_clause();
                            if (s11 === peg$FAILED) {
                              s11 = null;
                            }
                            if (s11 !== peg$FAILED) {
                              peg$savedPos = s0;
                              s1 = peg$c298(s1, s5, s9, s11);
                              s0 = s1;
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "table_join",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "table_join",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsetable_base() {
    var s0, s1, s2, s3, s4, s5, s6, s7,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "table_base",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_DUAL();
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c299();
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parsetable_name();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsealias_clause();
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c300(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseLPAREN();
        if (s1 !== peg$FAILED) {
          s2 = peg$parse__();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseset_operator_stmt();
            if (s3 !== peg$FAILED) {
              s4 = peg$parse__();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseRPAREN();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parse__();
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parsealias_clause();
                    if (s7 === peg$FAILED) {
                      s7 = null;
                    }
                    if (s7 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c301(s3, s7);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "table_base",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "table_base",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsejoin_op() {
    var s0, s1, s2, s3, s4, s5,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "join_op",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_LEFT();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseKW_OUTER();
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseKW_JOIN();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c302();
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseKW_RIGHT();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseKW_OUTER();
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse__();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseKW_JOIN();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c303();
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseKW_FULL();
        if (s1 !== peg$FAILED) {
          s2 = peg$parse__();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseKW_OUTER();
            if (s3 === peg$FAILED) {
              s3 = null;
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$parse__();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseKW_JOIN();
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c304();
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseKW_CROSS();
          if (s1 !== peg$FAILED) {
            s2 = peg$parse__();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseKW_JOIN();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c305();
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseKW_NATURAL();
            if (s1 !== peg$FAILED) {
              s2 = peg$parse__();
              if (s2 !== peg$FAILED) {
                s3 = peg$parseKW_JOIN();
                if (s3 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c306();
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parseKW_FULL();
              if (s1 !== peg$FAILED) {
                s2 = peg$parse__();
                if (s2 !== peg$FAILED) {
                  s3 = peg$parseKW_OUTER();
                  if (s3 === peg$FAILED) {
                    s3 = null;
                  }
                  if (s3 !== peg$FAILED) {
                    s4 = peg$parse__();
                    if (s4 !== peg$FAILED) {
                      s5 = peg$parseKW_JOIN();
                      if (s5 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c304();
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$currPos;
                s2 = peg$parseKW_INNER();
                if (s2 !== peg$FAILED) {
                  s3 = peg$parse__();
                  if (s3 !== peg$FAILED) {
                    s2 = [s2, s3];
                    s1 = s2;
                  } else {
                    peg$currPos = s1;
                    s1 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
                if (s1 === peg$FAILED) {
                  s1 = null;
                }
                if (s1 !== peg$FAILED) {
                  s2 = peg$parseKW_JOIN();
                  if (s2 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c307();
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              }
            }
          }
        }
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "join_op",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "join_op",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsetable_name() {
    var s0, s1, s2, s3, s4, s5, s6, s7,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "table_name",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseident();
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      s3 = peg$parse__();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseDOT();
        if (s4 !== peg$FAILED) {
          s5 = peg$parse__();
          if (s5 !== peg$FAILED) {
            s6 = peg$parseident();
            if (s6 !== peg$FAILED) {
              s3 = [s3, s4, s5, s6];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseDOT();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseident();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c308(s1, s2, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseident();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseDOT();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse__();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseSTAR();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c309(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseident();
        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          s3 = peg$parse__();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseDOT();
            if (s4 !== peg$FAILED) {
              s5 = peg$parse__();
              if (s5 !== peg$FAILED) {
                s6 = peg$parseident();
                if (s6 !== peg$FAILED) {
                  s3 = [s3, s4, s5, s6];
                  s2 = s3;
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
          if (s2 === peg$FAILED) {
            s2 = null;
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c310(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsevar_decl();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c311(s1);
          }
          s0 = s1;
        }
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "table_name",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "table_name",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseon_clause() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "on_clause",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_ON();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseexpr();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c312(s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "on_clause",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "on_clause",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsewhere_clause() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "where_clause",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_WHERE();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseor_and_where_expr();
        if (s3 === peg$FAILED) {
          s3 = peg$parseexpr();
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c312(s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "where_clause",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "where_clause",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsegroup_by_clause() {
    var s0, s1, s2, s3, s4, s5,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "group_by_clause",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_GROUP();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseKW_BY();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parsegroupby_expr_list();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c313(s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "group_by_clause",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "group_by_clause",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsegroupby_expr_list() {
    var s0, s1, s2, s3, s4, s5, s6, s7,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "groupby_expr_list",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parsegroup_by_expr();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse__();
      if (s4 !== peg$FAILED) {
        s5 = peg$parseCOMMA();
        if (s5 !== peg$FAILED) {
          s6 = peg$parse__();
          if (s6 !== peg$FAILED) {
            s7 = peg$parsegroup_by_expr();
            if (s7 !== peg$FAILED) {
              s4 = [s4, s5, s6, s7];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseCOMMA();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s7 = peg$parsegroup_by_expr();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c314(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "groupby_expr_list",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "groupby_expr_list",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsegroup_by_expr() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "group_by_expr",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$parsegroup_by_func_call();
    if (s0 === peg$FAILED) {
      s0 = peg$parselogic_operator_expr();
      if (s0 === peg$FAILED) {
        s0 = peg$parseunary_expr();
        if (s0 === peg$FAILED) {
          s0 = peg$parseor_expr();
          if (s0 === peg$FAILED) {
            s0 = peg$parseselect_stmt();
          }
        }
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "group_by_expr",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "group_by_expr",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsegroup_by_func_call() {
    var s0, s1, s2, s3, s4, s5, s6, s7,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "group_by_func_call",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parsegroup_by_func_name();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseLPAREN();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseexpr_list();
            if (s5 === peg$FAILED) {
              s5 = null;
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseRPAREN();
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c315(s1, s5);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "group_by_func_call",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "group_by_func_call",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsegroup_by_func_name() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "group_by_func_name",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$parseKW_CUBE();
    if (s0 === peg$FAILED) {
      s0 = peg$parseKW_ROLLUP();
      if (s0 === peg$FAILED) {
        s0 = peg$parsegrouping_sets();
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "group_by_func_name",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "group_by_func_name",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsegrouping_sets() {
    var s0, s1, s2, s3, s4,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "grouping_sets",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parseKW_GROUPING();
    if (s2 !== peg$FAILED) {
      s3 = peg$parse___();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseKW_SETS();
        if (s4 !== peg$FAILED) {
          s2 = [s2, s3, s4];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c316();
    }
    s0 = s1;

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "grouping_sets",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "grouping_sets",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecolumn_ref_list() {
    var s0, s1, s2, s3, s4, s5, s6, s7,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "column_ref_list",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parsecolumn_ref();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse__();
      if (s4 !== peg$FAILED) {
        s5 = peg$parseCOMMA();
        if (s5 !== peg$FAILED) {
          s6 = peg$parse__();
          if (s6 !== peg$FAILED) {
            s7 = peg$parsecolumn_ref();
            if (s7 !== peg$FAILED) {
              s4 = [s4, s5, s6, s7];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseCOMMA();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s7 = peg$parsecolumn_ref();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c317(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "column_ref_list",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "column_ref_list",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsehaving_clause() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "having_clause",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_HAVING();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseexpr();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c312(s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "having_clause",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "having_clause",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseas_window_specification() {
    var s0, s1, s2, s3, s4, s5,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "as_window_specification",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseLPAREN();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parsewindow_specification();
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseRPAREN();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c318(s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "as_window_specification",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "as_window_specification",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsewindow_specification() {
    var s0, s1, s2, s3, s4, s5,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "window_specification",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parsepartition_by_clause();
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseorder_by_clause();
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parsewindow_frame_clause();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c319(s1, s3, s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "window_specification",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "window_specification",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsewindow_specification_frameless() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "window_specification_frameless",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parsepartition_by_clause();
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseorder_by_clause();
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c320(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "window_specification_frameless",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "window_specification_frameless",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsewindow_frame_clause() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "window_frame_clause",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_ROWS();
    if (s1 === peg$FAILED) {
      s1 = peg$parseKW_RANGE();
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parsewindow_frame_following();
        if (s3 === peg$FAILED) {
          s3 = peg$parsewindow_frame_preceding();
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c321(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseKW_ROWS();
      if (s1 === peg$FAILED) {
        s1 = peg$parseKW_RANGE();
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseKW_BETWEEN();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse__();
            if (s4 !== peg$FAILED) {
              s5 = peg$parsewindow_frame_preceding();
              if (s5 !== peg$FAILED) {
                s6 = peg$parse__();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parseKW_AND();
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parse__();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parsewindow_frame_following();
                      if (s9 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c322(s1, s5, s9);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "window_frame_clause",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "window_frame_clause",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsewindow_frame_following() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "window_frame_following",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parsewindow_frame_value();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        if (input.substr(peg$currPos, 9).toLowerCase() === peg$c323) {
          s3 = input.substr(peg$currPos, 9);
          peg$currPos += 9;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c324); }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c325(s1);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parsewindow_frame_current_row();
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "window_frame_following",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "window_frame_following",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsewindow_frame_preceding() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "window_frame_preceding",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parsewindow_frame_value();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        if (input.substr(peg$currPos, 9).toLowerCase() === peg$c326) {
          s3 = input.substr(peg$currPos, 9);
          peg$currPos += 9;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c327); }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c328(s1);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parsewindow_frame_current_row();
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "window_frame_preceding",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "window_frame_preceding",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsewindow_frame_current_row() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "window_frame_current_row",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c329) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c330); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        if (input.substr(peg$currPos, 3).toLowerCase() === peg$c179) {
          s3 = input.substr(peg$currPos, 3);
          peg$currPos += 3;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c180); }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c331();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "window_frame_current_row",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "window_frame_current_row",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsewindow_frame_value() {
    var s0, s1,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "window_frame_value",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 9).toLowerCase() === peg$c332) {
      s1 = input.substr(peg$currPos, 9);
      peg$currPos += 9;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c333); }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c334(s1);
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      s0 = peg$parseliteral_numeric();
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "window_frame_value",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "window_frame_value",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsepartition_by_clause() {
    var s0, s1, s2, s3, s4, s5,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "partition_by_clause",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_PARTITION();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseKW_BY();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parsecolumn_clause();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c335(s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "partition_by_clause",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "partition_by_clause",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseorder_by_clause() {
    var s0, s1, s2, s3, s4, s5,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "order_by_clause",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_ORDER();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseKW_BY();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseorder_by_list();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c336(s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "order_by_clause",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "order_by_clause",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseorder_by_list() {
    var s0, s1, s2, s3, s4, s5, s6, s7,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "order_by_list",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseorder_by_element();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse__();
      if (s4 !== peg$FAILED) {
        s5 = peg$parseCOMMA();
        if (s5 !== peg$FAILED) {
          s6 = peg$parse__();
          if (s6 !== peg$FAILED) {
            s7 = peg$parseorder_by_element();
            if (s7 !== peg$FAILED) {
              s4 = [s4, s5, s6, s7];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseCOMMA();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseorder_by_element();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c337(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "order_by_list",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "order_by_list",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseorder_by_element() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "order_by_element",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseexpr();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseKW_DESC();
        if (s3 === peg$FAILED) {
          s3 = peg$parseKW_ASC();
        }
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c338(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "order_by_element",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "order_by_element",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsenumber_or_param() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "number_or_param",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$parseliteral_numeric();
    if (s0 === peg$FAILED) {
      s0 = peg$parseparam();
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "number_or_param",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "number_or_param",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parselimit_clause() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "limit_clause",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_LIMIT();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parsenumber_or_param();
        if (s3 === peg$FAILED) {
          s3 = peg$parseKW_ALL();
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$currPos;
            s6 = peg$parseKW_OFFSET();
            if (s6 !== peg$FAILED) {
              s7 = peg$parse__();
              if (s7 !== peg$FAILED) {
                s8 = peg$parsenumber_or_param();
                if (s8 !== peg$FAILED) {
                  s6 = [s6, s7, s8];
                  s5 = s6;
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            if (s5 === peg$FAILED) {
              s5 = null;
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c339(s3, s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "limit_clause",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "limit_clause",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseupdate_stmt() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "update_stmt",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_UPDATE();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parsetable_ref_list();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseKW_SET();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseset_list();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse__();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parsewhere_clause();
                    if (s9 === peg$FAILED) {
                      s9 = null;
                    }
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parse__();
                      if (s10 !== peg$FAILED) {
                        s11 = peg$parsereturning_stmt();
                        if (s11 === peg$FAILED) {
                          s11 = null;
                        }
                        if (s11 !== peg$FAILED) {
                          peg$savedPos = s0;
                          s1 = peg$c340(s3, s7, s9, s11);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "update_stmt",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "update_stmt",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsedelete_stmt() {
    var s0, s1, s2, s3, s4, s5, s6, s7,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "delete_stmt",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_DELETE();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parsetable_ref_list();
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parsefrom_clause();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parsewhere_clause();
                if (s7 === peg$FAILED) {
                  s7 = null;
                }
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c341(s3, s5, s7);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "delete_stmt",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "delete_stmt",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseset_list() {
    var s0, s1, s2, s3, s4, s5, s6, s7,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "set_list",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseset_item();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse__();
      if (s4 !== peg$FAILED) {
        s5 = peg$parseCOMMA();
        if (s5 !== peg$FAILED) {
          s6 = peg$parse__();
          if (s6 !== peg$FAILED) {
            s7 = peg$parseset_item();
            if (s7 !== peg$FAILED) {
              s4 = [s4, s5, s6, s7];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseCOMMA();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseset_item();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c342(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "set_list",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "set_list",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseset_item() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "set_item",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parseident();
    if (s2 !== peg$FAILED) {
      s3 = peg$parse__();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseDOT();
        if (s4 !== peg$FAILED) {
          s2 = [s2, s3, s4];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parsecolumn();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 61) {
              s5 = peg$c343;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c344); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseadditive_expr();
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c345(s1, s3, s7);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$parseident();
      if (s2 !== peg$FAILED) {
        s3 = peg$parse__();
        if (s3 !== peg$FAILED) {
          s4 = peg$parseDOT();
          if (s4 !== peg$FAILED) {
            s2 = [s2, s3, s4];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 === peg$FAILED) {
        s1 = null;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsecolumn();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse__();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 61) {
                s5 = peg$c343;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c344); }
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parse__();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parseKW_VALUES();
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parse__();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parseLPAREN();
                      if (s9 !== peg$FAILED) {
                        s10 = peg$parse__();
                        if (s10 !== peg$FAILED) {
                          s11 = peg$parsecolumn_ref();
                          if (s11 !== peg$FAILED) {
                            s12 = peg$parse__();
                            if (s12 !== peg$FAILED) {
                              s13 = peg$parseRPAREN();
                              if (s13 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s1 = peg$c346(s1, s3, s11);
                                s0 = s1;
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "set_item",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "set_item",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsereturning_stmt() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "returning_stmt",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_RETURNING();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseSTAR();
        if (s3 === peg$FAILED) {
          s3 = peg$parsecolumn_ref_list();
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c347(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "returning_stmt",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "returning_stmt",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseinsert_value_clause() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "insert_value_clause",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$parsevalue_clause();
    if (s0 === peg$FAILED) {
      s0 = peg$parseselect_stmt_nake();
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "insert_value_clause",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "insert_value_clause",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseinsert_partition() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "insert_partition",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_PARTITION();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseLPAREN();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseident_name();
            if (s5 !== peg$FAILED) {
              s6 = [];
              s7 = peg$currPos;
              s8 = peg$parse__();
              if (s8 !== peg$FAILED) {
                s9 = peg$parseCOMMA();
                if (s9 !== peg$FAILED) {
                  s10 = peg$parse__();
                  if (s10 !== peg$FAILED) {
                    s11 = peg$parseident_name();
                    if (s11 !== peg$FAILED) {
                      s8 = [s8, s9, s10, s11];
                      s7 = s8;
                    } else {
                      peg$currPos = s7;
                      s7 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
              } else {
                peg$currPos = s7;
                s7 = peg$FAILED;
              }
              while (s7 !== peg$FAILED) {
                s6.push(s7);
                s7 = peg$currPos;
                s8 = peg$parse__();
                if (s8 !== peg$FAILED) {
                  s9 = peg$parseCOMMA();
                  if (s9 !== peg$FAILED) {
                    s10 = peg$parse__();
                    if (s10 !== peg$FAILED) {
                      s11 = peg$parseident_name();
                      if (s11 !== peg$FAILED) {
                        s8 = [s8, s9, s10, s11];
                        s7 = s8;
                      } else {
                        peg$currPos = s7;
                        s7 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s7;
                      s7 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
              }
              if (s6 !== peg$FAILED) {
                s7 = peg$parse__();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parseRPAREN();
                  if (s8 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c348(s5, s6);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseKW_PARTITION();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsevalue_item();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c349(s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "insert_partition",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "insert_partition",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsereplace_insert_stmt() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "replace_insert_stmt",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parsereplace_insert();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseKW_INTO();
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parsetable_name();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseinsert_partition();
                if (s7 === peg$FAILED) {
                  s7 = null;
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse__();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parseLPAREN();
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parse__();
                      if (s10 !== peg$FAILED) {
                        s11 = peg$parsecolumn_list();
                        if (s11 !== peg$FAILED) {
                          s12 = peg$parse__();
                          if (s12 !== peg$FAILED) {
                            s13 = peg$parseRPAREN();
                            if (s13 !== peg$FAILED) {
                              s14 = peg$parse__();
                              if (s14 !== peg$FAILED) {
                                s15 = peg$parseinsert_value_clause();
                                if (s15 !== peg$FAILED) {
                                  s16 = peg$parse__();
                                  if (s16 !== peg$FAILED) {
                                    s17 = peg$parsereturning_stmt();
                                    if (s17 === peg$FAILED) {
                                      s17 = null;
                                    }
                                    if (s17 !== peg$FAILED) {
                                      peg$savedPos = s0;
                                      s1 = peg$c350(s1, s5, s7, s11, s15, s17);
                                      s0 = s1;
                                    } else {
                                      peg$currPos = s0;
                                      s0 = peg$FAILED;
                                    }
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "replace_insert_stmt",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "replace_insert_stmt",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseinsert_no_columns_stmt() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "insert_no_columns_stmt",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parsereplace_insert();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseKW_INTO();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parsetable_name();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseinsert_partition();
                if (s7 === peg$FAILED) {
                  s7 = null;
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse__();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parseinsert_value_clause();
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parse__();
                      if (s10 !== peg$FAILED) {
                        s11 = peg$parsereturning_stmt();
                        if (s11 === peg$FAILED) {
                          s11 = null;
                        }
                        if (s11 !== peg$FAILED) {
                          peg$savedPos = s0;
                          s1 = peg$c351(s1, s5, s7, s9, s11);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "insert_no_columns_stmt",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "insert_no_columns_stmt",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsereplace_insert() {
    var s0, s1,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "replace_insert",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_INSERT();
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c352();
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseKW_REPLACE();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c353();
      }
      s0 = s1;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "replace_insert",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "replace_insert",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsevalue_clause() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "value_clause",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_VALUES();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parsevalue_list();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c354(s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "value_clause",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "value_clause",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsevalue_list() {
    var s0, s1, s2, s3, s4, s5, s6, s7,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "value_list",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parsevalue_item();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse__();
      if (s4 !== peg$FAILED) {
        s5 = peg$parseCOMMA();
        if (s5 !== peg$FAILED) {
          s6 = peg$parse__();
          if (s6 !== peg$FAILED) {
            s7 = peg$parsevalue_item();
            if (s7 !== peg$FAILED) {
              s4 = [s4, s5, s6, s7];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseCOMMA();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s7 = peg$parsevalue_item();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c355(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "value_list",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "value_list",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsevalue_item() {
    var s0, s1, s2, s3, s4, s5,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "value_item",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseLPAREN();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseexpr_list();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseRPAREN();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c356(s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "value_item",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "value_item",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseexpr_list() {
    var s0, s1, s2, s3, s4, s5, s6, s7,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "expr_list",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseexpr();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse__();
      if (s4 !== peg$FAILED) {
        s5 = peg$parseCOMMA();
        if (s5 !== peg$FAILED) {
          s6 = peg$parse__();
          if (s6 !== peg$FAILED) {
            s7 = peg$parseexpr();
            if (s7 !== peg$FAILED) {
              s4 = [s4, s5, s6, s7];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseCOMMA();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseexpr();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c314(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "expr_list",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expr_list",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseinterval_expr() {
    var s0, s1, s2, s3, s4, s5,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "interval_expr",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_INTERVAL();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseexpr();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseinterval_unit();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c357(s3, s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseKW_INTERVAL();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseliteral_string();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c358(s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "interval_expr",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "interval_expr",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecase_expr() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "case_expr",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_CASE();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseexpr();
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = [];
            s6 = peg$parsecase_when_then();
            if (s6 !== peg$FAILED) {
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                s6 = peg$parsecase_when_then();
              }
            } else {
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parsecase_else();
                if (s7 === peg$FAILED) {
                  s7 = null;
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse__();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parseKW_END();
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parse__();
                      if (s10 !== peg$FAILED) {
                        s11 = peg$parseKW_CASE();
                        if (s11 === peg$FAILED) {
                          s11 = null;
                        }
                        if (s11 !== peg$FAILED) {
                          peg$savedPos = s0;
                          s1 = peg$c359(s3, s5, s7);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "case_expr",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "case_expr",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecase_when_then() {
    var s0, s1, s2, s3, s4, s5, s6, s7,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "case_when_then",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_WHEN();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseexpr();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseKW_THEN();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseexpr();
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c360(s3, s7);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "case_when_then",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "case_when_then",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecase_else() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "case_else",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_ELSE();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseexpr();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c361(s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "case_else",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "case_else",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseexpr() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "expr",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$parselogic_operator_expr();
    if (s0 === peg$FAILED) {
      s0 = peg$parseunary_expr();
      if (s0 === peg$FAILED) {
        s0 = peg$parseor_expr();
        if (s0 === peg$FAILED) {
          s0 = peg$parseselect_stmt();
        }
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "expr",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "expr",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parselogic_operator_expr() {
    var s0, s1, s2, s3, s4, s5, s6, s7,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "logic_operator_expr",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseprimary();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse__();
      if (s4 !== peg$FAILED) {
        s5 = peg$parseLOGIC_OPERATOR();
        if (s5 !== peg$FAILED) {
          s6 = peg$parse__();
          if (s6 !== peg$FAILED) {
            s7 = peg$parseprimary();
            if (s7 !== peg$FAILED) {
              s4 = [s4, s5, s6, s7];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseLOGIC_OPERATOR();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseprimary();
                if (s7 !== peg$FAILED) {
                  s4 = [s4, s5, s6, s7];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c362(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "logic_operator_expr",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "logic_operator_expr",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseunary_expr() {
    var s0, s1, s2, s3, s4, s5,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "unary_expr",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseadditive_operator();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse__();
      if (s4 !== peg$FAILED) {
        s5 = peg$parseprimary();
        if (s5 !== peg$FAILED) {
          s4 = [s4, s5];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseprimary();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c363(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "unary_expr",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "unary_expr",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseor_and_where_expr() {
    var s0, s1, s2, s3, s4, s5, s6, s7,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "or_and_where_expr",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseparentheses_or_expr();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse__();
      if (s4 !== peg$FAILED) {
        s5 = peg$parseKW_AND();
        if (s5 === peg$FAILED) {
          s5 = peg$parseKW_OR();
        }
        if (s5 !== peg$FAILED) {
          s6 = peg$parse__();
          if (s6 !== peg$FAILED) {
            s7 = peg$parseparentheses_or_expr();
            if (s7 !== peg$FAILED) {
              s4 = [s4, s5, s6, s7];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseKW_AND();
          if (s5 === peg$FAILED) {
            s5 = peg$parseKW_OR();
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseparentheses_or_expr();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c364(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "or_and_where_expr",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "or_and_where_expr",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseparentheses_or_expr() {
    var s0, s1, s2, s3, s4, s5, s6,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "parentheses_or_expr",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseLPAREN();
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseor_expr();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseRPAREN();
            if (s5 === peg$FAILED) {
              s5 = null;
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = peg$currPos;
              s6 = peg$c365(s1, s3, s5);
              if (s6) {
                s6 = peg$FAILED;
              } else {
                s6 = void 0;
              }
              if (s6 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c366(s1, s3, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "parentheses_or_expr",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "parentheses_or_expr",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseor_expr() {
    var s0, s1, s2, s3, s4, s5, s6, s7,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "or_expr",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseand_expr();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse___();
      if (s4 !== peg$FAILED) {
        s5 = peg$parseKW_OR();
        if (s5 !== peg$FAILED) {
          s6 = peg$parse__();
          if (s6 !== peg$FAILED) {
            s7 = peg$parseand_expr();
            if (s7 !== peg$FAILED) {
              s4 = [s4, s5, s6, s7];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parse___();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseKW_OR();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseand_expr();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c367(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "or_expr",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "or_expr",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseand_expr() {
    var s0, s1, s2, s3, s4, s5, s6, s7,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "and_expr",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parsenot_expr();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse___();
      if (s4 !== peg$FAILED) {
        s5 = peg$parseKW_AND();
        if (s5 !== peg$FAILED) {
          s6 = peg$parse__();
          if (s6 !== peg$FAILED) {
            s7 = peg$parsenot_expr();
            if (s7 !== peg$FAILED) {
              s4 = [s4, s5, s6, s7];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parse___();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseKW_AND();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s7 = peg$parsenot_expr();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c367(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "and_expr",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "and_expr",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsenot_expr() {
    var s0, s1, s2, s3, s4,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "not_expr",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$parsecomparison_expr();
    if (s0 === peg$FAILED) {
      s0 = peg$parseexists_expr();
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseKW_NOT();
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 33) {
            s2 = peg$c368;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c369); }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$currPos;
            peg$silentFails++;
            if (input.charCodeAt(peg$currPos) === 61) {
              s4 = peg$c343;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c344); }
            }
            peg$silentFails--;
            if (s4 === peg$FAILED) {
              s3 = void 0;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            if (s3 !== peg$FAILED) {
              s2 = [s2, s3];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse__();
          if (s2 !== peg$FAILED) {
            s3 = peg$parsenot_expr();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c370(s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "not_expr",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "not_expr",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecomparison_expr() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "comparison_expr",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseadditive_expr();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parsecomparison_op_right();
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c371(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parseliteral_string();
      if (s0 === peg$FAILED) {
        s0 = peg$parsecolumn_ref();
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "comparison_expr",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "comparison_expr",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseexists_expr() {
    var s0, s1, s2, s3, s4, s5, s6, s7,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "exists_expr",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseexists_op();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseLPAREN();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseset_operator_stmt();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseRPAREN();
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c372(s1, s5);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "exists_expr",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "exists_expr",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseexists_op() {
    var s0, s1, s2, s3, s4,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "exists_op",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parseKW_NOT();
    if (s2 !== peg$FAILED) {
      s3 = peg$parse__();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseKW_EXISTS();
        if (s4 !== peg$FAILED) {
          s2 = [s2, s3, s4];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c373(s1);
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      s0 = peg$parseKW_EXISTS();
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "exists_op",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "exists_op",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecomparison_op_right() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "comparison_op_right",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$parsearithmetic_op_right();
    if (s0 === peg$FAILED) {
      s0 = peg$parsein_op_right();
      if (s0 === peg$FAILED) {
        s0 = peg$parsebetween_op_right();
        if (s0 === peg$FAILED) {
          s0 = peg$parseis_op_right();
          if (s0 === peg$FAILED) {
            s0 = peg$parselike_op_right();
            if (s0 === peg$FAILED) {
              s0 = peg$parsejsonb_op_right();
            }
          }
        }
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "comparison_op_right",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "comparison_op_right",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsearithmetic_op_right() {
    var s0, s1, s2, s3, s4, s5, s6,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "arithmetic_op_right",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$currPos;
    s3 = peg$parse__();
    if (s3 !== peg$FAILED) {
      s4 = peg$parsearithmetic_comparison_operator();
      if (s4 !== peg$FAILED) {
        s5 = peg$parse__();
        if (s5 !== peg$FAILED) {
          s6 = peg$parseadditive_expr();
          if (s6 !== peg$FAILED) {
            s3 = [s3, s4, s5, s6];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    } else {
      peg$currPos = s2;
      s2 = peg$FAILED;
    }
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$currPos;
        s3 = peg$parse__();
        if (s3 !== peg$FAILED) {
          s4 = peg$parsearithmetic_comparison_operator();
          if (s4 !== peg$FAILED) {
            s5 = peg$parse__();
            if (s5 !== peg$FAILED) {
              s6 = peg$parseadditive_expr();
              if (s6 !== peg$FAILED) {
                s3 = [s3, s4, s5, s6];
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c374(s1);
    }
    s0 = s1;

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "arithmetic_op_right",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "arithmetic_op_right",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsearithmetic_comparison_operator() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "arithmetic_comparison_operator",
      location: peg$computeLocation(startPos, startPos)
    });

    if (input.substr(peg$currPos, 2) === peg$c375) {
      s0 = peg$c375;
      peg$currPos += 2;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c376); }
    }
    if (s0 === peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 62) {
        s0 = peg$c377;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c378); }
      }
      if (s0 === peg$FAILED) {
        if (input.substr(peg$currPos, 2) === peg$c379) {
          s0 = peg$c379;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c380); }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c381) {
            s0 = peg$c381;
            peg$currPos += 2;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c382); }
          }
          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 60) {
              s0 = peg$c383;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c384); }
            }
            if (s0 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 61) {
                s0 = peg$c343;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c344); }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c385) {
                  s0 = peg$c385;
                  peg$currPos += 2;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c386); }
                }
              }
            }
          }
        }
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "arithmetic_comparison_operator",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "arithmetic_comparison_operator",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseis_op_right() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "is_op_right",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_IS();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseadditive_expr();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c387(s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseKW_IS();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          s4 = peg$parseKW_DISTINCT();
          if (s4 !== peg$FAILED) {
            s5 = peg$parse__();
            if (s5 !== peg$FAILED) {
              s6 = peg$parseKW_FROM();
              if (s6 !== peg$FAILED) {
                s7 = peg$parse__();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parsetable_name();
                  if (s8 !== peg$FAILED) {
                    s4 = [s4, s5, s6, s7, s8];
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c388(s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parseKW_IS();
        if (s2 !== peg$FAILED) {
          s3 = peg$parse__();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseKW_NOT();
            if (s4 !== peg$FAILED) {
              s2 = [s2, s3, s4];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse__();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseadditive_expr();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c389(s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "is_op_right",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "is_op_right",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsebetween_op_right() {
    var s0, s1, s2, s3, s4, s5, s6, s7,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "between_op_right",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parsebetween_or_not_between_op();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseadditive_expr();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseKW_AND();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseadditive_expr();
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c390(s1, s3, s7);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "between_op_right",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "between_op_right",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsebetween_or_not_between_op() {
    var s0, s1, s2, s3, s4,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "between_or_not_between_op",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parseKW_NOT();
    if (s2 !== peg$FAILED) {
      s3 = peg$parse__();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseKW_BETWEEN();
        if (s4 !== peg$FAILED) {
          s2 = [s2, s3, s4];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c391(s1);
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      s0 = peg$parseKW_BETWEEN();
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "between_or_not_between_op",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "between_or_not_between_op",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parselike_op() {
    var s0, s1, s2, s3, s4,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "like_op",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parseKW_NOT();
    if (s2 !== peg$FAILED) {
      s3 = peg$parse__();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseKW_LIKE();
        if (s4 === peg$FAILED) {
          s4 = peg$parseKW_ILIKE();
        }
        if (s4 !== peg$FAILED) {
          s2 = [s2, s3, s4];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c392(s1);
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      s0 = peg$parseKW_LIKE();
      if (s0 === peg$FAILED) {
        s0 = peg$parseKW_ILIKE();
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "like_op",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "like_op",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsein_op() {
    var s0, s1, s2, s3, s4,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "in_op",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parseKW_NOT();
    if (s2 !== peg$FAILED) {
      s3 = peg$parse__();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseKW_IN();
        if (s4 !== peg$FAILED) {
          s2 = [s2, s3, s4];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c393(s1);
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      s0 = peg$parseKW_IN();
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "in_op",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "in_op",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parselike_op_right() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "like_op_right",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parselike_op();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseliteral();
        if (s3 === peg$FAILED) {
          s3 = peg$parsecomparison_expr();
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c394(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "like_op_right",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "like_op_right",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsein_op_right() {
    var s0, s1, s2, s3, s4, s5, s6, s7,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "in_op_right",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parsein_op();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseLPAREN();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseexpr_list();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseRPAREN();
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c395(s1, s5);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parsein_op();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsevar_decl();
          if (s3 === peg$FAILED) {
            s3 = peg$parseliteral_string();
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c396(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "in_op_right",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "in_op_right",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsejsonb_op_right() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "jsonb_op_right",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c397) {
      s1 = peg$c397;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c398); }
    }
    if (s1 === peg$FAILED) {
      if (input.substr(peg$currPos, 2) === peg$c399) {
        s1 = peg$c399;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c400); }
      }
      if (s1 === peg$FAILED) {
        s1 = peg$parseOPERATOR_CONCATENATION();
        if (s1 === peg$FAILED) {
          s1 = peg$parseDOUBLE_WELL_ARROW();
          if (s1 === peg$FAILED) {
            s1 = peg$parseWELL_ARROW();
            if (s1 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 63) {
                s1 = peg$c401;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c402); }
              }
              if (s1 === peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c403) {
                  s1 = peg$c403;
                  peg$currPos += 2;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c404); }
                }
                if (s1 === peg$FAILED) {
                  if (input.substr(peg$currPos, 2) === peg$c405) {
                    s1 = peg$c405;
                    peg$currPos += 2;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c406); }
                  }
                  if (s1 === peg$FAILED) {
                    if (input.substr(peg$currPos, 2) === peg$c407) {
                      s1 = peg$c407;
                      peg$currPos += 2;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c408); }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parsecolumn_list_item();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c409(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "jsonb_op_right",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "jsonb_op_right",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseadditive_expr() {
    var s0, s1, s2, s3, s4, s5, s6, s7,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "additive_expr",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parsemultiplicative_expr();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse__();
      if (s4 !== peg$FAILED) {
        s5 = peg$parseadditive_operator();
        if (s5 !== peg$FAILED) {
          s6 = peg$parse__();
          if (s6 !== peg$FAILED) {
            s7 = peg$parsemultiplicative_expr();
            if (s7 !== peg$FAILED) {
              s4 = [s4, s5, s6, s7];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseadditive_operator();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s7 = peg$parsemultiplicative_expr();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c367(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "additive_expr",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "additive_expr",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseadditive_operator() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "additive_operator",
      location: peg$computeLocation(startPos, startPos)
    });

    if (input.charCodeAt(peg$currPos) === 43) {
      s0 = peg$c410;
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c411); }
    }
    if (s0 === peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 45) {
        s0 = peg$c412;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c413); }
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "additive_operator",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "additive_operator",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsemultiplicative_expr() {
    var s0, s1, s2, s3, s4, s5, s6, s7,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "multiplicative_expr",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseprimary();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse__();
      if (s4 !== peg$FAILED) {
        s5 = peg$parsemultiplicative_operator();
        if (s5 !== peg$FAILED) {
          s6 = peg$parse__();
          if (s6 !== peg$FAILED) {
            s7 = peg$parseprimary();
            if (s7 !== peg$FAILED) {
              s4 = [s4, s5, s6, s7];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s5 = peg$parsemultiplicative_operator();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseprimary();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c414(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "multiplicative_expr",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "multiplicative_expr",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsemultiplicative_operator() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "multiplicative_operator",
      location: peg$computeLocation(startPos, startPos)
    });

    if (input.charCodeAt(peg$currPos) === 42) {
      s0 = peg$c415;
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c416); }
    }
    if (s0 === peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 47) {
        s0 = peg$c417;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c418); }
      }
      if (s0 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 37) {
          s0 = peg$c419;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c420); }
        }
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "multiplicative_operator",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "multiplicative_operator",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseprimary() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "primary",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$parsecast_expr();
    if (s0 === peg$FAILED) {
      s0 = peg$parseliteral();
      if (s0 === peg$FAILED) {
        s0 = peg$parseaggr_func();
        if (s0 === peg$FAILED) {
          s0 = peg$parsewindow_func();
          if (s0 === peg$FAILED) {
            s0 = peg$parsefunc_call();
            if (s0 === peg$FAILED) {
              s0 = peg$parsecase_expr();
              if (s0 === peg$FAILED) {
                s0 = peg$parseinterval_expr();
                if (s0 === peg$FAILED) {
                  s0 = peg$parsecolumn_ref();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parseparam();
                    if (s0 === peg$FAILED) {
                      s0 = peg$currPos;
                      s1 = peg$parseLPAREN();
                      if (s1 !== peg$FAILED) {
                        s2 = peg$parse__();
                        if (s2 !== peg$FAILED) {
                          s3 = peg$parseexpr();
                          if (s3 !== peg$FAILED) {
                            s4 = peg$parse__();
                            if (s4 !== peg$FAILED) {
                              s5 = peg$parseRPAREN();
                              if (s5 !== peg$FAILED) {
                                s6 = [];
                                s7 = peg$currPos;
                                s8 = peg$parse___();
                                if (s8 !== peg$FAILED) {
                                  s9 = peg$parseKW_AND();
                                  if (s9 === peg$FAILED) {
                                    s9 = peg$parseKW_OR();
                                  }
                                  if (s9 !== peg$FAILED) {
                                    s10 = peg$parse__();
                                    if (s10 !== peg$FAILED) {
                                      s11 = peg$parseor_expr();
                                      if (s11 !== peg$FAILED) {
                                        s8 = [s8, s9, s10, s11];
                                        s7 = s8;
                                      } else {
                                        peg$currPos = s7;
                                        s7 = peg$FAILED;
                                      }
                                    } else {
                                      peg$currPos = s7;
                                      s7 = peg$FAILED;
                                    }
                                  } else {
                                    peg$currPos = s7;
                                    s7 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s7;
                                  s7 = peg$FAILED;
                                }
                                while (s7 !== peg$FAILED) {
                                  s6.push(s7);
                                  s7 = peg$currPos;
                                  s8 = peg$parse___();
                                  if (s8 !== peg$FAILED) {
                                    s9 = peg$parseKW_AND();
                                    if (s9 === peg$FAILED) {
                                      s9 = peg$parseKW_OR();
                                    }
                                    if (s9 !== peg$FAILED) {
                                      s10 = peg$parse__();
                                      if (s10 !== peg$FAILED) {
                                        s11 = peg$parseor_expr();
                                        if (s11 !== peg$FAILED) {
                                          s8 = [s8, s9, s10, s11];
                                          s7 = s8;
                                        } else {
                                          peg$currPos = s7;
                                          s7 = peg$FAILED;
                                        }
                                      } else {
                                        peg$currPos = s7;
                                        s7 = peg$FAILED;
                                      }
                                    } else {
                                      peg$currPos = s7;
                                      s7 = peg$FAILED;
                                    }
                                  } else {
                                    peg$currPos = s7;
                                    s7 = peg$FAILED;
                                  }
                                }
                                if (s6 !== peg$FAILED) {
                                  peg$savedPos = s0;
                                  s1 = peg$c421(s3, s6);
                                  s0 = s1;
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                      if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        s1 = peg$parseLPAREN();
                        if (s1 !== peg$FAILED) {
                          s2 = peg$parse__();
                          if (s2 !== peg$FAILED) {
                            s3 = peg$parseexpr_list();
                            if (s3 !== peg$FAILED) {
                              s4 = peg$parse__();
                              if (s4 !== peg$FAILED) {
                                s5 = peg$parseRPAREN();
                                if (s5 !== peg$FAILED) {
                                  peg$savedPos = s0;
                                  s1 = peg$c422(s3);
                                  s0 = s1;
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                        if (s0 === peg$FAILED) {
                          s0 = peg$parsevar_decl();
                          if (s0 === peg$FAILED) {
                            s0 = peg$currPos;
                            s1 = peg$parse__();
                            if (s1 !== peg$FAILED) {
                              if (input.charCodeAt(peg$currPos) === 36) {
                                s2 = peg$c423;
                                peg$currPos++;
                              } else {
                                s2 = peg$FAILED;
                                if (peg$silentFails === 0) { peg$fail(peg$c424); }
                              }
                              if (s2 !== peg$FAILED) {
                                s3 = peg$parseliteral_numeric();
                                if (s3 !== peg$FAILED) {
                                  peg$savedPos = s0;
                                  s1 = peg$c425(s2, s3);
                                  s0 = s1;
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "primary",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "primary",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecolumn_ref() {
    var s0, s1, s2, s3, s4, s5, s6, s7,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "column_ref",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseident();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseDOT();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseSTAR();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c426(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$parseident();
      if (s2 !== peg$FAILED) {
        s3 = peg$parse__();
        if (s3 !== peg$FAILED) {
          s4 = peg$parseDOT();
          if (s4 !== peg$FAILED) {
            s2 = [s2, s3, s4];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 === peg$FAILED) {
        s1 = null;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsecolumn();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse__();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseDOUBLE_ARROW();
              if (s5 === peg$FAILED) {
                s5 = peg$parseSINGLE_ARROW();
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parse__();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parseliteral_string();
                  if (s7 === peg$FAILED) {
                    s7 = peg$parseliteral_numeric();
                  }
                  if (s7 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c427(s1, s3, s5, s7);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseident();
        if (s1 !== peg$FAILED) {
          s2 = peg$parse__();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseDOT();
            if (s3 !== peg$FAILED) {
              s4 = peg$parse__();
              if (s4 !== peg$FAILED) {
                s5 = peg$parsecolumn_with_join();
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c428(s1, s5);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsecolumn_with_join();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c429(s1);
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseident();
            if (s1 !== peg$FAILED) {
              s2 = peg$parse__();
              if (s2 !== peg$FAILED) {
                s3 = peg$parseDOT();
                if (s3 !== peg$FAILED) {
                  s4 = peg$parse__();
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parsecolumn();
                    if (s5 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c430(s1, s5);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parsecolumn();
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c431(s1);
              }
              s0 = s1;
            }
          }
        }
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "column_ref",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "column_ref",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecolumn_list() {
    var s0, s1, s2, s3, s4, s5, s6, s7,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "column_list",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parsecolumn();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse__();
      if (s4 !== peg$FAILED) {
        s5 = peg$parseCOMMA();
        if (s5 !== peg$FAILED) {
          s6 = peg$parse__();
          if (s6 !== peg$FAILED) {
            s7 = peg$parsecolumn();
            if (s7 !== peg$FAILED) {
              s4 = [s4, s5, s6, s7];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseCOMMA();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s7 = peg$parsecolumn();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c256(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "column_list",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "column_list",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseident() {
    var s0, s1, s2,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "ident",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseident_name();
    if (s1 !== peg$FAILED) {
      peg$savedPos = peg$currPos;
      s2 = peg$c432(s1);
      if (s2) {
        s2 = peg$FAILED;
      } else {
        s2 = void 0;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c433(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parsequoted_ident();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c433(s1);
      }
      s0 = s1;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "ident",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "ident",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsealias_ident() {
    var s0, s1, s2,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "alias_ident",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseident_name();
    if (s1 !== peg$FAILED) {
      peg$savedPos = peg$currPos;
      s2 = peg$c434(s1);
      if (s2) {
        s2 = peg$FAILED;
      } else {
        s2 = void 0;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c435(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parsequoted_ident();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c436(s1);
      }
      s0 = s1;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "alias_ident",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "alias_ident",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsequoted_ident() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "quoted_ident",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$parsedouble_quoted_ident();
    if (s0 === peg$FAILED) {
      s0 = peg$parsesingle_quoted_ident();
      if (s0 === peg$FAILED) {
        s0 = peg$parsebackticks_quoted_ident();
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "quoted_ident",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "quoted_ident",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsedouble_quoted_ident() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "double_quoted_ident",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 34) {
      s1 = peg$c437;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c438); }
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      if (peg$c439.test(input.charAt(peg$currPos))) {
        s3 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c440); }
      }
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          if (peg$c439.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c440); }
          }
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 34) {
          s3 = peg$c437;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c438); }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c441(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "double_quoted_ident",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "double_quoted_ident",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsesingle_quoted_ident() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "single_quoted_ident",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 39) {
      s1 = peg$c212;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c213); }
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      if (peg$c442.test(input.charAt(peg$currPos))) {
        s3 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c443); }
      }
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          if (peg$c442.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c443); }
          }
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 39) {
          s3 = peg$c212;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c213); }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c444(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "single_quoted_ident",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "single_quoted_ident",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsebackticks_quoted_ident() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "backticks_quoted_ident",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 96) {
      s1 = peg$c445;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c446); }
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      if (peg$c447.test(input.charAt(peg$currPos))) {
        s3 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c448); }
      }
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          if (peg$c447.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c448); }
          }
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 96) {
          s3 = peg$c445;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c446); }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c444(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "backticks_quoted_ident",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "backticks_quoted_ident",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecolumn_with_join() {
    var s0, s1, s2,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "column_with_join",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parsecolumn_name_with_join();
    if (s1 === peg$FAILED) {
      s1 = peg$parsecolumn_name_with_join_double_quoted();
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = peg$currPos;
      s2 = peg$c432(s1);
      if (s2) {
        s2 = peg$FAILED;
      } else {
        s2 = void 0;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c449(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "column_with_join",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "column_with_join",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecolumn() {
    var s0, s1, s2,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "column",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parsecolumn_name();
    if (s1 !== peg$FAILED) {
      peg$savedPos = peg$currPos;
      s2 = peg$c432(s1);
      if (s2) {
        s2 = peg$FAILED;
      } else {
        s2 = void 0;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c449(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parsequoted_ident();
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "column",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "column",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecolumn_name() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "column_name",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseident_start();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parsecolumn_part();
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parsecolumn_part();
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c450(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "column_name",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "column_name",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecolumn_name_with_join() {
    var s0, s1, s2, s3, s4,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "column_name_with_join",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseident_start();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parsecolumn_part();
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parsecolumn_part();
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse__();
        if (s3 !== peg$FAILED) {
          s4 = peg$parsejoin_mark_part();
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c451(s1, s2, s4);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "column_name_with_join",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "column_name_with_join",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecolumn_name_with_join_double_quoted() {
    var s0, s1, s2, s3, s4, s5, s6,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "column_name_with_join_double_quoted",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 34) {
      s1 = peg$c437;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c438); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseident_start();
      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parsecolumn_part();
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parsecolumn_part();
        }
        if (s3 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 34) {
            s4 = peg$c437;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c438); }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parse__();
            if (s5 !== peg$FAILED) {
              s6 = peg$parsejoin_mark_part();
              if (s6 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c452(s2, s3, s6);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "column_name_with_join_double_quoted",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "column_name_with_join_double_quoted",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseident_name() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "ident_name",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseident_start();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseident_part();
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parseident_part();
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c453(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "ident_name",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "ident_name",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseident_start() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "ident_start",
      location: peg$computeLocation(startPos, startPos)
    });

    if (peg$c454.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c455); }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "ident_start",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "ident_start",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseident_part() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "ident_part",
      location: peg$computeLocation(startPos, startPos)
    });

    if (peg$c456.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c457); }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "ident_part",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "ident_part",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsejoin_mark_part() {
    var s0, s1, s2, s3, s4, s5, s6,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "join_mark_part",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parse__();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseLPAREN();
      if (s2 !== peg$FAILED) {
        s3 = peg$parse__();
        if (s3 !== peg$FAILED) {
          s4 = peg$parsePLUS();
          if (s4 !== peg$FAILED) {
            s5 = peg$parse__();
            if (s5 !== peg$FAILED) {
              s6 = peg$parseRPAREN();
              if (s6 !== peg$FAILED) {
                s1 = [s1, s2, s3, s4, s5, s6];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "join_mark_part",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "join_mark_part",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecolumn_part() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "column_part",
      location: peg$computeLocation(startPos, startPos)
    });

    if (peg$c458.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c459); }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "column_part",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "column_part",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseparam() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "param",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 58) {
      s2 = peg$c460;
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c461); }
    }
    if (s2 !== peg$FAILED) {
      s3 = peg$parseident_name();
      if (s3 !== peg$FAILED) {
        s2 = [s2, s3];
        s1 = s2;
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c462(s1);
    }
    s0 = s1;

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "param",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "param",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseover_partition() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "over_partition",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c463) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c464); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseas_window_specification();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c465(s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c463) {
        s1 = input.substr(peg$currPos, 4);
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c464); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseLPAREN();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse__();
            if (s4 !== peg$FAILED) {
              s5 = peg$parsepartition_by_clause();
              if (s5 === peg$FAILED) {
                s5 = null;
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parse__();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parseorder_by_clause();
                  if (s7 === peg$FAILED) {
                    s7 = null;
                  }
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parse__();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parseRPAREN();
                      if (s9 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c466(s5, s7);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "over_partition",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "over_partition",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseaggr_func() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "aggr_func",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$parseaggr_fun_count();
    if (s0 === peg$FAILED) {
      s0 = peg$parseaggr_fun_smma();
      if (s0 === peg$FAILED) {
        s0 = peg$parseaggr_array_agg();
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "aggr_func",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "aggr_func",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsewindow_func() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "window_func",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$parsewindow_fun_rank();
    if (s0 === peg$FAILED) {
      s0 = peg$parsewindow_fun_laglead();
      if (s0 === peg$FAILED) {
        s0 = peg$parsewindow_fun_firstlast();
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "window_func",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "window_func",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsewindow_fun_rank() {
    var s0, s1, s2, s3, s4, s5, s6, s7,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "window_fun_rank",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_WIN_FNS_RANK();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseLPAREN();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseRPAREN();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseover_partition();
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c467(s1, s7);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "window_fun_rank",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "window_fun_rank",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsewindow_fun_laglead() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "window_fun_laglead",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_LAG_LEAD();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseLPAREN();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseexpr_list();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseRPAREN();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse__();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parseover_partition();
                    if (s9 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c468(s1, s5, s9);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "window_fun_laglead",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "window_fun_laglead",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsewindow_fun_firstlast() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "window_fun_firstlast",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_FIRST_LAST_VALUE();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseLPAREN();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseexpr();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseconsider_nulls_clause();
                if (s7 === peg$FAILED) {
                  s7 = null;
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse__();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parseRPAREN();
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parse__();
                      if (s10 !== peg$FAILED) {
                        s11 = peg$parseover_partition();
                        if (s11 !== peg$FAILED) {
                          peg$savedPos = s0;
                          s1 = peg$c469(s1, s5, s7, s11);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "window_fun_firstlast",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "window_fun_firstlast",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_FIRST_LAST_VALUE() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_FIRST_LAST_VALUE",
      location: peg$computeLocation(startPos, startPos)
    });

    if (input.substr(peg$currPos, 11).toLowerCase() === peg$c470) {
      s0 = input.substr(peg$currPos, 11);
      peg$currPos += 11;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c471); }
    }
    if (s0 === peg$FAILED) {
      if (input.substr(peg$currPos, 10).toLowerCase() === peg$c472) {
        s0 = input.substr(peg$currPos, 10);
        peg$currPos += 10;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c473); }
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_FIRST_LAST_VALUE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_FIRST_LAST_VALUE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_WIN_FNS_RANK() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_WIN_FNS_RANK",
      location: peg$computeLocation(startPos, startPos)
    });

    if (input.substr(peg$currPos, 10).toLowerCase() === peg$c474) {
      s0 = input.substr(peg$currPos, 10);
      peg$currPos += 10;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c475); }
    }
    if (s0 === peg$FAILED) {
      if (input.substr(peg$currPos, 10).toLowerCase() === peg$c476) {
        s0 = input.substr(peg$currPos, 10);
        peg$currPos += 10;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c477); }
      }
      if (s0 === peg$FAILED) {
        if (input.substr(peg$currPos, 4).toLowerCase() === peg$c478) {
          s0 = input.substr(peg$currPos, 4);
          peg$currPos += 4;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c479); }
        }
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_WIN_FNS_RANK",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_WIN_FNS_RANK",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_LAG_LEAD() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_LAG_LEAD",
      location: peg$computeLocation(startPos, startPos)
    });

    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c480) {
      s0 = input.substr(peg$currPos, 3);
      peg$currPos += 3;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c481); }
    }
    if (s0 === peg$FAILED) {
      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c482) {
        s0 = input.substr(peg$currPos, 4);
        peg$currPos += 4;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c483); }
      }
      if (s0 === peg$FAILED) {
        if (input.substr(peg$currPos, 9).toLowerCase() === peg$c484) {
          s0 = input.substr(peg$currPos, 9);
          peg$currPos += 9;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c485); }
        }
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_LAG_LEAD",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_LAG_LEAD",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseconsider_nulls_clause() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "consider_nulls_clause",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c486) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c487); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        if (input.substr(peg$currPos, 5).toLowerCase() === peg$c47) {
          s3 = input.substr(peg$currPos, 5);
          peg$currPos += 5;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c48); }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c488(s1);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "consider_nulls_clause",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "consider_nulls_clause",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseaggr_fun_smma() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "aggr_fun_smma",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_SUM_MAX_MIN_AVG();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseLPAREN();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseadditive_expr();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseRPAREN();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse__();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parseover_partition();
                    if (s9 === peg$FAILED) {
                      s9 = null;
                    }
                    if (s9 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c489(s1, s5, s9);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "aggr_fun_smma",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "aggr_fun_smma",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_SUM_MAX_MIN_AVG() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_SUM_MAX_MIN_AVG",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$parseKW_SUM();
    if (s0 === peg$FAILED) {
      s0 = peg$parseKW_MAX();
      if (s0 === peg$FAILED) {
        s0 = peg$parseKW_MIN();
        if (s0 === peg$FAILED) {
          s0 = peg$parseKW_AVG();
        }
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_SUM_MAX_MIN_AVG",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_SUM_MAX_MIN_AVG",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseaggr_fun_count() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "aggr_fun_count",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_COUNT();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseLPAREN();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parsecount_arg();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseRPAREN();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse__();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parseover_partition();
                    if (s9 === peg$FAILED) {
                      s9 = null;
                    }
                    if (s9 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c490(s1, s5, s9);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "aggr_fun_count",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "aggr_fun_count",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsedistinct_args() {
    var s0, s1, s2, s3, s4, s5, s6, s7,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "distinct_args",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_DISTINCT();
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parsecolumn_ref();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c491(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseKW_DISTINCT();
      if (s1 === peg$FAILED) {
        s1 = null;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseLPAREN();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse__();
            if (s4 !== peg$FAILED) {
              s5 = peg$parsecolumn_ref();
              if (s5 !== peg$FAILED) {
                s6 = peg$parse__();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parseRPAREN();
                  if (s7 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c492(s1, s5);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "distinct_args",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "distinct_args",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecount_arg() {
    var s0, s1,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "count_arg",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parsestar_expr();
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c493(s1);
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      s0 = peg$parsedistinct_args();
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "count_arg",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "count_arg",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseaggr_array_agg() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "aggr_array_agg",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_ARRAY_AGG();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseLPAREN();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parsedistinct_args();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseorder_by_clause();
                if (s7 === peg$FAILED) {
                  s7 = null;
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse__();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parseRPAREN();
                    if (s9 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c494(s1, s5, s7);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "aggr_array_agg",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "aggr_array_agg",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsestar_expr() {
    var s0, s1,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "star_expr",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 42) {
      s1 = peg$c415;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c416); }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c495();
    }
    s0 = s1;

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "star_expr",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "star_expr",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsefunc_call() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "func_call",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseproc_func_name();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseLPAREN();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseexpr_list();
            if (s5 === peg$FAILED) {
              s5 = null;
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseRPAREN();
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c315(s1, s5);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parsescalar_func();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseLPAREN();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse__();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseexpr_list();
              if (s5 === peg$FAILED) {
                s5 = null;
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parse__();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parseRPAREN();
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parse__();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parseover_partition();
                      if (s9 === peg$FAILED) {
                        s9 = null;
                      }
                      if (s9 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c496(s1, s5, s9);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parseextract_func();
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "func_call",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "func_call",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseextract_filed() {
    var s0, s1,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "extract_filed",
      location: peg$computeLocation(startPos, startPos)
    });

    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c497) {
      s0 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c498); }
    }
    if (s0 === peg$FAILED) {
      if (input.substr(peg$currPos, 3).toLowerCase() === peg$c499) {
        s0 = input.substr(peg$currPos, 3);
        peg$currPos += 3;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c500); }
      }
      if (s0 === peg$FAILED) {
        if (input.substr(peg$currPos, 6).toLowerCase() === peg$c501) {
          s0 = input.substr(peg$currPos, 6);
          peg$currPos += 6;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c502); }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 3).toLowerCase() === peg$c503) {
            s0 = input.substr(peg$currPos, 3);
            peg$currPos += 3;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c504); }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 3).toLowerCase() === peg$c505) {
              s0 = input.substr(peg$currPos, 3);
              peg$currPos += 3;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c506); }
            }
            if (s0 === peg$FAILED) {
              if (input.substr(peg$currPos, 5).toLowerCase() === peg$c507) {
                s0 = input.substr(peg$currPos, 5);
                peg$currPos += 5;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c508); }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 4).toLowerCase() === peg$c509) {
                  s0 = input.substr(peg$currPos, 4);
                  peg$currPos += 4;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c510); }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 6).toLowerCase() === peg$c511) {
                    s0 = input.substr(peg$currPos, 6);
                    peg$currPos += 6;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c512); }
                  }
                  if (s0 === peg$FAILED) {
                    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c513) {
                      s0 = input.substr(peg$currPos, 7);
                      peg$currPos += 7;
                    } else {
                      s0 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c514); }
                    }
                    if (s0 === peg$FAILED) {
                      if (input.substr(peg$currPos, 12).toLowerCase() === peg$c515) {
                        s0 = input.substr(peg$currPos, 12);
                        peg$currPos += 12;
                      } else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c516); }
                      }
                      if (s0 === peg$FAILED) {
                        if (input.substr(peg$currPos, 10).toLowerCase() === peg$c517) {
                          s0 = input.substr(peg$currPos, 10);
                          peg$currPos += 10;
                        } else {
                          s0 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c518); }
                        }
                        if (s0 === peg$FAILED) {
                          if (input.substr(peg$currPos, 12).toLowerCase() === peg$c519) {
                            s0 = input.substr(peg$currPos, 12);
                            peg$currPos += 12;
                          } else {
                            s0 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$c520); }
                          }
                          if (s0 === peg$FAILED) {
                            if (input.substr(peg$currPos, 6).toLowerCase() === peg$c521) {
                              s0 = input.substr(peg$currPos, 6);
                              peg$currPos += 6;
                            } else {
                              s0 = peg$FAILED;
                              if (peg$silentFails === 0) { peg$fail(peg$c522); }
                            }
                            if (s0 === peg$FAILED) {
                              if (input.substr(peg$currPos, 5).toLowerCase() === peg$c523) {
                                s0 = input.substr(peg$currPos, 5);
                                peg$currPos += 5;
                              } else {
                                s0 = peg$FAILED;
                                if (peg$silentFails === 0) { peg$fail(peg$c524); }
                              }
                              if (s0 === peg$FAILED) {
                                if (input.substr(peg$currPos, 7).toLowerCase() === peg$c525) {
                                  s0 = input.substr(peg$currPos, 7);
                                  peg$currPos += 7;
                                } else {
                                  s0 = peg$FAILED;
                                  if (peg$silentFails === 0) { peg$fail(peg$c526); }
                                }
                                if (s0 === peg$FAILED) {
                                  if (input.substr(peg$currPos, 6).toLowerCase() === peg$c527) {
                                    s0 = input.substr(peg$currPos, 6);
                                    peg$currPos += 6;
                                  } else {
                                    s0 = peg$FAILED;
                                    if (peg$silentFails === 0) { peg$fail(peg$c528); }
                                  }
                                  if (s0 === peg$FAILED) {
                                    if (input.substr(peg$currPos, 8).toLowerCase() === peg$c529) {
                                      s0 = input.substr(peg$currPos, 8);
                                      peg$currPos += 8;
                                    } else {
                                      s0 = peg$FAILED;
                                      if (peg$silentFails === 0) { peg$fail(peg$c530); }
                                    }
                                    if (s0 === peg$FAILED) {
                                      if (input.substr(peg$currPos, 13).toLowerCase() === peg$c531) {
                                        s0 = input.substr(peg$currPos, 13);
                                        peg$currPos += 13;
                                      } else {
                                        s0 = peg$FAILED;
                                        if (peg$silentFails === 0) { peg$fail(peg$c532); }
                                      }
                                      if (s0 === peg$FAILED) {
                                        if (input.substr(peg$currPos, 15).toLowerCase() === peg$c533) {
                                          s0 = input.substr(peg$currPos, 15);
                                          peg$currPos += 15;
                                        } else {
                                          s0 = peg$FAILED;
                                          if (peg$silentFails === 0) { peg$fail(peg$c534); }
                                        }
                                        if (s0 === peg$FAILED) {
                                          if (input.substr(peg$currPos, 4).toLowerCase() === peg$c535) {
                                            s0 = input.substr(peg$currPos, 4);
                                            peg$currPos += 4;
                                          } else {
                                            s0 = peg$FAILED;
                                            if (peg$silentFails === 0) { peg$fail(peg$c536); }
                                          }
                                          if (s0 === peg$FAILED) {
                                            s0 = peg$currPos;
                                            if (input.substr(peg$currPos, 4).toLowerCase() === peg$c537) {
                                              s1 = input.substr(peg$currPos, 4);
                                              peg$currPos += 4;
                                            } else {
                                              s1 = peg$FAILED;
                                              if (peg$silentFails === 0) { peg$fail(peg$c538); }
                                            }
                                            if (s1 !== peg$FAILED) {
                                              peg$savedPos = s0;
                                              s1 = peg$c539();
                                            }
                                            s0 = s1;
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "extract_filed",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "extract_filed",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseextract_func() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "extract_func",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_EXTRACT();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseLPAREN();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseextract_filed();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseKW_FROM();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse__();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parseKW_TIMESTAMP();
                    if (s9 === peg$FAILED) {
                      s9 = peg$parseKW_INTERVAL();
                      if (s9 === peg$FAILED) {
                        s9 = peg$parseKW_TIME();
                        if (s9 === peg$FAILED) {
                          s9 = peg$parseKW_DATE();
                        }
                      }
                    }
                    if (s9 === peg$FAILED) {
                      s9 = null;
                    }
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parse__();
                      if (s10 !== peg$FAILED) {
                        s11 = peg$parseexpr();
                        if (s11 !== peg$FAILED) {
                          s12 = peg$parse__();
                          if (s12 !== peg$FAILED) {
                            s13 = peg$parseRPAREN();
                            if (s13 !== peg$FAILED) {
                              peg$savedPos = s0;
                              s1 = peg$c540(s1, s5, s9, s11);
                              s0 = s1;
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "extract_func",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "extract_func",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsescalar_func() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "scalar_func",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$parseKW_CURRENT_DATE();
    if (s0 === peg$FAILED) {
      s0 = peg$parseKW_CURRENT_TIME();
      if (s0 === peg$FAILED) {
        s0 = peg$parseKW_CURRENT_TIMESTAMP();
        if (s0 === peg$FAILED) {
          s0 = peg$parseKW_CURRENT_USER();
          if (s0 === peg$FAILED) {
            s0 = peg$parseKW_USER();
            if (s0 === peg$FAILED) {
              s0 = peg$parseKW_SESSION_USER();
              if (s0 === peg$FAILED) {
                s0 = peg$parseKW_SYSTEM_USER();
              }
            }
          }
        }
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "scalar_func",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "scalar_func",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecast_expr() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17, s18, s19, s20, s21,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "cast_expr",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseliteral();
    if (s1 === peg$FAILED) {
      s1 = peg$parseaggr_func();
      if (s1 === peg$FAILED) {
        s1 = peg$parsewindow_func();
        if (s1 === peg$FAILED) {
          s1 = peg$parsefunc_call();
          if (s1 === peg$FAILED) {
            s1 = peg$parsecase_expr();
            if (s1 === peg$FAILED) {
              s1 = peg$parseinterval_expr();
              if (s1 === peg$FAILED) {
                s1 = peg$parsecolumn_ref();
                if (s1 === peg$FAILED) {
                  s1 = peg$parseparam();
                }
              }
            }
          }
        }
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseKW_DOUBLE_COLON();
      if (s2 !== peg$FAILED) {
        s3 = peg$parsedata_type();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parsealias_clause();
            if (s5 === peg$FAILED) {
              s5 = null;
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c541(s1, s2, s3, s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseKW_CAST();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseLPAREN();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse__();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseexpr();
              if (s5 !== peg$FAILED) {
                s6 = peg$parse__();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parseKW_AS();
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parse__();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parsedata_type();
                      if (s9 !== peg$FAILED) {
                        s10 = peg$parse__();
                        if (s10 !== peg$FAILED) {
                          s11 = peg$parseRPAREN();
                          if (s11 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c542(s5, s9);
                            s0 = s1;
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseKW_CAST();
        if (s1 !== peg$FAILED) {
          s2 = peg$parse__();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseLPAREN();
            if (s3 !== peg$FAILED) {
              s4 = peg$parse__();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseexpr();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parse__();
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parseKW_AS();
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parse__();
                      if (s8 !== peg$FAILED) {
                        s9 = peg$parseKW_DECIMAL();
                        if (s9 !== peg$FAILED) {
                          s10 = peg$parse__();
                          if (s10 !== peg$FAILED) {
                            s11 = peg$parseLPAREN();
                            if (s11 !== peg$FAILED) {
                              s12 = peg$parse__();
                              if (s12 !== peg$FAILED) {
                                s13 = peg$parseint();
                                if (s13 !== peg$FAILED) {
                                  s14 = peg$parse__();
                                  if (s14 !== peg$FAILED) {
                                    s15 = peg$parseRPAREN();
                                    if (s15 !== peg$FAILED) {
                                      s16 = peg$parse__();
                                      if (s16 !== peg$FAILED) {
                                        s17 = peg$parseRPAREN();
                                        if (s17 !== peg$FAILED) {
                                          peg$savedPos = s0;
                                          s1 = peg$c543(s5, s13);
                                          s0 = s1;
                                        } else {
                                          peg$currPos = s0;
                                          s0 = peg$FAILED;
                                        }
                                      } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                      }
                                    } else {
                                      peg$currPos = s0;
                                      s0 = peg$FAILED;
                                    }
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseKW_CAST();
          if (s1 !== peg$FAILED) {
            s2 = peg$parse__();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseLPAREN();
              if (s3 !== peg$FAILED) {
                s4 = peg$parse__();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseexpr();
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parse__();
                    if (s6 !== peg$FAILED) {
                      s7 = peg$parseKW_AS();
                      if (s7 !== peg$FAILED) {
                        s8 = peg$parse__();
                        if (s8 !== peg$FAILED) {
                          s9 = peg$parseKW_DECIMAL();
                          if (s9 !== peg$FAILED) {
                            s10 = peg$parse__();
                            if (s10 !== peg$FAILED) {
                              s11 = peg$parseLPAREN();
                              if (s11 !== peg$FAILED) {
                                s12 = peg$parse__();
                                if (s12 !== peg$FAILED) {
                                  s13 = peg$parseint();
                                  if (s13 !== peg$FAILED) {
                                    s14 = peg$parse__();
                                    if (s14 !== peg$FAILED) {
                                      s15 = peg$parseCOMMA();
                                      if (s15 !== peg$FAILED) {
                                        s16 = peg$parse__();
                                        if (s16 !== peg$FAILED) {
                                          s17 = peg$parseint();
                                          if (s17 !== peg$FAILED) {
                                            s18 = peg$parse__();
                                            if (s18 !== peg$FAILED) {
                                              s19 = peg$parseRPAREN();
                                              if (s19 !== peg$FAILED) {
                                                s20 = peg$parse__();
                                                if (s20 !== peg$FAILED) {
                                                  s21 = peg$parseRPAREN();
                                                  if (s21 !== peg$FAILED) {
                                                    peg$savedPos = s0;
                                                    s1 = peg$c544(s5, s13, s17);
                                                    s0 = s1;
                                                  } else {
                                                    peg$currPos = s0;
                                                    s0 = peg$FAILED;
                                                  }
                                                } else {
                                                  peg$currPos = s0;
                                                  s0 = peg$FAILED;
                                                }
                                              } else {
                                                peg$currPos = s0;
                                                s0 = peg$FAILED;
                                              }
                                            } else {
                                              peg$currPos = s0;
                                              s0 = peg$FAILED;
                                            }
                                          } else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                          }
                                        } else {
                                          peg$currPos = s0;
                                          s0 = peg$FAILED;
                                        }
                                      } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                      }
                                    } else {
                                      peg$currPos = s0;
                                      s0 = peg$FAILED;
                                    }
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseKW_CAST();
            if (s1 !== peg$FAILED) {
              s2 = peg$parse__();
              if (s2 !== peg$FAILED) {
                s3 = peg$parseLPAREN();
                if (s3 !== peg$FAILED) {
                  s4 = peg$parse__();
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parseexpr();
                    if (s5 !== peg$FAILED) {
                      s6 = peg$parse__();
                      if (s6 !== peg$FAILED) {
                        s7 = peg$parseKW_AS();
                        if (s7 !== peg$FAILED) {
                          s8 = peg$parse__();
                          if (s8 !== peg$FAILED) {
                            s9 = peg$parsesignedness();
                            if (s9 !== peg$FAILED) {
                              s10 = peg$parse__();
                              if (s10 !== peg$FAILED) {
                                s11 = peg$parseKW_INTEGER();
                                if (s11 === peg$FAILED) {
                                  s11 = null;
                                }
                                if (s11 !== peg$FAILED) {
                                  s12 = peg$parse__();
                                  if (s12 !== peg$FAILED) {
                                    s13 = peg$parseRPAREN();
                                    if (s13 !== peg$FAILED) {
                                      peg$savedPos = s0;
                                      s1 = peg$c545(s5, s9, s11);
                                      s0 = s1;
                                    } else {
                                      peg$currPos = s0;
                                      s0 = peg$FAILED;
                                    }
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
        }
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "cast_expr",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "cast_expr",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsesignedness() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "signedness",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$parseKW_SIGNED();
    if (s0 === peg$FAILED) {
      s0 = peg$parseKW_UNSIGNED();
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "signedness",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "signedness",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseliteral() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "literal",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$parseliteral_string();
    if (s0 === peg$FAILED) {
      s0 = peg$parseliteral_numeric();
      if (s0 === peg$FAILED) {
        s0 = peg$parseliteral_bool();
        if (s0 === peg$FAILED) {
          s0 = peg$parseliteral_null();
          if (s0 === peg$FAILED) {
            s0 = peg$parseliteral_datetime();
            if (s0 === peg$FAILED) {
              s0 = peg$parseliteral_array();
            }
          }
        }
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "literal",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "literal",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseliteral_array() {
    var s0, s1, s2, s3, s4, s5, s6, s7,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "literal_array",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_ARRAY();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseLBRAKE();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseexpr_list();
            if (s5 === peg$FAILED) {
              s5 = null;
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseRBRAKE();
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c546(s1, s5);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "literal_array",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "literal_array",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseliteral_list() {
    var s0, s1, s2, s3, s4, s5, s6, s7,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "literal_list",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseliteral();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse__();
      if (s4 !== peg$FAILED) {
        s5 = peg$parseCOMMA();
        if (s5 !== peg$FAILED) {
          s6 = peg$parse__();
          if (s6 !== peg$FAILED) {
            s7 = peg$parseliteral();
            if (s7 !== peg$FAILED) {
              s4 = [s4, s5, s6, s7];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseCOMMA();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseliteral();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c547(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "literal_list",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "literal_list",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseliteral_null() {
    var s0, s1,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "literal_null",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_NULL();
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c548();
    }
    s0 = s1;

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "literal_null",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "literal_null",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseliteral_not_null() {
    var s0, s1,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "literal_not_null",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_NOT_NULL();
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c549();
    }
    s0 = s1;

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "literal_not_null",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "literal_not_null",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseliteral_bool() {
    var s0, s1,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "literal_bool",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_TRUE();
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c550();
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseKW_FALSE();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c551();
      }
      s0 = s1;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "literal_bool",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "literal_bool",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseliteral_string() {
    var s0, s1, s2, s3, s4,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "literal_string",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 39) {
      s2 = peg$c212;
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c213); }
    }
    if (s2 !== peg$FAILED) {
      s3 = [];
      s4 = peg$parsesingle_char_in_col();
      while (s4 !== peg$FAILED) {
        s3.push(s4);
        s4 = peg$parsesingle_char_in_col();
      }
      if (s3 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 39) {
          s4 = peg$c212;
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c213); }
        }
        if (s4 !== peg$FAILED) {
          s2 = [s2, s3, s4];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c552(s1);
    }
    s0 = s1;

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "literal_string",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "literal_string",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseliteral_datetime() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "literal_datetime",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_TIME();
    if (s1 === peg$FAILED) {
      s1 = peg$parseKW_DATE();
      if (s1 === peg$FAILED) {
        s1 = peg$parseKW_TIMESTAMP();
        if (s1 === peg$FAILED) {
          s1 = peg$parseKW_DATETIME();
        }
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 39) {
          s4 = peg$c212;
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c213); }
        }
        if (s4 !== peg$FAILED) {
          s5 = [];
          s6 = peg$parsesingle_char();
          while (s6 !== peg$FAILED) {
            s5.push(s6);
            s6 = peg$parsesingle_char();
          }
          if (s5 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 39) {
              s6 = peg$c212;
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c213); }
            }
            if (s6 !== peg$FAILED) {
              s4 = [s4, s5, s6];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c553(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseKW_CURRENT_TIMESTAMP();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseLPAREN();
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse__();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseRPAREN();
              if (s5 === peg$FAILED) {
                s5 = null;
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = peg$currPos;
                s6 = peg$c554(s1, s3, s5);
                if (s6) {
                  s6 = peg$FAILED;
                } else {
                  s6 = void 0;
                }
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse__();
                  if (s7 !== peg$FAILED) {
                    if (input.substr(peg$currPos, 27).toLowerCase() === peg$c555) {
                      s8 = input.substr(peg$currPos, 27);
                      peg$currPos += 27;
                    } else {
                      s8 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c556); }
                    }
                    if (s8 === peg$FAILED) {
                      s8 = null;
                    }
                    if (s8 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c557(s1, s3, s5, s8);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "literal_datetime",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "literal_datetime",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsesingle_quote_char() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "single_quote_char",
      location: peg$computeLocation(startPos, startPos)
    });

    if (peg$c558.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c559); }
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parseescape_char();
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "single_quote_char",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "single_quote_char",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsesingle_char_in_col() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "single_char_in_col",
      location: peg$computeLocation(startPos, startPos)
    });

    if (peg$c560.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c561); }
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parseescape_char();
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "single_char_in_col",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "single_char_in_col",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsesingle_char() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "single_char",
      location: peg$computeLocation(startPos, startPos)
    });

    if (peg$c562.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c563); }
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parseescape_char();
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "single_char",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "single_char",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseescape_char() {
    var s0, s1, s2, s3, s4, s5,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "escape_char",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c564) {
      s1 = peg$c564;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c565); }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c566();
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c567) {
        s1 = peg$c567;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c568); }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c569();
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c570) {
          s1 = peg$c570;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c571); }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c572();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c573) {
            s1 = peg$c573;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c574); }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c575();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c576) {
              s1 = peg$c576;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c577); }
            }
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c578();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 2) === peg$c579) {
                s1 = peg$c579;
                peg$currPos += 2;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c580); }
              }
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c581();
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 2) === peg$c582) {
                  s1 = peg$c582;
                  peg$currPos += 2;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c583); }
                }
                if (s1 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c584();
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  if (input.substr(peg$currPos, 2) === peg$c585) {
                    s1 = peg$c585;
                    peg$currPos += 2;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c586); }
                  }
                  if (s1 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c587();
                  }
                  s0 = s1;
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 2) === peg$c588) {
                      s1 = peg$c588;
                      peg$currPos += 2;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c589); }
                    }
                    if (s1 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c590();
                    }
                    s0 = s1;
                    if (s0 === peg$FAILED) {
                      s0 = peg$currPos;
                      if (input.substr(peg$currPos, 2) === peg$c591) {
                        s1 = peg$c591;
                        peg$currPos += 2;
                      } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c592); }
                      }
                      if (s1 !== peg$FAILED) {
                        s2 = peg$parsehexDigit();
                        if (s2 !== peg$FAILED) {
                          s3 = peg$parsehexDigit();
                          if (s3 !== peg$FAILED) {
                            s4 = peg$parsehexDigit();
                            if (s4 !== peg$FAILED) {
                              s5 = peg$parsehexDigit();
                              if (s5 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s1 = peg$c593(s2, s3, s4, s5);
                                s0 = s1;
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                      if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        if (input.charCodeAt(peg$currPos) === 92) {
                          s1 = peg$c594;
                          peg$currPos++;
                        } else {
                          s1 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c595); }
                        }
                        if (s1 !== peg$FAILED) {
                          peg$savedPos = s0;
                          s1 = peg$c572();
                        }
                        s0 = s1;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "escape_char",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "escape_char",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseline_terminator() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "line_terminator",
      location: peg$computeLocation(startPos, startPos)
    });

    if (peg$c596.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c597); }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "line_terminator",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "line_terminator",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseliteral_numeric() {
    var s0, s1,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "literal_numeric",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parsenumber();
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c598(s1);
    }
    s0 = s1;

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "literal_numeric",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "literal_numeric",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsenumber() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "number",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseint();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsefrac();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseexp();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c599(s1, s2, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseint();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsefrac();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c600(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseint();
        if (s1 !== peg$FAILED) {
          s2 = peg$parseexp();
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c601(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseint();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c602(s1);
          }
          s0 = s1;
        }
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "number",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "number",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseint() {
    var s0, s1, s2,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "int",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$parsedigits();
    if (s0 === peg$FAILED) {
      s0 = peg$parsedigit();
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 45) {
          s1 = peg$c412;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c413); }
        }
        if (s1 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 43) {
            s1 = peg$c410;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c411); }
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parsedigits();
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c603(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 45) {
            s1 = peg$c412;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c413); }
          }
          if (s1 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 43) {
              s1 = peg$c410;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c411); }
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parsedigit();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c604(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "int",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "int",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsefrac() {
    var s0, s1, s2,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "frac",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 46) {
      s1 = peg$c605;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c606); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parsedigits();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c607(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "frac",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "frac",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseexp() {
    var s0, s1, s2,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "exp",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parsee();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsedigits();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c608(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "exp",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "exp",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsedigits() {
    var s0, s1, s2,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "digits",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parsedigit();
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parsedigit();
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c609(s1);
    }
    s0 = s1;

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "digits",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "digits",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsedigit() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "digit",
      location: peg$computeLocation(startPos, startPos)
    });

    if (peg$c610.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c611); }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "digit",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "digit",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsehexDigit() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "hexDigit",
      location: peg$computeLocation(startPos, startPos)
    });

    if (peg$c612.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c613); }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "hexDigit",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "hexDigit",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsee() {
    var s0, s1, s2,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "e",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (peg$c614.test(input.charAt(peg$currPos))) {
      s1 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c615); }
    }
    if (s1 !== peg$FAILED) {
      if (peg$c616.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c617); }
      }
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c618(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "e",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "e",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_NULL() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_NULL",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c619) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c620); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_NULL",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_NULL",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_DEFAULT() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_DEFAULT",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c75) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c76); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_DEFAULT",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_DEFAULT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_NOT_NULL() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_NOT_NULL",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 8).toLowerCase() === peg$c621) {
      s1 = input.substr(peg$currPos, 8);
      peg$currPos += 8;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c622); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_NOT_NULL",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_NOT_NULL",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_TRUE() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_TRUE",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c623) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c624); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_TRUE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_TRUE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_TO() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_TO",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2).toLowerCase() === peg$c625) {
      s1 = input.substr(peg$currPos, 2);
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c626); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_TO",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_TO",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_FALSE() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_FALSE",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c627) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c628); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_FALSE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_FALSE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_SHOW() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_SHOW",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c629) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c630); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_SHOW",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_SHOW",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_DROP() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_DROP",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c631) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c632); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c633();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_DROP",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_DROP",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_USE() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_USE",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c634) {
      s1 = input.substr(peg$currPos, 3);
      peg$currPos += 3;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c635); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_USE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_USE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_ALTER() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_ALTER",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c636) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c637); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_ALTER",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_ALTER",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_SELECT() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_SELECT",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c638) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c639); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_SELECT",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_SELECT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_UPDATE() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_UPDATE",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c640) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c641); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_UPDATE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_UPDATE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_CREATE() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_CREATE",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c642) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c643); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_CREATE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_CREATE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_TEMPORARY() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_TEMPORARY",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 9).toLowerCase() === peg$c644) {
      s1 = input.substr(peg$currPos, 9);
      peg$currPos += 9;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c645); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c646();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_TEMPORARY",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_TEMPORARY",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_TEMP() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_TEMP",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c647) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c648); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c649();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_TEMP",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_TEMP",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_IF_NOT_EXISTS() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_IF_NOT_EXISTS",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 13).toLowerCase() === peg$c650) {
      s1 = input.substr(peg$currPos, 13);
      peg$currPos += 13;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c651); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_IF_NOT_EXISTS",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_IF_NOT_EXISTS",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_DELETE() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_DELETE",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c652) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c653); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_DELETE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_DELETE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_INSERT() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_INSERT",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c654) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c655); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_INSERT",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_INSERT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_RECURSIVE() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_RECURSIVE",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 9) === peg$c656) {
      s1 = peg$c656;
      peg$currPos += 9;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c657); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_RECURSIVE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_RECURSIVE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_REPLACE() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_REPLACE",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c658) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c659); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_REPLACE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_REPLACE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_RETURNING() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_RETURNING",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 9).toLowerCase() === peg$c660) {
      s1 = input.substr(peg$currPos, 9);
      peg$currPos += 9;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c661); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c662();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_RETURNING",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_RETURNING",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_RENAME() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_RENAME",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c663) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c664); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_RENAME",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_RENAME",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_IGNORE() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_IGNORE",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c486) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c487); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_IGNORE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_IGNORE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_EXPLAIN() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_EXPLAIN",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c665) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c666); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_EXPLAIN",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_EXPLAIN",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_PARTITION() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_PARTITION",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 9).toLowerCase() === peg$c667) {
      s1 = input.substr(peg$currPos, 9);
      peg$currPos += 9;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c668); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c669();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_PARTITION",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_PARTITION",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_INTO() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_INTO",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c670) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c671); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_INTO",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_INTO",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_FROM() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_FROM",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c672) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c673); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_FROM",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_FROM",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_SET() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_SET",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c188) {
      s1 = input.substr(peg$currPos, 3);
      peg$currPos += 3;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c189); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_SET",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_SET",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_LOCK() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_LOCK",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c106) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c107); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_LOCK",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_LOCK",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_AS() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_AS",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2).toLowerCase() === peg$c674) {
      s1 = input.substr(peg$currPos, 2);
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c675); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_AS",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_AS",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_TABLE() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_TABLE",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c676) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c677); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c678();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_TABLE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_TABLE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_DATABASE() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_DATABASE",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 8).toLowerCase() === peg$c679) {
      s1 = input.substr(peg$currPos, 8);
      peg$currPos += 8;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c680); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c681();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_DATABASE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_DATABASE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_SCHEME() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_SCHEME",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c682) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c683); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c684();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_SCHEME",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_SCHEME",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_SEQUENCE() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_SEQUENCE",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 8).toLowerCase() === peg$c685) {
      s1 = input.substr(peg$currPos, 8);
      peg$currPos += 8;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c686); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c687();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_SEQUENCE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_SEQUENCE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_TABLESPACE() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_TABLESPACE",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 10).toLowerCase() === peg$c688) {
      s1 = input.substr(peg$currPos, 10);
      peg$currPos += 10;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c689); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c690();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_TABLESPACE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_TABLESPACE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_COLLATE() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_COLLATE",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c193) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c194); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c691();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_COLLATE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_COLLATE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_ON() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_ON",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2).toLowerCase() === peg$c154) {
      s1 = input.substr(peg$currPos, 2);
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c155); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_ON",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_ON",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_LEFT() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_LEFT",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c692) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c693); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_LEFT",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_LEFT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_RIGHT() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_RIGHT",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c694) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c695); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_RIGHT",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_RIGHT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_FULL() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_FULL",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c696) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c697); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_FULL",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_FULL",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_CROSS() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_CROSS",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c698) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c699); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_CROSS",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_CROSS",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_NATURAL() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_NATURAL",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c700) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c701); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_NATURAL",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_NATURAL",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_INNER() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_INNER",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c702) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c703); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_INNER",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_INNER",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_JOIN() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_JOIN",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c704) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c705); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_JOIN",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_JOIN",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_OUTER() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_OUTER",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c706) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c707); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_OUTER",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_OUTER",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_UNION() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_UNION",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c708) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c709); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_UNION",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_UNION",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_MINUS() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_MINUS",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c710) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c711); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_MINUS",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_MINUS",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_INTERSECT() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_INTERSECT",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 9).toLowerCase() === peg$c712) {
      s1 = input.substr(peg$currPos, 9);
      peg$currPos += 9;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c713); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_INTERSECT",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_INTERSECT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_VALUES() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_VALUES",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c714) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c715); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_VALUES",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_VALUES",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_USING() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_USING",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c716) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c717); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_USING",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_USING",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_WHERE() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_WHERE",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c718) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c719); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_WHERE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_WHERE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_WITH() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_WITH",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c283) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c284); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_WITH",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_WITH",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_GROUP() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_GROUP",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c720) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c721); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_GROUP",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_GROUP",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_BY() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_BY",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2).toLowerCase() === peg$c722) {
      s1 = input.substr(peg$currPos, 2);
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c723); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_BY",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_BY",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_ORDER() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_ORDER",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c724) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c725); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_ORDER",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_ORDER",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_HAVING() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_HAVING",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c726) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c727); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_HAVING",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_HAVING",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_LIMIT() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_LIMIT",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c728) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c729); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_LIMIT",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_LIMIT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_OFFSET() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_OFFSET",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c730) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c731); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c732();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_OFFSET",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_OFFSET",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_ASC() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_ASC",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c733) {
      s1 = input.substr(peg$currPos, 3);
      peg$currPos += 3;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c734); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c735();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_ASC",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_ASC",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_DESC() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_DESC",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c736) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c737); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c738();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_DESC",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_DESC",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_ALL() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_ALL",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c739) {
      s1 = input.substr(peg$currPos, 3);
      peg$currPos += 3;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c740); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c741();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_ALL",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_ALL",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_DISTINCT() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_DISTINCT",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 8).toLowerCase() === peg$c742) {
      s1 = input.substr(peg$currPos, 8);
      peg$currPos += 8;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c743); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c744();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_DISTINCT",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_DISTINCT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_BETWEEN() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_BETWEEN",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c745) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c746); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c747();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_BETWEEN",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_BETWEEN",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_IN() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_IN",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2).toLowerCase() === peg$c225) {
      s1 = input.substr(peg$currPos, 2);
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c226); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c748();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_IN",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_IN",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_IS() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_IS",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2).toLowerCase() === peg$c749) {
      s1 = input.substr(peg$currPos, 2);
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c750); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c751();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_IS",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_IS",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_LIKE() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_LIKE",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c752) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c753); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c754();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_LIKE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_LIKE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_ILIKE() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_ILIKE",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c755) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c756); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c757();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_ILIKE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_ILIKE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_EXISTS() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_EXISTS",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c758) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c759); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c760();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_EXISTS",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_EXISTS",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_NOT() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_NOT",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c166) {
      s1 = input.substr(peg$currPos, 3);
      peg$currPos += 3;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c167); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c761();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_NOT",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_NOT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_AND() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_AND",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c762) {
      s1 = input.substr(peg$currPos, 3);
      peg$currPos += 3;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c763); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c764();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_AND",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_AND",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_OR() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_OR",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2).toLowerCase() === peg$c765) {
      s1 = input.substr(peg$currPos, 2);
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c766); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c767();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_OR",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_OR",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_ARRAY() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_ARRAY",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c768) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c769); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c770();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_ARRAY",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_ARRAY",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_ARRAY_AGG() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_ARRAY_AGG",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 9).toLowerCase() === peg$c771) {
      s1 = input.substr(peg$currPos, 9);
      peg$currPos += 9;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c772); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c773();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_ARRAY_AGG",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_ARRAY_AGG",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_COUNT() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_COUNT",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c774) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c775); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c776();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_COUNT",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_COUNT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_MAX() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_MAX",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c777) {
      s1 = input.substr(peg$currPos, 3);
      peg$currPos += 3;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c778); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c779();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_MAX",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_MAX",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_MIN() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_MIN",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c780) {
      s1 = input.substr(peg$currPos, 3);
      peg$currPos += 3;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c781); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c782();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_MIN",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_MIN",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_SUM() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_SUM",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c783) {
      s1 = input.substr(peg$currPos, 3);
      peg$currPos += 3;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c784); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c785();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_SUM",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_SUM",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_AVG() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_AVG",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c786) {
      s1 = input.substr(peg$currPos, 3);
      peg$currPos += 3;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c787); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c788();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_AVG",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_AVG",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_EXTRACT() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_EXTRACT",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c789) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c790); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c791();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_EXTRACT",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_EXTRACT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_CALL() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_CALL",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c792) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c793); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c794();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_CALL",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_CALL",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_CASE() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_CASE",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c795) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c796); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_CASE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_CASE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_WHEN() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_WHEN",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c797) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c798); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_WHEN",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_WHEN",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_THEN() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_THEN",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c799) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c800); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_THEN",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_THEN",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_ELSE() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_ELSE",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c801) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c802); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_ELSE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_ELSE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_END() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_END",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c803) {
      s1 = input.substr(peg$currPos, 3);
      peg$currPos += 3;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c804); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_END",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_END",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_CAST() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_CAST",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c805) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c806); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_CAST",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_CAST",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_BOOL() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_BOOL",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c807) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c808); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c809();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_BOOL",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_BOOL",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_BOOLEAN() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_BOOLEAN",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c810) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c811); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c812();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_BOOLEAN",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_BOOLEAN",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_CHAR() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_CHAR",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c813) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c814); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c815();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_CHAR",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_CHAR",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_VARCHAR() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_VARCHAR",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c816) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c817); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c818();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_VARCHAR",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_VARCHAR",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_NUMERIC() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_NUMERIC",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c819) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c820); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c821();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_NUMERIC",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_NUMERIC",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_DECIMAL() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_DECIMAL",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c822) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c823); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c824();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_DECIMAL",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_DECIMAL",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_SIGNED() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_SIGNED",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c825) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c826); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c827();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_SIGNED",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_SIGNED",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_UNSIGNED() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_UNSIGNED",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 8).toLowerCase() === peg$c828) {
      s1 = input.substr(peg$currPos, 8);
      peg$currPos += 8;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c829); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c830();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_UNSIGNED",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_UNSIGNED",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_INT() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_INT",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c831) {
      s1 = input.substr(peg$currPos, 3);
      peg$currPos += 3;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c832); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c833();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_INT",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_INT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_ZEROFILL() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_ZEROFILL",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 8).toLowerCase() === peg$c834) {
      s1 = input.substr(peg$currPos, 8);
      peg$currPos += 8;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c835); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c836();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_ZEROFILL",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_ZEROFILL",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_INTEGER() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_INTEGER",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c837) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c838); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c839();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_INTEGER",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_INTEGER",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_JSON() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_JSON",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c840) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c841); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c842();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_JSON",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_JSON",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_JSONB() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_JSONB",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c843) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c844); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c845();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_JSONB",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_JSONB",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_GEOMETRY() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_GEOMETRY",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 8).toLowerCase() === peg$c846) {
      s1 = input.substr(peg$currPos, 8);
      peg$currPos += 8;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c847); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c848();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_GEOMETRY",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_GEOMETRY",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_SMALLINT() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_SMALLINT",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 8).toLowerCase() === peg$c849) {
      s1 = input.substr(peg$currPos, 8);
      peg$currPos += 8;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c850); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c851();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_SMALLINT",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_SMALLINT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_TINYINT() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_TINYINT",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c852) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c853); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c854();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_TINYINT",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_TINYINT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_TINYTEXT() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_TINYTEXT",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 8).toLowerCase() === peg$c855) {
      s1 = input.substr(peg$currPos, 8);
      peg$currPos += 8;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c856); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c857();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_TINYTEXT",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_TINYTEXT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_TEXT() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_TEXT",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c858) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c859); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c860();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_TEXT",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_TEXT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_MEDIUMTEXT() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_MEDIUMTEXT",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 10).toLowerCase() === peg$c861) {
      s1 = input.substr(peg$currPos, 10);
      peg$currPos += 10;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c862); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c863();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_MEDIUMTEXT",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_MEDIUMTEXT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_LONGTEXT() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_LONGTEXT",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 8).toLowerCase() === peg$c864) {
      s1 = input.substr(peg$currPos, 8);
      peg$currPos += 8;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c865); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c866();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_LONGTEXT",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_LONGTEXT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_BIGINT() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_BIGINT",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c867) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c868); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c869();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_BIGINT",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_BIGINT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_FLOAT() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_FLOAT",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c870) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c871); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c872();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_FLOAT",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_FLOAT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_DOUBLE() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_DOUBLE",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c873) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c874); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c875();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_DOUBLE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_DOUBLE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_DATE() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_DATE",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c876) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c877); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c878();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_DATE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_DATE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_DATETIME() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_DATETIME",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 8).toLowerCase() === peg$c879) {
      s1 = input.substr(peg$currPos, 8);
      peg$currPos += 8;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c880); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c881();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_DATETIME",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_DATETIME",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_ROWS() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_ROWS",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c882) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c883); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c884();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_ROWS",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_ROWS",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_RANGE() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_RANGE",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c885) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c886); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c887();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_RANGE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_RANGE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_TIME() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_TIME",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c888) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c889); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c890();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_TIME",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_TIME",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_TIMESTAMP() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_TIMESTAMP",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 9).toLowerCase() === peg$c891) {
      s1 = input.substr(peg$currPos, 9);
      peg$currPos += 9;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c892); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c893();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_TIMESTAMP",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_TIMESTAMP",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_TRUNCATE() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_TRUNCATE",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 8).toLowerCase() === peg$c894) {
      s1 = input.substr(peg$currPos, 8);
      peg$currPos += 8;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c895); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c896();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_TRUNCATE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_TRUNCATE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_USER() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_USER",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c897) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c898); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c899();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_USER",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_USER",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_UUID() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_UUID",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c900) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c901); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c902();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_UUID",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_UUID",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_CURRENT_DATE() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_CURRENT_DATE",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 12).toLowerCase() === peg$c903) {
      s1 = input.substr(peg$currPos, 12);
      peg$currPos += 12;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c904); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c905();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_CURRENT_DATE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_CURRENT_DATE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_ADD_DATE() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_ADD_DATE",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c906) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c907); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c908();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_ADD_DATE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_ADD_DATE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_INTERVAL() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_INTERVAL",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 8).toLowerCase() === peg$c909) {
      s1 = input.substr(peg$currPos, 8);
      peg$currPos += 8;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c910); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c911();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_INTERVAL",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_INTERVAL",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_UNIT_YEAR() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_UNIT_YEAR",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c537) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c538); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c912();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_UNIT_YEAR",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_UNIT_YEAR",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_UNIT_MONTH() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_UNIT_MONTH",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c523) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c524); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c913();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_UNIT_MONTH",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_UNIT_MONTH",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_UNIT_DAY() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_UNIT_DAY",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c499) {
      s1 = input.substr(peg$currPos, 3);
      peg$currPos += 3;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c500); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c914();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_UNIT_DAY",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_UNIT_DAY",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_UNIT_HOUR() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_UNIT_HOUR",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c509) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c510); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c915();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_UNIT_HOUR",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_UNIT_HOUR",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_UNIT_MINUTE() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_UNIT_MINUTE",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c521) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c522); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c916();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_UNIT_MINUTE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_UNIT_MINUTE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_UNIT_SECOND() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_UNIT_SECOND",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c527) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c528); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c917();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_UNIT_SECOND",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_UNIT_SECOND",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_CURRENT_TIME() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_CURRENT_TIME",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 12).toLowerCase() === peg$c918) {
      s1 = input.substr(peg$currPos, 12);
      peg$currPos += 12;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c919); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c920();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_CURRENT_TIME",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_CURRENT_TIME",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_CURRENT_TIMESTAMP() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_CURRENT_TIMESTAMP",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 17).toLowerCase() === peg$c921) {
      s1 = input.substr(peg$currPos, 17);
      peg$currPos += 17;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c922); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c923();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_CURRENT_TIMESTAMP",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_CURRENT_TIMESTAMP",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_CURRENT_USER() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_CURRENT_USER",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 12).toLowerCase() === peg$c924) {
      s1 = input.substr(peg$currPos, 12);
      peg$currPos += 12;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c925); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c926();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_CURRENT_USER",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_CURRENT_USER",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_SESSION_USER() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_SESSION_USER",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 12).toLowerCase() === peg$c927) {
      s1 = input.substr(peg$currPos, 12);
      peg$currPos += 12;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c928); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c929();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_SESSION_USER",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_SESSION_USER",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_SYSTEM_USER() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_SYSTEM_USER",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 11).toLowerCase() === peg$c930) {
      s1 = input.substr(peg$currPos, 11);
      peg$currPos += 11;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c931); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c932();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_SYSTEM_USER",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_SYSTEM_USER",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_GLOBAL() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_GLOBAL",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c933) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c934); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c935();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_GLOBAL",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_GLOBAL",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_SESSION() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_SESSION",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c936) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c937); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c938();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_SESSION",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_SESSION",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_LOCAL() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_LOCAL",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c939) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c940); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c941();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_LOCAL",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_LOCAL",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_PERSIST() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_PERSIST",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c942) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c943); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c944();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_PERSIST",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_PERSIST",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_PERSIST_ONLY() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_PERSIST_ONLY",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 12).toLowerCase() === peg$c945) {
      s1 = input.substr(peg$currPos, 12);
      peg$currPos += 12;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c946); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c947();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_PERSIST_ONLY",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_PERSIST_ONLY",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_CUBE() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_CUBE",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c948) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c949); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c950();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_CUBE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_CUBE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_ROLLUP() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_ROLLUP",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c951) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c952); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c953();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_ROLLUP",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_ROLLUP",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_GROUPING() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_GROUPING",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 8).toLowerCase() === peg$c954) {
      s1 = input.substr(peg$currPos, 8);
      peg$currPos += 8;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c955); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c956();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_GROUPING",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_GROUPING",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_SETS() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_SETS",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c957) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c958); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c959();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_SETS",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_SETS",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_VAR__PRE_AT() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_VAR__PRE_AT",
      location: peg$computeLocation(startPos, startPos)
    });

    if (input.charCodeAt(peg$currPos) === 64) {
      s0 = peg$c960;
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c961); }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_VAR__PRE_AT",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_VAR__PRE_AT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_VAR__PRE_AT_AT() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_VAR__PRE_AT_AT",
      location: peg$computeLocation(startPos, startPos)
    });

    if (input.substr(peg$currPos, 2) === peg$c962) {
      s0 = peg$c962;
      peg$currPos += 2;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c963); }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_VAR__PRE_AT_AT",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_VAR__PRE_AT_AT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_VAR_PRE_DOLLAR() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_VAR_PRE_DOLLAR",
      location: peg$computeLocation(startPos, startPos)
    });

    if (input.charCodeAt(peg$currPos) === 36) {
      s0 = peg$c423;
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c424); }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_VAR_PRE_DOLLAR",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_VAR_PRE_DOLLAR",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_VAR_PRE() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_VAR_PRE",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$parseKW_VAR__PRE_AT_AT();
    if (s0 === peg$FAILED) {
      s0 = peg$parseKW_VAR__PRE_AT();
      if (s0 === peg$FAILED) {
        s0 = peg$parseKW_VAR_PRE_DOLLAR();
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_VAR_PRE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_VAR_PRE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_RETURN() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_RETURN",
      location: peg$computeLocation(startPos, startPos)
    });

    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c964) {
      s0 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c965); }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_RETURN",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_RETURN",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_ASSIGN() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_ASSIGN",
      location: peg$computeLocation(startPos, startPos)
    });

    if (input.substr(peg$currPos, 2) === peg$c966) {
      s0 = peg$c966;
      peg$currPos += 2;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c967); }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_ASSIGN",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_ASSIGN",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_DOUBLE_COLON() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_DOUBLE_COLON",
      location: peg$computeLocation(startPos, startPos)
    });

    if (input.substr(peg$currPos, 2) === peg$c968) {
      s0 = peg$c968;
      peg$currPos += 2;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c969); }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_DOUBLE_COLON",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_DOUBLE_COLON",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_ASSIGIN_EQUAL() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_ASSIGIN_EQUAL",
      location: peg$computeLocation(startPos, startPos)
    });

    if (input.charCodeAt(peg$currPos) === 61) {
      s0 = peg$c343;
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c344); }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_ASSIGIN_EQUAL",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_ASSIGIN_EQUAL",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_DUAL() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_DUAL",
      location: peg$computeLocation(startPos, startPos)
    });

    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c970) {
      s0 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c971); }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_DUAL",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_DUAL",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_ADD() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_ADD",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c972) {
      s1 = input.substr(peg$currPos, 3);
      peg$currPos += 3;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c973); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c974();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_ADD",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_ADD",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_COLUMN() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_COLUMN",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c975) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c976); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c977();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_COLUMN",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_COLUMN",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_INDEX() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_INDEX",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c978) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c979); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c980();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_INDEX",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_INDEX",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_KEY() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_KEY",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c63) {
      s1 = input.substr(peg$currPos, 3);
      peg$currPos += 3;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c64); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c981();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_KEY",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_KEY",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_FULLTEXT() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_FULLTEXT",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 8).toLowerCase() === peg$c982) {
      s1 = input.substr(peg$currPos, 8);
      peg$currPos += 8;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c983); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c984();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_FULLTEXT",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_FULLTEXT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_SPATIAL() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_SPATIAL",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c985) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c986); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c987();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_SPATIAL",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_SPATIAL",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_UNIQUE() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_UNIQUE",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c59) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c60); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c988();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_UNIQUE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_UNIQUE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_KEY_BLOCK_SIZE() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_KEY_BLOCK_SIZE",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 14).toLowerCase() === peg$c198) {
      s1 = input.substr(peg$currPos, 14);
      peg$currPos += 14;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c199); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c989();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_KEY_BLOCK_SIZE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_KEY_BLOCK_SIZE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_COMMENT() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_COMMENT",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c990) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c991); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c992();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_COMMENT",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_COMMENT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_CONSTRAINT() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_CONSTRAINT",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 10).toLowerCase() === peg$c993) {
      s1 = input.substr(peg$currPos, 10);
      peg$currPos += 10;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c994); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c995();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_CONSTRAINT",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_CONSTRAINT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_CONCURRENTLY() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_CONCURRENTLY",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 12).toLowerCase() === peg$c996) {
      s1 = input.substr(peg$currPos, 12);
      peg$currPos += 12;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c997); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c998();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_CONCURRENTLY",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_CONCURRENTLY",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseKW_REFERENCES() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "KW_REFERENCES",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 10).toLowerCase() === peg$c999) {
      s1 = input.substr(peg$currPos, 10);
      peg$currPos += 10;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c1000); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseident_start();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c1001();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "KW_REFERENCES",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "KW_REFERENCES",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseOPT_SQL_CALC_FOUND_ROWS() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "OPT_SQL_CALC_FOUND_ROWS",
      location: peg$computeLocation(startPos, startPos)
    });

    if (input.substr(peg$currPos, 19).toLowerCase() === peg$c1002) {
      s0 = input.substr(peg$currPos, 19);
      peg$currPos += 19;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c1003); }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "OPT_SQL_CALC_FOUND_ROWS",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "OPT_SQL_CALC_FOUND_ROWS",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseOPT_SQL_CACHE() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "OPT_SQL_CACHE",
      location: peg$computeLocation(startPos, startPos)
    });

    if (input.substr(peg$currPos, 9).toLowerCase() === peg$c1004) {
      s0 = input.substr(peg$currPos, 9);
      peg$currPos += 9;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c1005); }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "OPT_SQL_CACHE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "OPT_SQL_CACHE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseOPT_SQL_NO_CACHE() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "OPT_SQL_NO_CACHE",
      location: peg$computeLocation(startPos, startPos)
    });

    if (input.substr(peg$currPos, 12).toLowerCase() === peg$c1006) {
      s0 = input.substr(peg$currPos, 12);
      peg$currPos += 12;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c1007); }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "OPT_SQL_NO_CACHE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "OPT_SQL_NO_CACHE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseOPT_SQL_SMALL_RESULT() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "OPT_SQL_SMALL_RESULT",
      location: peg$computeLocation(startPos, startPos)
    });

    if (input.substr(peg$currPos, 16).toLowerCase() === peg$c1008) {
      s0 = input.substr(peg$currPos, 16);
      peg$currPos += 16;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c1009); }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "OPT_SQL_SMALL_RESULT",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "OPT_SQL_SMALL_RESULT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseOPT_SQL_BIG_RESULT() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "OPT_SQL_BIG_RESULT",
      location: peg$computeLocation(startPos, startPos)
    });

    if (input.substr(peg$currPos, 14).toLowerCase() === peg$c1010) {
      s0 = input.substr(peg$currPos, 14);
      peg$currPos += 14;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c1011); }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "OPT_SQL_BIG_RESULT",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "OPT_SQL_BIG_RESULT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseOPT_SQL_BUFFER_RESULT() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "OPT_SQL_BUFFER_RESULT",
      location: peg$computeLocation(startPos, startPos)
    });

    if (input.substr(peg$currPos, 17).toLowerCase() === peg$c1012) {
      s0 = input.substr(peg$currPos, 17);
      peg$currPos += 17;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c1013); }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "OPT_SQL_BUFFER_RESULT",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "OPT_SQL_BUFFER_RESULT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseDOT() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "DOT",
      location: peg$computeLocation(startPos, startPos)
    });

    if (input.charCodeAt(peg$currPos) === 46) {
      s0 = peg$c605;
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c606); }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "DOT",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "DOT",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseCOMMA() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "COMMA",
      location: peg$computeLocation(startPos, startPos)
    });

    if (input.charCodeAt(peg$currPos) === 44) {
      s0 = peg$c1014;
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c1015); }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "COMMA",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "COMMA",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseSTAR() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "STAR",
      location: peg$computeLocation(startPos, startPos)
    });

    if (input.charCodeAt(peg$currPos) === 42) {
      s0 = peg$c415;
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c416); }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "STAR",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "STAR",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsePLUS() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "PLUS",
      location: peg$computeLocation(startPos, startPos)
    });

    if (input.charCodeAt(peg$currPos) === 43) {
      s0 = peg$c410;
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c411); }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "PLUS",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "PLUS",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseLPAREN() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "LPAREN",
      location: peg$computeLocation(startPos, startPos)
    });

    if (input.charCodeAt(peg$currPos) === 40) {
      s0 = peg$c248;
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c249); }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "LPAREN",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "LPAREN",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseRPAREN() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "RPAREN",
      location: peg$computeLocation(startPos, startPos)
    });

    if (input.charCodeAt(peg$currPos) === 41) {
      s0 = peg$c250;
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c251); }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "RPAREN",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "RPAREN",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseLBRAKE() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "LBRAKE",
      location: peg$computeLocation(startPos, startPos)
    });

    if (input.charCodeAt(peg$currPos) === 91) {
      s0 = peg$c1016;
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c1017); }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "LBRAKE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "LBRAKE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseRBRAKE() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "RBRAKE",
      location: peg$computeLocation(startPos, startPos)
    });

    if (input.charCodeAt(peg$currPos) === 93) {
      s0 = peg$c1018;
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c1019); }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "RBRAKE",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "RBRAKE",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseSEMICOLON() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "SEMICOLON",
      location: peg$computeLocation(startPos, startPos)
    });

    if (input.charCodeAt(peg$currPos) === 59) {
      s0 = peg$c1020;
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c1021); }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "SEMICOLON",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "SEMICOLON",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseSINGLE_ARROW() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "SINGLE_ARROW",
      location: peg$computeLocation(startPos, startPos)
    });

    if (input.substr(peg$currPos, 2) === peg$c1022) {
      s0 = peg$c1022;
      peg$currPos += 2;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c1023); }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "SINGLE_ARROW",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "SINGLE_ARROW",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseDOUBLE_ARROW() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "DOUBLE_ARROW",
      location: peg$computeLocation(startPos, startPos)
    });

    if (input.substr(peg$currPos, 3) === peg$c1024) {
      s0 = peg$c1024;
      peg$currPos += 3;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c1025); }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "DOUBLE_ARROW",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "DOUBLE_ARROW",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseWELL_ARROW() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "WELL_ARROW",
      location: peg$computeLocation(startPos, startPos)
    });

    if (input.substr(peg$currPos, 2) === peg$c1026) {
      s0 = peg$c1026;
      peg$currPos += 2;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c1027); }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "WELL_ARROW",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "WELL_ARROW",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseDOUBLE_WELL_ARROW() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "DOUBLE_WELL_ARROW",
      location: peg$computeLocation(startPos, startPos)
    });

    if (input.substr(peg$currPos, 3) === peg$c1028) {
      s0 = peg$c1028;
      peg$currPos += 3;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c1029); }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "DOUBLE_WELL_ARROW",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "DOUBLE_WELL_ARROW",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseOPERATOR_CONCATENATION() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "OPERATOR_CONCATENATION",
      location: peg$computeLocation(startPos, startPos)
    });

    if (input.substr(peg$currPos, 2) === peg$c1030) {
      s0 = peg$c1030;
      peg$currPos += 2;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c1031); }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "OPERATOR_CONCATENATION",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "OPERATOR_CONCATENATION",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseOPERATOR_AND() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "OPERATOR_AND",
      location: peg$computeLocation(startPos, startPos)
    });

    if (input.substr(peg$currPos, 2) === peg$c1032) {
      s0 = peg$c1032;
      peg$currPos += 2;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c1033); }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "OPERATOR_AND",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "OPERATOR_AND",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseLOGIC_OPERATOR() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "LOGIC_OPERATOR",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$parseOPERATOR_CONCATENATION();
    if (s0 === peg$FAILED) {
      s0 = peg$parseOPERATOR_AND();
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "LOGIC_OPERATOR",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "LOGIC_OPERATOR",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parse__() {
    var s0, s1,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "__",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = [];
    s1 = peg$parsewhitespace();
    if (s1 === peg$FAILED) {
      s1 = peg$parsecomment();
    }
    while (s1 !== peg$FAILED) {
      s0.push(s1);
      s1 = peg$parsewhitespace();
      if (s1 === peg$FAILED) {
        s1 = peg$parsecomment();
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "__",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "__",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parse___() {
    var s0, s1,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "___",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = [];
    s1 = peg$parsewhitespace();
    if (s1 === peg$FAILED) {
      s1 = peg$parsecomment();
    }
    if (s1 !== peg$FAILED) {
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        s1 = peg$parsewhitespace();
        if (s1 === peg$FAILED) {
          s1 = peg$parsecomment();
        }
      }
    } else {
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "___",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "___",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecomment() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "comment",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$parseblock_comment();
    if (s0 === peg$FAILED) {
      s0 = peg$parseline_comment();
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "comment",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "comment",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseblock_comment() {
    var s0, s1, s2, s3, s4, s5,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "block_comment",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c1034) {
      s1 = peg$c1034;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c1035); }
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$currPos;
      peg$silentFails++;
      if (input.substr(peg$currPos, 2) === peg$c1036) {
        s5 = peg$c1036;
        peg$currPos += 2;
      } else {
        s5 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c1037); }
      }
      peg$silentFails--;
      if (s5 === peg$FAILED) {
        s4 = void 0;
      } else {
        peg$currPos = s4;
        s4 = peg$FAILED;
      }
      if (s4 !== peg$FAILED) {
        s5 = peg$parsechar();
        if (s5 !== peg$FAILED) {
          s4 = [s4, s5];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$currPos;
        peg$silentFails++;
        if (input.substr(peg$currPos, 2) === peg$c1036) {
          s5 = peg$c1036;
          peg$currPos += 2;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c1037); }
        }
        peg$silentFails--;
        if (s5 === peg$FAILED) {
          s4 = void 0;
        } else {
          peg$currPos = s4;
          s4 = peg$FAILED;
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parsechar();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        if (input.substr(peg$currPos, 2) === peg$c1036) {
          s3 = peg$c1036;
          peg$currPos += 2;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c1037); }
        }
        if (s3 !== peg$FAILED) {
          s1 = [s1, s2, s3];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "block_comment",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "block_comment",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseline_comment() {
    var s0, s1, s2, s3, s4, s5,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "line_comment",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c1038) {
      s1 = peg$c1038;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c1039); }
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$currPos;
      peg$silentFails++;
      s5 = peg$parseEOL();
      peg$silentFails--;
      if (s5 === peg$FAILED) {
        s4 = void 0;
      } else {
        peg$currPos = s4;
        s4 = peg$FAILED;
      }
      if (s4 !== peg$FAILED) {
        s5 = peg$parsechar();
        if (s5 !== peg$FAILED) {
          s4 = [s4, s5];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$currPos;
        peg$silentFails++;
        s5 = peg$parseEOL();
        peg$silentFails--;
        if (s5 === peg$FAILED) {
          s4 = void 0;
        } else {
          peg$currPos = s4;
          s4 = peg$FAILED;
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parsechar();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "line_comment",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "line_comment",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsepound_sign_comment() {
    var s0, s1, s2, s3, s4, s5,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "pound_sign_comment",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 35) {
      s1 = peg$c1040;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c1041); }
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$currPos;
      peg$silentFails++;
      s5 = peg$parseEOL();
      peg$silentFails--;
      if (s5 === peg$FAILED) {
        s4 = void 0;
      } else {
        peg$currPos = s4;
        s4 = peg$FAILED;
      }
      if (s4 !== peg$FAILED) {
        s5 = peg$parsechar();
        if (s5 !== peg$FAILED) {
          s4 = [s4, s5];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$currPos;
        peg$silentFails++;
        s5 = peg$parseEOL();
        peg$silentFails--;
        if (s5 === peg$FAILED) {
          s4 = void 0;
        } else {
          peg$currPos = s4;
          s4 = peg$FAILED;
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parsechar();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "pound_sign_comment",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "pound_sign_comment",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsekeyword_comment() {
    var s0, s1, s2, s3, s4, s5,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "keyword_comment",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_COMMENT();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseKW_ASSIGIN_EQUAL();
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseliteral_string();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c1042(s1, s3, s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "keyword_comment",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "keyword_comment",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsechar() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "char",
      location: peg$computeLocation(startPos, startPos)
    });

    if (input.length > peg$currPos) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c1043); }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "char",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "char",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseinterval_unit() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "interval_unit",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$parseKW_UNIT_YEAR();
    if (s0 === peg$FAILED) {
      s0 = peg$parseKW_UNIT_MONTH();
      if (s0 === peg$FAILED) {
        s0 = peg$parseKW_UNIT_DAY();
        if (s0 === peg$FAILED) {
          s0 = peg$parseKW_UNIT_HOUR();
          if (s0 === peg$FAILED) {
            s0 = peg$parseKW_UNIT_MINUTE();
            if (s0 === peg$FAILED) {
              s0 = peg$parseKW_UNIT_SECOND();
            }
          }
        }
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "interval_unit",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "interval_unit",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsewhitespace() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "whitespace",
      location: peg$computeLocation(startPos, startPos)
    });

    if (peg$c1044.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c1045); }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "whitespace",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "whitespace",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseEOL() {
    var s0, s1,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "EOL",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$parseEOF();
    if (s0 === peg$FAILED) {
      s0 = [];
      if (peg$c596.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c597); }
      }
      if (s1 !== peg$FAILED) {
        while (s1 !== peg$FAILED) {
          s0.push(s1);
          if (peg$c596.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c597); }
          }
        }
      } else {
        s0 = peg$FAILED;
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "EOL",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "EOL",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseEOF() {
    var s0, s1,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "EOF",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    peg$silentFails++;
    if (input.length > peg$currPos) {
      s1 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c1043); }
    }
    peg$silentFails--;
    if (s1 === peg$FAILED) {
      s0 = void 0;
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "EOF",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "EOF",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseproc_stmts() {
    var s0, s1,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "proc_stmts",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = [];
    s1 = peg$parseproc_stmt();
    while (s1 !== peg$FAILED) {
      s0.push(s1);
      s1 = peg$parseproc_stmt();
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "proc_stmts",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "proc_stmts",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseproc_stmt() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "proc_stmt",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    peg$savedPos = peg$currPos;
    s1 = peg$c1046();
    if (s1) {
      s1 = void 0;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseassign_stmt();
        if (s3 === peg$FAILED) {
          s3 = peg$parsereturn_stmt();
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c1047(s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "proc_stmt",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "proc_stmt",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseassign_stmt() {
    var s0, s1, s2, s3, s4, s5,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "assign_stmt",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parsevar_decl();
    if (s1 === peg$FAILED) {
      s1 = peg$parsewithout_prefix_var_decl();
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseKW_ASSIGN();
        if (s3 === peg$FAILED) {
          s3 = peg$parseKW_ASSIGIN_EQUAL();
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseproc_expr();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c1048(s1, s3, s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "assign_stmt",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "assign_stmt",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsereturn_stmt() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "return_stmt",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_RETURN();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseproc_expr();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c1049(s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "return_stmt",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "return_stmt",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseproc_expr() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "proc_expr",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$parseselect_stmt();
    if (s0 === peg$FAILED) {
      s0 = peg$parseproc_join();
      if (s0 === peg$FAILED) {
        s0 = peg$parseproc_additive_expr();
        if (s0 === peg$FAILED) {
          s0 = peg$parseproc_array();
        }
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "proc_expr",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "proc_expr",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseproc_additive_expr() {
    var s0, s1, s2, s3, s4, s5, s6, s7,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "proc_additive_expr",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseproc_multiplicative_expr();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse__();
      if (s4 !== peg$FAILED) {
        s5 = peg$parseadditive_operator();
        if (s5 !== peg$FAILED) {
          s6 = peg$parse__();
          if (s6 !== peg$FAILED) {
            s7 = peg$parseproc_multiplicative_expr();
            if (s7 !== peg$FAILED) {
              s4 = [s4, s5, s6, s7];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseadditive_operator();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseproc_multiplicative_expr();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c367(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "proc_additive_expr",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "proc_additive_expr",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseproc_multiplicative_expr() {
    var s0, s1, s2, s3, s4, s5, s6, s7,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "proc_multiplicative_expr",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseproc_primary();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse__();
      if (s4 !== peg$FAILED) {
        s5 = peg$parsemultiplicative_operator();
        if (s5 !== peg$FAILED) {
          s6 = peg$parse__();
          if (s6 !== peg$FAILED) {
            s7 = peg$parseproc_primary();
            if (s7 !== peg$FAILED) {
              s4 = [s4, s5, s6, s7];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s5 = peg$parsemultiplicative_operator();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseproc_primary();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c367(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "proc_multiplicative_expr",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "proc_multiplicative_expr",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseproc_join() {
    var s0, s1, s2, s3, s4, s5, s6, s7,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "proc_join",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parsevar_decl();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parsejoin_op();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parsevar_decl();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseon_clause();
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c1050(s1, s3, s5, s7);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "proc_join",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "proc_join",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseproc_primary() {
    var s0, s1, s2, s3, s4, s5,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "proc_primary",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$parseliteral();
    if (s0 === peg$FAILED) {
      s0 = peg$parsevar_decl();
      if (s0 === peg$FAILED) {
        s0 = peg$parseproc_func_call();
        if (s0 === peg$FAILED) {
          s0 = peg$parseparam();
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseLPAREN();
            if (s1 !== peg$FAILED) {
              s2 = peg$parse__();
              if (s2 !== peg$FAILED) {
                s3 = peg$parseproc_additive_expr();
                if (s3 !== peg$FAILED) {
                  s4 = peg$parse__();
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parseRPAREN();
                    if (s5 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c1051(s3);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
        }
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "proc_primary",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "proc_primary",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseproc_func_name() {
    var s0, s1, s2, s3, s4, s5, s6,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "proc_func_name",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseident();
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      s3 = peg$parse__();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseDOT();
        if (s4 !== peg$FAILED) {
          s5 = peg$parse__();
          if (s5 !== peg$FAILED) {
            s6 = peg$parseident();
            if (s6 !== peg$FAILED) {
              s3 = [s3, s4, s5, s6];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c1052(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "proc_func_name",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "proc_func_name",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseproc_func_call() {
    var s0, s1, s2, s3, s4, s5, s6, s7,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "proc_func_call",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseproc_func_name();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseLPAREN();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseproc_primary_list();
            if (s5 === peg$FAILED) {
              s5 = null;
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseRPAREN();
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c1053(s1, s5);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseproc_func_name();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c1054(s1);
      }
      s0 = s1;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "proc_func_call",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "proc_func_call",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseproc_primary_list() {
    var s0, s1, s2, s3, s4, s5, s6, s7,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "proc_primary_list",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseproc_primary();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse__();
      if (s4 !== peg$FAILED) {
        s5 = peg$parseCOMMA();
        if (s5 !== peg$FAILED) {
          s6 = peg$parse__();
          if (s6 !== peg$FAILED) {
            s7 = peg$parseproc_primary();
            if (s7 !== peg$FAILED) {
              s4 = [s4, s5, s6, s7];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseCOMMA();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseproc_primary();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c1055(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "proc_primary_list",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "proc_primary_list",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseproc_array() {
    var s0, s1, s2, s3, s4, s5,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "proc_array",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseLBRAKE();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseproc_primary_list();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseRBRAKE();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c1056(s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "proc_array",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "proc_array",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsevar_decl() {
    var s0, s1, s2,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "var_decl",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_VAR_PRE();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsewithout_prefix_var_decl();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c1057(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "var_decl",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "var_decl",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsewithout_prefix_var_decl() {
    var s0, s1, s2,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "without_prefix_var_decl",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseident_name();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsemem_chain();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c1058(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "without_prefix_var_decl",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "without_prefix_var_decl",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsemem_chain() {
    var s0, s1, s2, s3, s4,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "mem_chain",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 46) {
      s3 = peg$c605;
      peg$currPos++;
    } else {
      s3 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c606); }
    }
    if (s3 !== peg$FAILED) {
      s4 = peg$parseident_name();
      if (s4 !== peg$FAILED) {
        s3 = [s3, s4];
        s2 = s3;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    } else {
      peg$currPos = s2;
      s2 = peg$FAILED;
    }
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 46) {
        s3 = peg$c605;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c606); }
      }
      if (s3 !== peg$FAILED) {
        s4 = peg$parseident_name();
        if (s4 !== peg$FAILED) {
          s3 = [s3, s4];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c1059(s1);
    }
    s0 = s1;

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "mem_chain",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "mem_chain",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsedata_type() {
    var s0,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "data_type",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$parsecharacter_string_type();
    if (s0 === peg$FAILED) {
      s0 = peg$parsenumeric_type();
      if (s0 === peg$FAILED) {
        s0 = peg$parsedatetime_type();
        if (s0 === peg$FAILED) {
          s0 = peg$parsejson_type();
          if (s0 === peg$FAILED) {
            s0 = peg$parsegeometry_type();
            if (s0 === peg$FAILED) {
              s0 = peg$parsetext_type();
              if (s0 === peg$FAILED) {
                s0 = peg$parseuuid_type();
                if (s0 === peg$FAILED) {
                  s0 = peg$parseboolean_type();
                }
              }
            }
          }
        }
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "data_type",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "data_type",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseboolean_type() {
    var s0, s1,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "boolean_type",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_BOOL();
    if (s1 === peg$FAILED) {
      s1 = peg$parseKW_BOOLEAN();
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c1060(s1);
    }
    s0 = s1;

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "boolean_type",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "boolean_type",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsecharacter_string_type() {
    var s0, s1, s2, s3, s4, s5, s6, s7,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "character_string_type",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_CHAR();
    if (s1 === peg$FAILED) {
      s1 = peg$parseKW_VARCHAR();
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseLPAREN();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = [];
            if (peg$c610.test(input.charAt(peg$currPos))) {
              s6 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c611); }
            }
            if (s6 !== peg$FAILED) {
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                if (peg$c610.test(input.charAt(peg$currPos))) {
                  s6 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c611); }
                }
              }
            } else {
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseRPAREN();
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c1061(s1, s5);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseKW_CHAR();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c1062(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseKW_VARCHAR();
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c1063(s1);
        }
        s0 = s1;
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "character_string_type",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "character_string_type",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsenumeric_type_suffix() {
    var s0, s1, s2, s3,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "numeric_type_suffix",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_UNSIGNED();
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseKW_ZEROFILL();
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c1064(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "numeric_type_suffix",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "numeric_type_suffix",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsenumeric_type() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "numeric_type",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_NUMERIC();
    if (s1 === peg$FAILED) {
      s1 = peg$parseKW_DECIMAL();
      if (s1 === peg$FAILED) {
        s1 = peg$parseKW_INT();
        if (s1 === peg$FAILED) {
          s1 = peg$parseKW_INTEGER();
          if (s1 === peg$FAILED) {
            s1 = peg$parseKW_SMALLINT();
            if (s1 === peg$FAILED) {
              s1 = peg$parseKW_TINYINT();
              if (s1 === peg$FAILED) {
                s1 = peg$parseKW_BIGINT();
                if (s1 === peg$FAILED) {
                  s1 = peg$parseKW_FLOAT();
                  if (s1 === peg$FAILED) {
                    s1 = peg$parseKW_DOUBLE();
                  }
                }
              }
            }
          }
        }
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseLPAREN();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = [];
            if (peg$c610.test(input.charAt(peg$currPos))) {
              s6 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c611); }
            }
            if (s6 !== peg$FAILED) {
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                if (peg$c610.test(input.charAt(peg$currPos))) {
                  s6 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c611); }
                }
              }
            } else {
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$currPos;
                s8 = peg$parseCOMMA();
                if (s8 !== peg$FAILED) {
                  s9 = peg$parse__();
                  if (s9 !== peg$FAILED) {
                    s10 = [];
                    if (peg$c610.test(input.charAt(peg$currPos))) {
                      s11 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s11 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c611); }
                    }
                    if (s11 !== peg$FAILED) {
                      while (s11 !== peg$FAILED) {
                        s10.push(s11);
                        if (peg$c610.test(input.charAt(peg$currPos))) {
                          s11 = input.charAt(peg$currPos);
                          peg$currPos++;
                        } else {
                          s11 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c611); }
                        }
                      }
                    } else {
                      s10 = peg$FAILED;
                    }
                    if (s10 !== peg$FAILED) {
                      s8 = [s8, s9, s10];
                      s7 = s8;
                    } else {
                      peg$currPos = s7;
                      s7 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
                if (s7 === peg$FAILED) {
                  s7 = null;
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse__();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parseRPAREN();
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parse__();
                      if (s10 !== peg$FAILED) {
                        s11 = peg$parsenumeric_type_suffix();
                        if (s11 === peg$FAILED) {
                          s11 = null;
                        }
                        if (s11 !== peg$FAILED) {
                          peg$savedPos = s0;
                          s1 = peg$c1065(s1, s5, s7, s11);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseKW_NUMERIC();
      if (s1 === peg$FAILED) {
        s1 = peg$parseKW_DECIMAL();
        if (s1 === peg$FAILED) {
          s1 = peg$parseKW_INT();
          if (s1 === peg$FAILED) {
            s1 = peg$parseKW_INTEGER();
            if (s1 === peg$FAILED) {
              s1 = peg$parseKW_SMALLINT();
              if (s1 === peg$FAILED) {
                s1 = peg$parseKW_TINYINT();
                if (s1 === peg$FAILED) {
                  s1 = peg$parseKW_BIGINT();
                  if (s1 === peg$FAILED) {
                    s1 = peg$parseKW_FLOAT();
                    if (s1 === peg$FAILED) {
                      s1 = peg$parseKW_DOUBLE();
                    }
                  }
                }
              }
            }
          }
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        if (peg$c610.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c611); }
        }
        if (s3 !== peg$FAILED) {
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            if (peg$c610.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c611); }
            }
          }
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse__();
          if (s3 !== peg$FAILED) {
            s4 = peg$parsenumeric_type_suffix();
            if (s4 === peg$FAILED) {
              s4 = null;
            }
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c1066(s1, s2, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseKW_NUMERIC();
        if (s1 === peg$FAILED) {
          s1 = peg$parseKW_DECIMAL();
          if (s1 === peg$FAILED) {
            s1 = peg$parseKW_INT();
            if (s1 === peg$FAILED) {
              s1 = peg$parseKW_INTEGER();
              if (s1 === peg$FAILED) {
                s1 = peg$parseKW_SMALLINT();
                if (s1 === peg$FAILED) {
                  s1 = peg$parseKW_TINYINT();
                  if (s1 === peg$FAILED) {
                    s1 = peg$parseKW_BIGINT();
                    if (s1 === peg$FAILED) {
                      s1 = peg$parseKW_FLOAT();
                      if (s1 === peg$FAILED) {
                        s1 = peg$parseKW_DOUBLE();
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse__();
          if (s2 !== peg$FAILED) {
            s3 = peg$parsenumeric_type_suffix();
            if (s3 === peg$FAILED) {
              s3 = null;
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$parse__();
              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c1067(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "numeric_type",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "numeric_type",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsedatetime_type() {
    var s0, s1, s2, s3, s4, s5, s6, s7,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "datetime_type",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_DATE();
    if (s1 === peg$FAILED) {
      s1 = peg$parseKW_DATETIME();
      if (s1 === peg$FAILED) {
        s1 = peg$parseKW_TIME();
        if (s1 === peg$FAILED) {
          s1 = peg$parseKW_TIMESTAMP();
        }
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseLPAREN();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = [];
            if (peg$c610.test(input.charAt(peg$currPos))) {
              s6 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c611); }
            }
            if (s6 !== peg$FAILED) {
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                if (peg$c610.test(input.charAt(peg$currPos))) {
                  s6 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c611); }
                }
              }
            } else {
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseRPAREN();
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c1068(s1, s5);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseKW_DATE();
      if (s1 === peg$FAILED) {
        s1 = peg$parseKW_DATETIME();
        if (s1 === peg$FAILED) {
          s1 = peg$parseKW_TIME();
          if (s1 === peg$FAILED) {
            s1 = peg$parseKW_TIMESTAMP();
          }
        }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c1063(s1);
      }
      s0 = s1;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "datetime_type",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "datetime_type",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsejson_type() {
    var s0, s1,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "json_type",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_JSON();
    if (s1 === peg$FAILED) {
      s1 = peg$parseKW_JSONB();
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c1063(s1);
    }
    s0 = s1;

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "json_type",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "json_type",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsegeometry_type() {
    var s0, s1,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "geometry_type",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_GEOMETRY();
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c1069(s1);
    }
    s0 = s1;

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "geometry_type",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "geometry_type",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parsetext_type() {
    var s0, s1, s2, s3, s4,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "text_type",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_TINYTEXT();
    if (s1 === peg$FAILED) {
      s1 = peg$parseKW_TEXT();
      if (s1 === peg$FAILED) {
        s1 = peg$parseKW_MEDIUMTEXT();
        if (s1 === peg$FAILED) {
          s1 = peg$parseKW_LONGTEXT();
        }
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseLBRAKE();
      if (s2 !== peg$FAILED) {
        s3 = peg$parse__();
        if (s3 !== peg$FAILED) {
          s4 = peg$parseRBRAKE();
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c1070(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseKW_TINYTEXT();
      if (s1 === peg$FAILED) {
        s1 = peg$parseKW_TEXT();
        if (s1 === peg$FAILED) {
          s1 = peg$parseKW_MEDIUMTEXT();
          if (s1 === peg$FAILED) {
            s1 = peg$parseKW_LONGTEXT();
          }
        }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c1071(s1);
      }
      s0 = s1;
    }

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "text_type",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "text_type",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }

  function peg$parseuuid_type() {
    var s0, s1,
        startPos = peg$currPos;

    peg$tracer.trace({
      type:     "rule.enter",
      rule:     "uuid_type",
      location: peg$computeLocation(startPos, startPos)
    });

    s0 = peg$currPos;
    s1 = peg$parseKW_UUID();
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c1072(s1);
    }
    s0 = s1;

    if (s0 !== peg$FAILED) {
      peg$tracer.trace({
        type:   "rule.match",
        rule:   "uuid_type",
        result: s0,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: "uuid_type",
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return s0;
  }


    const reservedMap = {
      'ALTER': true,
      'ALL': true,
      'ADD': true,
      'AND': true,
      'AS': true,
      'ASC': true,

      'BETWEEN': true,
      'BY': true,

      // 'CALL': true,
      'CASE': true,
      'CREATE': true,
      'CONTAINS': true,
      'CURRENT_DATE': true,
      'CURRENT_TIME': true,
      'CURRENT_TIMESTAMP': true,
      'CURRENT_USER': true,

      'DELETE': true,
      'DESC': true,
      'DISTINCT': true,
      'DROP': true,

      'ELSE': true,
      'END': true,
      'EXISTS': true,
      'EXPLAIN': true,

      'FALSE': true,
      'FROM': true,
      'FULL': true,

      'GROUP': true,

      'HAVING': true,

      'IN': true,
      'INNER': true,
      'INSERT': true,
      'INTO': true,
      'INTERSECT': true,
      'INTERVAL': true,
      'IS': true,

      'JOIN': true,
      'JSON': true,

      // 'KEY': true,

      'LIKE': true,
      'LIMIT': true,

      'MINUS': true,

      'NOT': true,
      'NULL': true,
      'NULLS': true,

      'ON': true,
      'OR': true,
      'ORDER': true,
      'OUTER': true,

      'RECURSIVE': true,
      'RENAME': true,
      // 'REPLACE': true,
      'RIGHT': true,

      'SELECT': true,
      'SESSION_USER': true,
      'SET': true,
      'SHOW': true,
      'SYSTEM_USER': true,

      'TABLE': true,
      'THEN': true,
      'TRUE': true,
      'TRUNCATE': true,
      'TYPE': true,   // reserved (MySQL)

      'UNION': true,

      'UPDATE': true,
      'USING': true,

      'VALUES': true,

      'WITH': true,
      'WHEN': true,
      'WHERE': true,

      'GLOBAL': true,
      'SESSION': true,
      'LOCAL': true,
      'PERSIST': true,
      'PERSIST_ONLY': true,
    };

    function createUnaryExpr(op, e) {
      return {
        type: 'unary_expr',
        operator: op,
        expr: e
      };
    }

    function createBinaryExpr(op, left, right) {
      return {
        type: 'binary_expr',
        operator: op,
        left: left,
        right: right
      };
    }

    function isBigInt(numberStr) {
      const previousMaxSafe = BigInt(Number.MAX_SAFE_INTEGER)
      const num = BigInt(numberStr)
      if (num < previousMaxSafe) return false
      return true
    }

    function createList(head, tail, po = 3) {
      const result = [head];
      for (let i = 0; i < tail.length; i++) {
        result.push(tail[i][po]);
      }
      return result;
    }

    function createBinaryExprChain(head, tail) {
      let result = head;
      for (let i = 0; i < tail.length; i++) {      
        result = createBinaryExpr(tail[i][1], result, tail[i][3]);
      }

      // console.log(`Binary Expr Chain Result : `)
      // console.log(result)
      return result;
    }

    function queryTableAlias(tableName) {
      const alias = tableAlias[tableName]
      if (alias) return alias
      if (tableName) return tableName
      return null
    }

    function columnListTableAlias(columnList) {
      const newColumnsList = new Set()
      const symbolChar = '::'
      for(let column of columnList.keys()) {
        const columnInfo = column.split(symbolChar)
        if (!columnInfo) {
          newColumnsList.add(column)
          break
        }
        if (columnInfo && columnInfo[1]) columnInfo[1] = queryTableAlias(columnInfo[1])
        newColumnsList.add(columnInfo.join(symbolChar))
      }
      return Array.from(newColumnsList)
    }

    function refreshColumnList(columnList) {
      const columns = columnListTableAlias(columnList)
      columnList.clear()
      columns.forEach(col => columnList.add(col))
    }

    function commonStrToLiteral(strOrLiteral) {
      return typeof strOrLiteral === 'string' ? { type: 'same', value: strOrLiteral } : strOrLiteral
    }

    const cmpPrefixMap = {
      '+': true,
      '-': true,
      '*': true,
      '/': true,
      '>': true,
      '<': true,
      '!': true,
      '=': true,

      //between
      'B': true,
      'b': true,
      //for is or in
      'I': true,
      'i': true,
      //for like
      'L': true,
      'l': true,
      //for not
      'N': true,
      'n': true
    };

    // used for dependency analysis
    let varList = [];

    const tableList = new Set();
    const columnList = new Set();
    const tableAlias = {};


  peg$result = peg$startRuleFunction();

  if (peg$result !== peg$FAILED && peg$currPos === input.length) {
    return peg$result;
  } else {
    if (peg$result !== peg$FAILED && peg$currPos < input.length) {
      peg$fail(peg$endExpectation());
    }

    throw peg$buildStructuredError(
      peg$maxFailExpected,
      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
      peg$maxFailPos < input.length
        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
    );
  }
}

module.exports = {
  SyntaxError:   peg$SyntaxError,
  DefaultTracer: peg$DefaultTracer,
  parse:         peg$parse
};
